<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阿里3月27日笔试算法题记录</title>
    <url>/2020/03/27/%E9%98%BF%E9%87%8C3%E6%9C%8827%E6%97%A5%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>上午参加了阿里巴巴2020-3-27场次的笔试，笔试内容为两道算法题，笔试形式为牛客网在线编程(考试形式)，允许使用本地IDE进行调式。</p>
<p>博主本身算法题基础不是很好，加上是第一次参加这种形式的笔试（需要自己处理输入输出，之前刷LeetCode只需要实现函数就行了），题答的不好，结束后决定把这两道题搞清楚并记录一下。</p>
<hr>
<h4 id="算法题一的大致内容如下："><a href="#算法题一的大致内容如下：" class="headerlink" title="算法题一的大致内容如下："></a>算法题一的大致内容如下：</h4><ul>
<li>两行输入，分别为S和T，每行是一个字符串，字符串S和T长度相等</li>
<li>允许的操作是：将S中任意一个字符移至字符串的末尾</li>
<li>计算需要操作几次可以将S转换为T，输出操作次数；若S无法转换为T，则输出-1</li>
</ul>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ul>
<li><p>输入：</p>
<blockquote>
<p>ackd<br>cdak</p>
</blockquote>
</li>
<li><p>输出</p>
<blockquote>
<p>2</p>
</blockquote>
</li>
</ul>
<h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><ul>
<li><p>首先判断字符串S能否转换为T，即判断S和T中字符出现的次数是都完全一致</p>
</li>
<li><p>接下来寻找S中不需要移动的字符数，即寻找T的最长的一个首部，满足：S中可以找到一个子序列，包含此首部中出现的所有字符，并且这些字符出现的顺序相同。不需要移动的字符数即为此首部的长度。</p>
<p>如上例中T满足要求的最长首部为<code>cd</code>，对应S中的子序列为<code>ckd</code>。</p>
</li>
<li><p>输出需要操作的次数，即为T的长度减去不需要移动的字符数</p>
</li>
</ul>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(S, T)</span>:</span></span><br><span class="line">    <span class="comment"># 首先统计字符串S和T每个字符出现的次数是否相等</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> hashmap:</span><br><span class="line">            hashmap[c] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hashmap[c] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> T:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> hashmap:</span><br><span class="line">            hashmap[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> hashmap.values():</span><br><span class="line">        <span class="keyword">if</span> value != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 然后寻找不需要移动的字符数</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> j &lt; len(T):</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> T[j] != S[i]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(T)-j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    S = sys.stdin.readline().strip()</span><br><span class="line">    T = sys.stdin.readline().strip()</span><br><span class="line">    print(func(S, T))</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="算法题2的大致内容如下："><a href="#算法题2的大致内容如下：" class="headerlink" title="算法题2的大致内容如下："></a>算法题2的大致内容如下：</h4><ul>
<li><p>求n个随机数中最小值的期望值</p>
</li>
<li><p>三行输入，分别为：</p>
<ul>
<li>n:  随机数的个数</li>
<li>l1, l2, … ln  :  l<em>i</em> 为第i个随机数的最小值</li>
<li>r1, r2, … rn  ：r<em>i</em> 为第i个随机数的最大值</li>
</ul>
<p>即第i个随机数的取值区间是 [l<em>i</em>, r<em>i</em>]，取到区间里数字的概率相等</p>
</li>
<li><p>输出为随机数最小值的期望</p>
</li>
<li><p>还有一些关于浮点数的要求（记不清楚了）</p>
</li>
</ul>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><ul>
<li><p>输入：</p>
<blockquote>
<p>2</p>
<p>1 2</p>
<p>3 3</p>
</blockquote>
</li>
<li><p>输出</p>
<blockquote>
<p>1.83333</p>
</blockquote>
</li>
<li><p>解释：</p>
<blockquote>
<p>最小值为1：（1，2）（1，3）：概率为2/6</p>
<p>最小值为2：（2，2）（2，3）（3，2）：概率为3/6</p>
<p>最小值为3：（3，3）：概率为1/6</p>
<p>结果为：1*(2/6) + 2*(3/6) + 3*(1/6) = 1.83333</p>
</blockquote>
</li>
</ul>
<h5 id="解题思路：暴力破解"><a href="#解题思路：暴力破解" class="headerlink" title="解题思路：暴力破解"></a>解题思路：暴力破解</h5><ul>
<li>首先找到n个随机数的所有情况</li>
<li>然后找到最小值的范围</li>
<li>然后寻找每个可能值可能出现的次数并计算概率, 更新期望:<ul>
<li>依次让第i个随机数为num，统计可能的出现的次数</li>
<li>在统计其他位置可能的情况的时候，要略过已经统计过的情况（见代码）</li>
</ul>
</li>
</ul>
<h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(N, LS, RS)</span>:</span></span><br><span class="line">    <span class="comment"># 首先找到n个随机数的所有情况</span></span><br><span class="line">    total = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        total *= (RS[i] - LS[i]) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 然后找到最小值的范围</span></span><br><span class="line">    min_num = min(LS)</span><br><span class="line">    max_num = min(RS)</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 然后寻找每个可能值的概率, 并计算期望: 依次让第i个随机数为num，统计可能的出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(min_num, max_num+<span class="number">1</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            tmp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> LS[i] &lt;= num &lt;= RS[i]:  <span class="comment"># 第i个随机数可以取到num才计算：</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                    <span class="keyword">if</span> j != i:  <span class="comment"># 统计其他位置可能的情况</span></span><br><span class="line">                        <span class="keyword">if</span> j &lt; i <span class="keyword">and</span> LS[j] &lt;= num:  <span class="comment"># 略过已经统计过的情况</span></span><br><span class="line">                            pro = min(RS[j] - LS[j], RS[j]-num)  <span class="comment">#例如：示例中统计最小值为2的情况时，取第一位为2，有(2, 2),(2,3);取第二位为2时，应略过(2, 2), 此时只有(3,2)</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            pro = min(RS[j] - LS[j], RS[j] - num) + <span class="number">1</span></span><br><span class="line">                        tmp *= pro</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = <span class="number">0</span></span><br><span class="line">            count += tmp</span><br><span class="line">        p = count / total  <span class="comment"># 计算概率</span></span><br><span class="line">        ans += num*p  <span class="comment"># 更新期望</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = int(sys.stdin.readline())</span><br><span class="line">    line = sys.stdin.readline().strip()</span><br><span class="line">    ls = list(map(int, line.split()))</span><br><span class="line">    line = sys.stdin.readline().strip()</span><br><span class="line">    rs = list(map(int, line.split()))</span><br><span class="line">    print(func(n, ls, rs))</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>笔试时间为一个小时，调试第一题不知不觉就花了半个多小时，第二题慌慌张张只写了一个大概，跑通是不可能跑通的。</p>
<p>看来以后刷题的时候要刻意的控制下解题时间，不可以像现在这样慢慢的做。</p>
<p>有了思路之后要多考虑几个测试用例，不然写到一半或者写完测试时发现思路是错的，再改也没有时间了。</p>
<blockquote>
<p>文中有什么错误或者不足之处，欢迎指出~</p>
<p>题二有什么更好的解法也欢迎指教~</p>
</blockquote>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>阿里</tag>
        <tag>笔试</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内置模块bisect</title>
    <url>/2020/03/25/Python3%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97bisect/</url>
    <content><![CDATA[<h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p><code>bisect</code>模块是Python内置的一个功能模块，这个模块的功能是在对列表<code>list</code>进行插入操作时，维护列表保持有序的状态。使用<code>bisect</code>模块中的方法时需要满足一个条件，即<strong>执行插入操作的列表<code>list</code>本身需要是有序的。</strong></p>
<hr>
<h4 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h4><p><code>bisect</code> 模块包含如下四个主要函数，这四个函数都利用二分查找算法来在有序列表中查找或者插入元素。</p>
<h5 id="1-bisect-a-x-lo-0-hi-None"><a href="#1-bisect-a-x-lo-0-hi-None" class="headerlink" title="1. bisect(a, x, lo=0, hi=None):"></a>1. bisect(a, x, lo=0, hi=None):</h5><ul>
<li><p>此函数其实是<code>bisect_right()</code>的别名，函数的作用是返回元素x在列表a中的插入位置，a需要是有序的。</p>
</li>
<li><p>如果存在与x相等的元素，返回的结果是最后x出现位置的下一位。</p>
</li>
<li><p>参数lo和hi指定了查找范围。</p>
</li>
<li><p>源码：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<h5 id="2-insort-a-x-lo-0-hi-None-："><a href="#2-insort-a-x-lo-0-hi-None-：" class="headerlink" title="2. insort(a, x, lo=0, hi=None)："></a>2. insort(a, x, lo=0, hi=None)：</h5><ul>
<li>此函数其实是<code>insort_right()</code>的别名，函数的作用是在列表a中插入元素x，并保持列表a有序。</li>
<li>如果存在与x相等的元素，则插入在最后一个x的右侧。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br></pre></td></tr></table></figure>

<h5 id="3-bisect-left-a-x-lo-0-hi-None"><a href="#3-bisect-left-a-x-lo-0-hi-None" class="headerlink" title="3. bisect_left(a, x, lo=0, hi=None):"></a>3. bisect_left(a, x, lo=0, hi=None):</h5><ul>
<li>函数作用同样是返回元素x在列表a中的插入位置。</li>
<li>但如果存在与x相等的元素，返回的结果是第一个x出现位置。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<h5 id="4-insort-left-a-x-lo-0-hi-None"><a href="#4-insort-left-a-x-lo-0-hi-None" class="headerlink" title="4. insort_left(a, x, lo=0, hi=None):"></a>4. insort_left(a, x, lo=0, hi=None):</h5><ul>
<li>函数的作用同样是在列表a中插入元素x，并保持列表a有序。</li>
<li>但如果存在与x相等的元素，则插入在第一个x的左侧。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="与list内置index-性能的比较："><a href="#与list内置index-性能的比较：" class="headerlink" title="与list内置index()性能的比较："></a>与<code>list</code>内置<code>index()</code>性能的比较：</h4><p>由<code>bisect</code>的源码可以看出，<code>bisect</code>模块内的函数使用<strong>二分查找</strong>的方式来加快<strong>寻找元素插入位置</strong>。对于<strong>插入元素，并保持列表有序</strong> 这样的操作要求我们可以结合<code>list</code>内置的<code>index()</code>函数与<code>insert()</code>函数来实现相同的效果。但由于<code>index()</code>函数是采用顺序查找的方式，故<code>bisect</code>模块的效率应高于<code>list</code>内置的<code>index()</code>函数。</p>
<h5 id="1-list-内置index-函数源码："><a href="#1-list-内置index-函数源码：" class="headerlink" title="1.  list 内置index()函数源码："></a>1.  <code>list</code> 内置<code>index()</code>函数源码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*[clinic input]</span></span><br><span class="line"><span class="comment">list.index</span></span><br><span class="line"><span class="comment">    value: object</span></span><br><span class="line"><span class="comment">    start: slice_index(accept=&#123;int&#125;) = 0</span></span><br><span class="line"><span class="comment">    stop: slice_index(accept=&#123;int&#125;, c_default="PY_SSIZE_T_MAX") = sys.maxsize</span></span><br><span class="line"><span class="comment">    /</span></span><br><span class="line"><span class="comment">Return first index of value.</span></span><br><span class="line"><span class="comment">Raises ValueError if the value is not present.</span></span><br><span class="line"><span class="comment">[clinic start generated code]*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">list_index_impl(PyListObject *self, PyObject *value, Py_ssize_t start,</span><br><span class="line">                Py_ssize_t <span class="built_in">stop</span>)</span><br><span class="line"><span class="comment">/*[clinic end generated code: output=ec51b88787e4e481 input=40ec5826303a0eb1]*/</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stop</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stop</span> += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stop</span> &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; <span class="built_in">stop</span> &amp;&amp; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="keyword">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> PyLong_FromSsize_t(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_Format(PyExc_ValueError, <span class="string">"%R is not in list"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出<code>index()</code>函数是从<code>start</code>到<code>stop</code>顺序遍历的。</li>
</ul>
<h5 id="2-效率比较"><a href="#2-效率比较" class="headerlink" title="2. 效率比较"></a>2. 效率比较</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">list_ = list(range(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    list_.index(i)  <span class="comment"># 查找list中的每一个元素</span></span><br><span class="line">print(time.time() - start)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    bisect.bisect(list_, i)  <span class="comment"># 查找list中的每一个元素</span></span><br><span class="line">print(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 1.013824462890625</span></span><br><span class="line"><span class="comment"># 0.007440805435180664</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>bisect</code>模块的功能和实现都较为简单，通过调用此模块可以来让我们的代码更简洁。当然了，我们也可以自己实现二分查找的过程。</p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>python内置模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 多表插入操作 insert all/first子句</title>
    <url>/2020/03/20/Oracle-insert-all-first%E5%AD%90%E5%8F%A5/</url>
    <content><![CDATA[<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>在Oracle 中如果需要将一个子查询得到的数据进行多表插入操作的话，可以使用insert all/first 子句进行操作，相比使用多次单表插入效率会更高，因为主表只访问了一次。</p>
<hr>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/INSERT.html#GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank" rel="noopener">多表插入操作</a> 可以分为<strong>有条件</strong>插入和<strong>无条件</strong>插入两种：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200320210500.png"  />

<ul>
<li><p>执行<strong>有条件插入</strong>时，可以选择<strong>insert all/first</strong>子句来执行不同的插入策略。</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200320211224.png" style="zoom:80%;" />

<ul>
<li>一条多表插入操作的SQL语句最多支持<strong>127</strong>个<strong>when</strong>子句。</li>
</ul>
<p>两者的区别在于：</p>
<ul>
<li>insert all: 会对每个when条件进行匹配，如果满足则插入</li>
<li>insert first: 数据库会将数据依次对when条件进行匹配，遇到满足条件的when条件就进行插入，并且跳过之后的when条件的判断。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/insert all-first.png" style="zoom:80%;" />

<hr>
<h4 id="简单示例："><a href="#简单示例：" class="headerlink" title="简单示例："></a>简单示例：</h4><h5 id="1-数据准备："><a href="#1-数据准备：" class="headerlink" title="1. 数据准备："></a>1. 数据准备：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_a(a <span class="built_in">number</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_b <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_c <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-insert-all"><a href="#2-insert-all" class="headerlink" title="2.  insert all"></a>2.  insert all</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert all</span><br><span class="line">	when a &lt;&#x3D; 2 then into table_b</span><br><span class="line">	when a &lt;&#x3D; 5 then into table_c</span><br><span class="line">select * from table_a;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：</p>
<table>
<thead>
<tr>
<th>表</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>table_a</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
<tr>
<td>table_b</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>table_c</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
</tbody></table>
<blockquote>
<p>数据1和2同时满足两个when条件，两个表都进行了插入。</p>
</blockquote>
</li>
</ul>
<h5 id="3-insert-first"><a href="#3-insert-first" class="headerlink" title="3. insert first"></a>3. insert first</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">first</span></span><br><span class="line">	<span class="keyword">when</span> a &lt;= <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">into</span> table_b</span><br><span class="line">	<span class="keyword">when</span> a &lt;= <span class="number">5</span> <span class="keyword">then</span> <span class="keyword">into</span> table_c</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：</p>
<table>
<thead>
<tr>
<th>表</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>table_a</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
<tr>
<td>table_b</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>table_c</td>
<td>[3, 4, 5]</td>
</tr>
</tbody></table>
<blockquote>
<p>数据1和2同时满足两个when条件，但插入了第一个表后就跳过了第二个when条件的检查。</p>
</blockquote>
</li>
</ul>
<p>推荐使用Oracle 的<a href="https://livesql.oracle.com/apex/f?p=590:1:1114621173697::NO:RP::" target="_blank" rel="noopener">Live SQL</a>动手测试一下。</p>
<p>更多的示例可以参考Oracle官方文档 <a href="https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/INSERT.html#GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank" rel="noopener"><strong>Multitable Inserts: Examples</strong></a></p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3中sort()/sorted()自定义排序规则</title>
    <url>/2020/03/17/Python3%E4%B8%ADsort-sorted%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h4 id="问题：面试题45-把数组排成最小的数——《剑指Offer》"><a href="#问题：面试题45-把数组排成最小的数——《剑指Offer》" class="headerlink" title="问题：面试题45. 把数组排成最小的数——《剑指Offer》"></a>问题：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">面试题45. 把数组排成最小的数——《剑指Offer》</a></h4><p>先来看这样一道算法题：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200317161920.png" alt=""></p>
<p>解题思路：</p>
<ul>
<li>找到一个排序规则，数组根据这个规则排序后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就是给出两个数字<code>m</code>和<code>n</code>,我们需要确定一个规则来判断<code>m</code>和<code>n</code>哪个应该排在前面，而不是仅仅比较这两个数字的值的大小。</li>
</ul>
<p>排序规则设计：</p>
<ul>
<li>根据题目的要求，两个数字<code>m</code>和<code>n</code>能拼接成数字<code>mn</code>和<code>nm</code>。如果<code>mn</code>&lt;<code>nm</code>，那么我们应该打印<code>mn</code>，也就是<code>m</code>应该排在<code>n</code>的前面，此时我们定义<code>m</code>小于<code>n</code>；反之，如果<code>mn</code>&gt;<code>nm</code>，我们定义<code>m</code>大于<code>n</code>。</li>
</ul>
<hr>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><ul>
<li><p>基于以上排序规则，我们可以实现如下的排序函数：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="comment"># 将数组元素转换为str,是为了处理大数问题</span></span><br><span class="line">    str1 = m + n</span><br><span class="line">    str2 = n + m</span><br><span class="line">    <span class="keyword">if</span> str1 &lt; str2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> str1 &gt; str2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自定义的排序规则函数进行排序</p>
<p><code>nums</code>的排序可以使用<code>sort()</code>或者<code>sorted()</code>，但要注意的是：在Python3版本中，<code>sort()</code>以及<code>sorted()</code>都舍弃了<code>cmp</code>参数，引进了新的<code>key</code>参数，</p>
<ul>
<li><p><strong>cmp:</strong> 接受两个参数<code>a</code>和<code>b</code>，然后根据它们的大小关系返回不同的值：<code>a &lt; b</code>时返回负值，<code>a &gt; b</code>时返回正值，<code>a = b</code>时返回0。</p>
</li>
<li><p><strong>key:</strong> 接收一个参数，返回一个可比较对象。新的<code>key</code>函数这种模式并不直接比较任意两个原始元素，而是通过<code>key</code>函数把那些元素转换成一个个新的可比较对象，也就是元素的key，然后用元素的key代替元素去参与比较。</p>
</li>
</ul>
</li>
<li><p>如果我们习惯了Python2中<code>cmp</code>参数格式的写法，可以使用<a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" target="_blank" rel="noopener">functools.cmp_to_key()</a>函数进行转换，它相当于旧接口和新接口的转换器。完整代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            str1 = a + b</span><br><span class="line">            str2 = b + a</span><br><span class="line">            <span class="keyword">if</span> str1 &lt; str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> str1 &gt; str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=functools.cmp_to_key(compare)))</span><br></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>其实很巧妙，Python对象的比较过程可以用<code>__lt__</code>等函数重写，<code>cmp_to_key</code>的返回值也是一个重写了比较过程的对象，在调用自定义比较过程时会调用输入的比较函数，从而实现了设计目标。以下是<code>cmp_to_key()</code>的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_to_key</span><span class="params">(mycmp)</span>:</span></span><br><span class="line">    <span class="string">"""Convert a cmp= function into a key= function"""</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">K</span><span class="params">(object)</span>:</span></span><br><span class="line">        __slots__ = [<span class="string">'obj'</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">            self.obj = obj</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) == <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) != <span class="number">0</span></span><br><span class="line">        __hash__ = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>cmp_to_key()</code>函数返回的是一个类对象，在这里重载了进行元素比较的各个函数。</p>
<hr>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h4><ul>
<li><p>如果我们不想使用<code>cmp_to_key()</code>函数进行转换，我们也可以自己实现一个这样的类对象，只需重载其中的<code>__lt__</code>函数即可，完整代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Compare</span><span class="params">(str)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> self + s &lt; s + self</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=Compare))</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>cmp_to_key()</code>这种形式时，还可以利用<code>lambda</code>表达式来代替自定义排序规则函数，达到简化代码的效果，等效代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">import</span> functools</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=functools.cmp_to_key(<span class="keyword">lambda</span> x, y: int(x+y)-int(y+x))))</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较：</p>
<blockquote>
<p>This(key) is easier to use and faster to run. When using the cmp parameter, the sorting compares pairs of values, so the compare-function is called multiple times for every item. The larger the set of data, the more times the compare-function is called per item. With the key function the sorting instead keeps the key value for each item and compares those, so the key function is only called once for every item. This results in much faster sorts for large sets of data.</p>
<p>查看 <a href="http://python3porting.com/preparing.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p><strong>1. sort()与sorted()基础知识</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>sort()</th>
<th>sorted()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">调用方式</td>
<td><code>list1.sort()</code></td>
<td><code>sort(list1)</code></td>
</tr>
<tr>
<td align="center">返回值</td>
<td>自身被排序，没有返回值</td>
<td>返回一个新的排序好的list</td>
</tr>
<tr>
<td align="center">适用性</td>
<td>只适用于list</td>
<td>适用于所有可迭代序列</td>
</tr>
</tbody></table>
<ul>
<li>都有一个<code>reverse</code> 参数，指定升序或降序，默认为<code>False</code>(升序)</li>
<li>都有一个<code>key</code> 参数，此参数为一个只有一个参数的函数，这个函数会应用在序列里的每个元素, 所产生的结果将是排序算法依赖的对比关键字。默认值为恒等函数，即默认用元素自己的值来排序。</li>
<li>两个函数都是稳定的，即具有相同顺序的元素排序后还是原来的顺序。</li>
</ul>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3中queue模块及常用方法</title>
    <url>/2020/03/07/Python3%E4%B8%ADqueue%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Python3中的<code>queue</code>模块对应数据结构中<code>队列</code>的概念，实现了一些基本的队列操作。</p>
</blockquote>
<h4 id="一、queue-Queue-maxsize-0"><a href="#一、queue-Queue-maxsize-0" class="headerlink" title="一、queue.Queue(maxsize=0)"></a>一、queue.Queue(maxsize=0)</h4><ul>
<li><p>普通<code>FIFO</code>队列</p>
<p>  初始化时指定 <code>maxsize</code>参数可设定队列的最大容量， 若<code>maxsize &lt;= 0</code>，则队列容量无限。</p>
<p>  常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td>如果队列为空，返回True</td>
<td></td>
</tr>
<tr>
<td>full()</td>
<td>如果队满，返回True</td>
<td></td>
</tr>
<tr>
<td>put()</td>
<td>向队列添加元素</td>
<td></td>
</tr>
<tr>
<td>get()</td>
<td>从队列取元素，并从队列删除该元素</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="二、queue-deque"><a href="#二、queue-deque" class="headerlink" title="二、queue.deque()"></a>二、queue.deque()</h4><ul>
<li><p>双端队列</p>
<p>  其实是<code>collections.deque</code>模块。<code>deque()</code> 的设计是为了在两端实现高效的插入和删除操作。</p>
<p>  常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>在队列右侧添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>appendleft()</td>
<td>在队列左侧添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>clear()</td>
<td>删除所有元素</td>
<td></td>
</tr>
<tr>
<td>copy()</td>
<td>浅拷贝</td>
<td>O(n)</td>
</tr>
<tr>
<td>count(value)</td>
<td>统计Value出现的次数</td>
<td></td>
</tr>
<tr>
<td>extend(value)</td>
<td>Extend the right side of the deque with elements from the iterable</td>
<td>O(k)</td>
</tr>
<tr>
<td>extendleft</td>
<td>Extend the left side of the deque with elements from the iterable</td>
<td>O(k)</td>
</tr>
<tr>
<td>index(value)</td>
<td>返回value的第一个位置的索引</td>
<td></td>
</tr>
<tr>
<td>insert(index, value)</td>
<td>在指定位置插入元素</td>
<td></td>
</tr>
<tr>
<td>pop()</td>
<td>Remove and return the rightmost element</td>
<td>O(1)</td>
</tr>
<tr>
<td>popleft()</td>
<td>Remove and return the leftmost element</td>
<td>O(1)</td>
</tr>
<tr>
<td>remove(value)</td>
<td>remove first occurrence of value</td>
<td>O(n)</td>
</tr>
<tr>
<td>reverse()</td>
<td>reverse IN PLACE</td>
<td></td>
</tr>
<tr>
<td>rotate()</td>
<td>Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left</td>
<td>O(k)</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="三、与list的对比"><a href="#三、与list的对比" class="headerlink" title="三、与list的对比"></a>三、与list的对比</h4><p>我们有时为了方便会使用<code>list</code>这一数据类型来模拟队列的实现，但在某些功能实现的效率上会有所不同。比如：</p>
<ol>
<li><p>从队列中弹出队首元素</p>
<ul>
<li><p><code>list</code>:<br> 实现方式：<code>pop(0)</code> </p>
<ul>
<li><p><code>deque</code>：<br>实现方式：<code>popleft()</code></p>
</li>
<li><p><code>Queue</code>：<br>实现方式：<code>get()</code></p>
</li>
<li><p>以下是三种方法的时间复杂度比较：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>pop(0)</td>
<td>O(n)</td>
</tr>
<tr>
<td>popleft()</td>
<td>O(1)</td>
</tr>
<tr>
<td>get()</td>
<td>O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p><code>list</code> 中pop()函数不加参数时间复杂度为O(1)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>python内置模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3使用‘*’初始化list的陷阱</title>
    <url>/2020/03/06/Python3%E4%BD%BF%E7%94%A8%E2%80%98%E2%80%BB%E2%80%99%E5%88%9D%E5%A7%8B%E5%8C%96list%E7%9A%84%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<ul>
<li><p>问题发现：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [[<span class="number">0</span>]*<span class="number">2</span>]*<span class="number">3</span></span><br><span class="line">list2 = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">list1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">list2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(list1)  <span class="comment"># [[1, 0], [1, 0], [1, 0]]</span></span><br><span class="line">print(list2)  <span class="comment"># [[1, 0], [0, 0], [0, 0]]</span></span><br></pre></td></tr></table></figure>
<p>  在上述示例代码中，list1, list2这两种初始化的方式都会得到 [[0, 0], [0, 0]] 这样的list。<br>  但在我们想要修改list1以及list2的[0][0]位置的值时，我们发现list2中修改结果如我们所愿，而list1中所有元素均被修改。</p>
</li>
<li><p>解释：<br>在Python3中，list1 以及list2 两种初始化方式分别对应如下两种方式：</p>
<ul>
<li>list1<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, list1 &#x3D; [0]*2, []</span><br><span class="line">for i in range(3):    </span><br><span class="line">    list1.append(x)</span><br></pre></td></tr></table></figure></li>
<li>list2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list2 &#x3D; []</span><br><span class="line">for i in range(3):</span><br><span class="line">    x &#x3D; [0]*2</span><br><span class="line">    list2.append(x)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  <strong>list1:</strong> 将同一个对象x添加到list1当中三次，即list1中三个元素为同一个对象<br>  <strong>list2:</strong> 每次迭代创建一个新的对象，并将其添加到list2中</p>
</li>
<li><p>验证：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(list1[<span class="number">0</span>] <span class="keyword">is</span> list1[<span class="number">1</span>])  <span class="comment"># True</span></span><br><span class="line">print(list2[<span class="number">0</span>] <span class="keyword">is</span> list2[<span class="number">1</span>])  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次网络配置故障排查记录</title>
    <url>/2020/03/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="一、问题出现"><a href="#一、问题出现" class="headerlink" title="一、问题出现"></a>一、问题出现</h4><p>问题源自之前做的一个项目，客户换了新电脑之后，无论如何都打不开软件。</p>
<p>在多台电脑上测试后，都可以正常运行，唯独客户打不开，简单检查排除了软件自身的原因。</p>
<p>之后经过长时间检查，发现是客户新电脑网络配置的问题，以此文来记录下排查故障的过程和问题解决的方式。</p>
<hr>
<h4 id="二、基本环境"><a href="#二、基本环境" class="headerlink" title="二、基本环境"></a>二、基本环境</h4><ul>
<li>项目基础：<ol>
<li><code>Python3</code> + <code>PyQt5</code> 制作的桌面应用程序，在win10系统下使用，主要使用的模块还有<code>requests</code>；</li>
<li>使用<code>pyinstaller</code> 打包成单个exe程序，无需客户配置程序运行环境；</li>
</ol>
</li>
<li>客观因素：客户网络不是很好，网速比较慢</li>
</ul>
<h4 id="三、排查故障及解决过程"><a href="#三、排查故障及解决过程" class="headerlink" title="三、排查故障及解决过程"></a>三、排查故障及解决过程</h4><ol>
<li><p>错误提示<br> 客户每次运行软件，都会弹出<code>Failed to execute script ***</code>的错误提示窗口，此外没有其他信息。</p>
</li>
<li><p>重新打包<br> 之前的打包方式为 <code>pyinstall -F -w ***.py</code>，生成的为不带命令行窗口的单个EXE文件。为了查看更多、更详细的错误提示信息，需要重新打包软件，使用以下命令可以打包成使用命令行窗口执行的EXE文件。<br> <code>pyinstall -F -c ***.py</code><br> 在命令行窗口中再次运行程序，观察命令行窗口错误信息，主要有如下信息：<br> <img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/error.png" alt=""><br> 发现是在通过 <code>requests</code>库连接目标网址的时候，连接失败了。</p>
<blockquote>
<p> 考虑到客户说他网络不好，首先怀疑是网速的原因，但通过在浏览器网页打开目标网站的速度来看，应该不是由网速引起的，决定进一步排查。</p>
</blockquote>
</li>
<li><p>检查网络配置<br> 借助win10 自带工具<code>ping</code> 和 <code>telnet</code> 在命令行窗口排查故障</p>
<ul>
<li><p>在命令行中 <code>ping www.目标网址.com</code> ：<strong>提示找不到主机，请检查名称，然后重试。</strong>（博主自己的电脑可以）</p>
</li>
<li><p>在命令行中 <code>ping www.baidu.com</code>：ping 不通，同样的提示信息。</p>
</li>
<li><p>在命令行中 <code>telnet www.目标网址.com 443</code>：<strong>提示无法打开到主机的连接，在端口443，连接失败。</strong>（博主自己的电脑可以）</p>
</li>
<li><p>在命令行中 <code>ping 221.**.**.190(目标网址IP)</code>：可以ping通</p>
</li>
<li><p>在命令行中 <code>ping 111.206.223.172(百度网址的IP)</code>：可以ping通</p>
<p>可以发现客户电脑在 <code>ping</code> 域名时无法ping通，在直接 <code>ping</code>IP地址时可以ping通。推测是客户电脑在解析域名为IP地址时发生问题。</p>
</li>
<li><p>在命令行中 <code>nslookup www.目标网址.com</code>：失败（意料之中）</p>
</li>
<li><p>在命令行中 <code>nslookup www.baidu.com</code>：失败</p>
<p>由此可以判断是客户电脑DNS配置有问题，在解析域名时失败。</p>
</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>配置DNS服务器<strong>手动模式</strong>，输入<code>8.8.8.8</code></li>
<li>在命令行中刷新DNS缓存，执行 <code>ipconfig /flushdns</code></li>
<li>在命令行中（管理员身份）重置网络配置，执行 <code>netsh winsock reset</code></li>
<li>重新启动</li>
</ul>
</li>
</ol>
<hr>
<h4 id="四、事后"><a href="#四、事后" class="headerlink" title="四、事后"></a>四、事后</h4><p>通过一步一步的排查故障，到最后解决之后，感觉浑身通畅、无比舒服，也许这就是计算机的魅力之处吧</p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub搭建部署个人网站</title>
    <url>/2020/02/29/Hexo-GitHub%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><ul>
<li>安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
<li>安装 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li>
</ul>
<hr>
<h4 id="二、安装配置Hexo"><a href="#二、安装配置Hexo" class="headerlink" title="二、安装配置Hexo"></a>二、安装配置Hexo</h4><ol>
<li><p>安装</p>
<p>打开Git-bash，输入以下命令安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<br>选择合适的文件夹，如 <code>E:\hexo</code>，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd E:\hexo</span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>执行成功后，在 <code>hexo</code>文件夹下的目录结构类似为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _config.yml </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source|   </span><br><span class="line">├       ├── _drafts|   </span><br><span class="line">├       └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<ul>
<li>_config.yml: 网站的配置 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 文件，可以在此配置大部分的参数。</li>
<li>文件详细介绍可见 <a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">Hexo 官方网站</a></li>
</ul>
</li>
<li><p>测试，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>按照信息提示，使用浏览器访问 <code>http://localhost:4000/</code>。可以看到Hexo默认主题则说明本地建站成功。</p>
</li>
<li><p>修改主题</p>
<p>本网站使用的是 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next 主题</a></p>
<ul>
<li><p>下载主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用主题<br>修改 <code>_config.yml</code> 文件，找到 <code>theme</code>字段，并将其值改为 <code>next</code></p>
</li>
<li><p>验证主题<br>执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p> 此时使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行 <code>Next</code>主题。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="三、配置GitHub"><a href="#三、配置GitHub" class="headerlink" title="三、配置GitHub"></a>三、配置GitHub</h4><ul>
<li><p>创建仓库</p>
<p>新建一个名为<code>GitHub账户名.github.io</code>的仓库，之后网站的访问网址就是<code>http://GitHub账户名.github.io</code></p>
</li>
</ul>
<hr>
<h4 id="四、将Hexo部署到GitHub-Pages"><a href="#四、将Hexo部署到GitHub-Pages" class="headerlink" title="四、将Hexo部署到GitHub Pages"></a>四、将Hexo部署到GitHub Pages</h4><ol>
<li><p>安装 <code>hexo-deploy-git</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>_config.yml</code> 文件，找到<code>deploy</code> 配置项，修改为如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo:  https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt; </span><br><span class="line">    #示例：https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io </span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>注：要确保可以向 <code>GitHub</code>正常 <code>Push</code>，若出错，请检查是否配置好了<code>ssh key</code></p>
</li>
<li><p>验证部署<br>使用浏览器打开 <code>http://GitHub账户名.github.io</code>，验证是否部署成功。</p>
</li>
</ol>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
