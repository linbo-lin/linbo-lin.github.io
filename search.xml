<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机基础—Linux</title>
    <url>/2020/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94Linux/</url>
    <content><![CDATA[<h4 id="1-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别"><a href="#1-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别" class="headerlink" title="1. Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别"></a>1. Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别</h4><p>I/O过程包括两个阶段：数据准备阶段（内核从设备读取数据到内核空间的缓冲区）；数据复制阶段（内核空间复制回用户进程缓冲区阶段）</p>
<ul>
<li>阻塞I/O：</li>
</ul>
<p>I/O进程在数据准备阶段阻塞，等待数据准备完成；在数据复制阶段也阻塞，等待数据复制完成；</p>
<ul>
<li>非阻塞I/O：</li>
</ul>
<p>I/O进程在数据准备阶段不阻塞，但是会来轮询数据是否准备完成；在数据复制杰顿会阻塞，等待数据复制完成；</p>
<ul>
<li>I/O复用模型：</li>
</ul>
<p>使用select、poll、epoll进行I/O调用，在数据准备阶段会阻塞于select、poll、epoll，单个进程可以同时处理多个连接的I/O，当有数据准备完成后，通知用户进程；在数据复制阶段会阻塞，等待数据复制完成；</p>
<p>以上都属于同步I/O。</p>
<ul>
<li>异步I/O：</li>
</ul>
<p>在数据准备阶段不阻塞，在数据复制阶段也不阻塞，数据准备完成后，内核执行复制，完成后给用户进程发送一个完成的信号。</p>
<p><strong>参考：</strong><a href="https://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">同步I/O、异步I/O …</a></p>
<h4 id="2-I-O复用的三种方法（select、poll、epoll）深入理解，包括三者区别，内部实现原理"><a href="#2-I-O复用的三种方法（select、poll、epoll）深入理解，包括三者区别，内部实现原理" class="headerlink" title="2. I/O复用的三种方法（select、poll、epoll）深入理解，包括三者区别，内部实现原理"></a>2. I/O复用的三种方法（select、poll、epoll）深入理解，包括三者区别，内部实现原理</h4><p>参考：</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/397449cadc9a" target="_blank" rel="noopener">I/O多路复用的三种机制</a></p>
</li>
<li><p><a href="https://blog.csdn.net/davidsguo008/article/details/73556811" target="_blank" rel="noopener">深入理解select、poll和epoll</a></p>
</li>
</ul>
<h4 id="3-Epoll的ET模式和LT模式"><a href="#3-Epoll的ET模式和LT模式" class="headerlink" title="3. Epoll的ET模式和LT模式"></a>3. Epoll的ET模式和LT模式</h4><ul>
<li><a href="https://www.jianshu.com/p/397449cadc9a" target="_blank" rel="noopener">I/O多路复用的三种机制</a></li>
</ul>
<h4 id="4-查询进程占用CPU的命令"><a href="#4-查询进程占用CPU的命令" class="headerlink" title="4. 查询进程占用CPU的命令"></a>4. 查询进程占用CPU的命令</h4><ul>
<li>top命令</li>
<li>uptime命令</li>
<li>w命令</li>
<li>vmstat</li>
</ul>
<h4 id="5-硬链接和软链接"><a href="#5-硬链接和软链接" class="headerlink" title="5. 硬链接和软链接"></a>5. 硬链接和软链接</h4><p>在Linux系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号（Inode Index）。在Linux中，多个文件名指向同一索引节点是存在的。</p>
<ul>
<li>硬链接</li>
</ul>
<p>A是B的硬链接（A和B是文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。即删除任何一个都不会影响另一个的访问。</p>
<ul>
<li>软连接</li>
</ul>
<p>又称符号链接。软链接有点类似于Windows中的快捷方式。它实际上是一个特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一个文件的位置信息。比如，A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是主从关系，如果B被删除了，A仍然存在，但指向的是一个无效的链接。</p>
<h4 id="6-文件权限怎么看"><a href="#6-文件权限怎么看" class="headerlink" title="6. 文件权限怎么看"></a>6. 文件权限怎么看</h4><p><code>ls -l ***</code></p>
<ul>
<li>r：读权限read 4</li>
<li>w：写权限write 2</li>
<li>x：操作权限execute 1</li>
</ul>
<h4 id="7-文件的三种时间（mtime-atime-ctime），分别在什么时候会改变"><a href="#7-文件的三种时间（mtime-atime-ctime），分别在什么时候会改变" class="headerlink" title="7. 文件的三种时间（mtime/atime/ctime），分别在什么时候会改变"></a>7. 文件的三种时间（mtime/atime/ctime），分别在什么时候会改变</h4><ul>
<li>mtime：修改时间，文件的内容被最后一次修改的时间。当对文件进行修改的时候，它的mtime就会被修改。</li>
<li>atime：访问时间，对文件进行一次读操作，它的访问时间就会改变。例如，向cat、more等命令操作，但ls命令对atime是不会有影响的。</li>
<li>ctime：状态时间，当文件的状态被改变的时候，状态时间就会随之改变。例如，当使用chmod，chown等改变文件属性的操作是会改变文件的ctime的。</li>
</ul>
<h4 id="8-Linux查看网络带宽的命令，查看特定进程的占用网络资源情况的命令"><a href="#8-Linux查看网络带宽的命令，查看特定进程的占用网络资源情况的命令" class="headerlink" title="8. Linux查看网络带宽的命令，查看特定进程的占用网络资源情况的命令"></a>8. Linux查看网络带宽的命令，查看特定进程的占用网络资源情况的命令</h4><p>参考：<a href="https://blog.csdn.net/weixin_41563161/article/details/104164030" target="_blank" rel="noopener">Linux面试题汇总</a></p>
<ul>
<li>监控总体带宽使用：nload，bmon等</li>
<li>监控总体带宽使用（批量式输出）：vnstat/ifstat</li>
<li>每个套接字连接的带宽使用：iftop/iptrap</li>
<li>每个进程的带宽使用：nethogs</li>
</ul>
<h4 id="9-怎么修改一个文件的权限"><a href="#9-怎么修改一个文件的权限" class="headerlink" title="9. 怎么修改一个文件的权限"></a>9. 怎么修改一个文件的权限</h4><ul>
<li>chmod abc filename：改变权限</li>
<li>chown [-R] 账号 目录：更改拥有者</li>
</ul>
<h4 id="10-查看文件内容"><a href="#10-查看文件内容" class="headerlink" title="10. 查看文件内容"></a>10. 查看文件内容</h4><p><a href="https://www.runoob.com/linux/linux-comm-cat.html" target="_blank" rel="noopener">cat:</a></p>
<p>cat 命令用于连接文件并打印到标准输出设备上，一次显示全部数据。</p>
<p><strong>可选参数：</strong></p>
<ul>
<li><p>-n: 显示行号（从1开始）</p>
</li>
<li><p>-b: 显示行号，但空行不显示</p>
</li>
<li><p>-s: 连续两个及以上空行，替换为一个空行</p>
</li>
<li><p>-E: 在每行结束时显示<code>$</code></p>
</li>
</ul>
<p><a href="http://linux.51yip.com/search/tac" target="_blank" rel="noopener">tac:</a></p>
<p>将文件全部内容从尾到头连续输出到标准输出上。</p>
<p><a href="https://www.cnblogs.com/peida/archive/2012/11/01/2749048.html" target="_blank" rel="noopener">nl:</a> </p>
<p>带行号查看文件，默认空行不列出行号，类似<code>cat -b</code></p>
<p><strong>参数配置：</strong></p>
<ul>
<li><p>-b: 指定行号显示的方式；<code>-b a</code>表示无论是否为空行，都列出行号，类似<code>cat -n</code>；<code>-b t</code>表示如果有空行，空行不列出行号（默认值）。</p>
</li>
<li><p>-n: 列出行号表示的方法；<code>-n ln</code>行号靠左显示；<code>-n rn</code>行号靠右显示，且不加<code>0</code>(占位，如<code>00001</code>行)；<code>-n rz</code>行号靠右显示，且加<code>0</code>。</p>
</li>
</ul>
<p><a href="https://www.runoob.com/linux/linux-comm-more.html" target="_blank" rel="noopener">more:</a></p>
<p>一页一页的显示文件内容。</p>
<p><strong>参数配置：</strong></p>
<ul>
<li><p>-num: 指定一次显示的行数</p>
</li>
<li><p>+num: 从第num行开始显示</p>
</li>
<li><p>+/pattern: 在文档显示前搜索该字符串(pattern)，从该字符串所在行的前两行开始显示</p>
</li>
</ul>
<p><strong>指令：</strong></p>
<ul>
<li>空格键：向下滚动一屏</li>
<li>b: 返回上一屏</li>
<li>Enter：向下n行，默认为1行</li>
<li>=：输出当前行号</li>
<li>v: 调用vi编辑器</li>
</ul>
<p><a href="https://www.runoob.com/linux/linux-comm-less.html" target="_blank" rel="noopener">less：</a></p>
<p>与more类似，但less 在查看之前不会加载整个文件。</p>
<p>可以向前翻页，滚动一页或滚动半页。</p>
<p><a href="https://www.cnblogs.com/peida/archive/2012/11/06/2756278.html" target="_blank" rel="noopener">head</a>/<a href="https://www.runoob.com/linux/linux-comm-tail.html" target="_blank" rel="noopener">tail</a>：</p>
<p>head 只看前几行；tail 只看末尾几行</p>
<h4 id="11-怎么找出含有关键字的前后4行"><a href="#11-怎么找出含有关键字的前后4行" class="headerlink" title="11. 怎么找出含有关键字的前后4行"></a>11. 怎么找出含有关键字的前后4行</h4><ul>
<li>查看filename中含有abc所在行后4行内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat filename | grep abc -A4</span><br></pre></td></tr></table></figure>

<ul>
<li>查看filename中含有abc所在行前4行内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat filename  | grep abc  -B4</span><br></pre></td></tr></table></figure>



<h4 id="Linux的GDB调试"><a href="#Linux的GDB调试" class="headerlink" title="Linux的GDB调试"></a>Linux的GDB调试</h4><h4 id="coredump是什么，怎么才能coredump"><a href="#coredump是什么，怎么才能coredump" class="headerlink" title="coredump是什么，怎么才能coredump"></a>coredump是什么，怎么才能coredump</h4><h4 id="tcpdump常用命令"><a href="#tcpdump常用命令" class="headerlink" title="tcpdump常用命令"></a>tcpdump常用命令</h4><h4 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a>crontab命令</h4><h4 id="查看后台进程"><a href="#查看后台进程" class="headerlink" title="查看后台进程"></a>查看后台进程</h4><h4 id="文件系统的理解（EXT4，XFS，BTRFS）"><a href="#文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="文件系统的理解（EXT4，XFS，BTRFS）"></a>文件系统的理解（EXT4，XFS，BTRFS）</h4><h4 id="一、Lin-ux-查看打开的连接数"><a href="#一、Lin-ux-查看打开的连接数" class="headerlink" title="一、Lin  ux 查看打开的连接数"></a>一、Lin  ux 查看打开的连接数</h4><h5 id="Netstat："><a href="#Netstat：" class="headerlink" title="Netstat："></a><strong><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html" target="_blank" rel="noopener">Netstat：</a></strong></h5><p>Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships。</p>
<ul>
<li><code>netstat -a</code>：检查所有连接</li>
<li><code>netstat -at</code>：只列出tcp连接</li>
<li><code>netstat -au</code>：只列出udp连接</li>
<li><code>netstat -ax</code>：只列出Unix Socket连接</li>
<li><code>netstat -l</code>：只列出监听端口</li>
<li><code>netstat -lt</code>：只列出监听TCP端口</li>
<li><code>netstat -s</code>：显示所有端口的统计信息</li>
<li><code>netstat -st</code>：只显示TCP端口的统计信息</li>
<li><code>netstat -p</code>：在结果中显示进程PID及进程名称</li>
<li><code>netstat -n</code>：不显示主机、端口号和用户名</li>
<li><code>netstat -ap | grep ssh</code>：查看指定程序(ssh)运行的端口</li>
<li><code>netstat -an | grep &#39;:80&#39;</code>：查看运行在指定端口(80)的进程</li>
<li><code>netstat -anp | grep 80 | wc -l</code>：统计指定端口的连接数量</li>
</ul>
<h4 id="二、Linux-查看剩余内存"><a href="#二、Linux-查看剩余内存" class="headerlink" title="二、Linux 查看剩余内存"></a>二、Linux 查看剩余内存</h4><h5 id="top"><a href="#top" class="headerlink" title="top:"></a><a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">top:</a></h5><p>Linux下常用的性能分析工具，能够实时的显示系统中各个进程的资源占用情况。</p>
<p>输出结果前五行是系统情况的统计信息区，分别为：</p>
<ul>
<li>统计信息：当前系统时间；系统已运行时间；登录的用户数量；load average(每个5秒检查一次活跃的进程数，然后按特定算法计算出的数值)</li>
<li>Tasks：当前共有多少个进程，处于running的个数，sleeping的个数，stopped的个数，zombie的个数</li>
<li>CPU使用情况</li>
<li>Memory使用情况</li>
<li>swap交换分区信息</li>
</ul>
<p>后面是各个进程的状态监控，包括其进程id、所有者、优先级、CPU/内存的使用情况等。</p>
<h5 id="free"><a href="#free" class="headerlink" title="free:"></a><a href="https://www.cnblogs.com/ultranms/p/9254160.html" target="_blank" rel="noopener">free:</a></h5><p>free命令可以显示系统内存的使用情况，包括物理内存、交换分区和内核缓冲区内存。</p>
<p><strong>参数配置：</strong></p>
<ul>
<li>-h: 显示结果更友好</li>
<li>-s num: 持续的观察内存的状况，使用-s 指定间隔的秒数</li>
</ul>
<h5 id="cat-proc-meminfo"><a href="#cat-proc-meminfo" class="headerlink" title="cat /proc/meminfo"></a><a href="https://blog.csdn.net/whbing1471/article/details/105468139/" target="_blank" rel="noopener">cat /proc/meminfo</a></h5><p>可以使用/proc/meminfo文件查看操作系统内存的使用状态，该文件其实是<code>top/free</code>等命令的数据来源。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—C/C++</title>
    <url>/2020/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94C-C++/</url>
    <content><![CDATA[<h4 id="一、Const-Static-的区别"><a href="#一、Const-Static-的区别" class="headerlink" title="一、Const/Static 的区别"></a>一、Const/Static 的区别</h4><p>static：</p>
<ul>
<li>static 局部变量：将一个变量声明为函数的局部变量，但该变量在函数执行完成后不会被释放，而是继续保留在内存中，因此其值在下次调用时仍维持上次的值；</li>
<li>static 全局变量：表示一个变量在当前文件的全局内可访问，不能被模块外其他函数访问；</li>
<li>static 函数：表示一个函数只能在当前文件中被访问；</li>
<li>static 类成员变量：表示这个成员为全类所共有，(所有该类的实例共享)，必须<strong>在类声明的外部进行初始化</strong>；</li>
<li>static 类成员函数：表示这个函数为全类所共有，而且只能访问静态成员变量，这个函数不接受this指针；</li>
</ul>
<p>static成员变量和普通static变量一样，都在内存分区的全局数据区分配内存，到程序结束后释放。这就意味着，static成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p>
<p>const:</p>
<ul>
<li>const 常量：定义时就初始化，以后不能更改；</li>
<li>const 形参：该形参在函数里不能改变；</li>
<li>const 修饰类成员函数：该函数对成员变量只能进行读操作；</li>
</ul>
<p>const关键字阻止一个变量被改变；声明常量指针和指针常量。</p>
<p>对于类的成员函数，有时候必须指定其返回值为const类型，以使其返回值不为“左值”。</p>
<p>C++中const修饰的全局常量的作用域LOCAL的，即只在本文件中。可以通过配合使用<code>extern</code>关键字来声明该常量可以作用于其他编译模块中。</p>
<p>C中const修饰的全局常量的作用域是GLOBAL的，作用域整个编译工程。</p>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><h4 id="在函数参数传递时，什么时候用指针，什么时候用引用"><a href="#在函数参数传递时，什么时候用指针，什么时候用引用" class="headerlink" title="在函数参数传递时，什么时候用指针，什么时候用引用"></a>在函数参数传递时，什么时候用指针，什么时候用引用</h4><h4 id="堆和栈有什么区别"><a href="#堆和栈有什么区别" class="headerlink" title="堆和栈有什么区别"></a>堆和栈有什么区别</h4><h4 id="堆快一点还是栈快一点"><a href="#堆快一点还是栈快一点" class="headerlink" title="堆快一点还是栈快一点"></a>堆快一点还是栈快一点</h4><h4 id="new和delete是如何实现的，new与malloc的异同处"><a href="#new和delete是如何实现的，new与malloc的异同处" class="headerlink" title="new和delete是如何实现的，new与malloc的异同处"></a>new和delete是如何实现的，new与malloc的异同处</h4><h4 id="既然有了malloc-free，c-中为什么还需要new-delete呢"><a href="#既然有了malloc-free，c-中为什么还需要new-delete呢" class="headerlink" title="既然有了malloc/free，c++中为什么还需要new/delete呢"></a>既然有了malloc/free，c++中为什么还需要new/delete呢</h4><h4 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h4><h4 id="delete和delete-的区别"><a href="#delete和delete-的区别" class="headerlink" title="delete和delete[]的区别"></a>delete和delete[]的区别</h4><h4 id="c-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等"><a href="#c-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等" class="headerlink" title="c++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等"></a>c++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等</h4><h4 id="C-和Python的区别"><a href="#C-和Python的区别" class="headerlink" title="C++和Python的区别"></a>C++和Python的区别</h4><h4 id="Struct和class的区别"><a href="#Struct和class的区别" class="headerlink" title="Struct和class的区别"></a>Struct和class的区别</h4><h4 id="define和const的联系与区别（编译阶段安全性、内存占用等）"><a href="#define和const的联系与区别（编译阶段安全性、内存占用等）" class="headerlink" title="define和const的联系与区别（编译阶段安全性、内存占用等）"></a>define和const的联系与区别（编译阶段安全性、内存占用等）</h4><h4 id="计算下面几个类的大小"><a href="#计算下面几个类的大小" class="headerlink" title="计算下面几个类的大小"></a>计算下面几个类的大小</h4><h4 id="c-的STL介绍，其中包括内存管理、allocator、函数、实现机制、多线程实现等"><a href="#c-的STL介绍，其中包括内存管理、allocator、函数、实现机制、多线程实现等" class="headerlink" title="c++的STL介绍，其中包括内存管理、allocator、函数、实现机制、多线程实现等"></a>c++的STL介绍，其中包括内存管理、allocator、函数、实现机制、多线程实现等</h4><h4 id="STL源码中的hash表的实现"><a href="#STL源码中的hash表的实现" class="headerlink" title="STL源码中的hash表的实现"></a>STL源码中的hash表的实现</h4><h4 id="解决哈希冲突的方式"><a href="#解决哈希冲突的方式" class="headerlink" title="解决哈希冲突的方式"></a>解决哈希冲突的方式</h4><h4 id="STL中unordered-map和map的区别"><a href="#STL中unordered-map和map的区别" class="headerlink" title="STL中unordered_map和map的区别"></a>STL中unordered_map和map的区别</h4><h4 id="STL中vector的实现"><a href="#STL中vector的实现" class="headerlink" title="STL中vector的实现"></a>STL中vector的实现</h4><h4 id="vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因"><a href="#vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因" class="headerlink" title="vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因"></a>vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因</h4><h4 id="c-中vector和list的区别"><a href="#c-中vector和list的区别" class="headerlink" title="c++中vector和list的区别"></a>c++中vector和list的区别</h4><h4 id="C-中重载和重写的区别"><a href="#C-中重载和重写的区别" class="headerlink" title="C++中重载和重写的区别"></a>C++中重载和重写的区别</h4><h4 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h4><h4 id="介绍面向对象的三大特性"><a href="#介绍面向对象的三大特性" class="headerlink" title="介绍面向对象的三大特性"></a>介绍面向对象的三大特性</h4><h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><h4 id="C-虚函数相关，虚函数的实现原理"><a href="#C-虚函数相关，虚函数的实现原理" class="headerlink" title="C++虚函数相关，虚函数的实现原理"></a>C++虚函数相关，虚函数的实现原理</h4><h4 id="实现编译器处理虚函数表该如何处理"><a href="#实现编译器处理虚函数表该如何处理" class="headerlink" title="实现编译器处理虚函数表该如何处理"></a>实现编译器处理虚函数表该如何处理</h4><h4 id="基类的析构函数一般写成虚函数的原因"><a href="#基类的析构函数一般写成虚函数的原因" class="headerlink" title="基类的析构函数一般写成虚函数的原因"></a>基类的析构函数一般写成虚函数的原因</h4><h4 id="构造函数为什么一般不定义为虚函数"><a href="#构造函数为什么一般不定义为虚函数" class="headerlink" title="构造函数为什么一般不定义为虚函数"></a>构造函数为什么一般不定义为虚函数</h4><h4 id="构造函数或者析构函数中调用虚函数会怎么样"><a href="#构造函数或者析构函数中调用虚函数会怎么样" class="headerlink" title="构造函数或者析构函数中调用虚函数会怎么样"></a>构造函数或者析构函数中调用虚函数会怎么样</h4><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><h4 id="静态绑定和动态绑定的介绍"><a href="#静态绑定和动态绑定的介绍" class="headerlink" title="静态绑定和动态绑定的介绍"></a>静态绑定和动态绑定的介绍</h4><h4 id="深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4><h4 id="对象复用的了解，零拷贝的了解"><a href="#对象复用的了解，零拷贝的了解" class="headerlink" title="对象复用的了解，零拷贝的了解"></a>对象复用的了解，零拷贝的了解</h4><h4 id="介绍c-所有的构造函数"><a href="#介绍c-所有的构造函数" class="headerlink" title="介绍c++所有的构造函数"></a>介绍c++所有的构造函数</h4><h4 id="什么情况下会调用构造拷贝函数"><a href="#什么情况下会调用构造拷贝函数" class="headerlink" title="什么情况下会调用构造拷贝函数"></a>什么情况下会调用构造拷贝函数</h4><h4 id="结构体内存对齐方式和为什么要进行内存对齐"><a href="#结构体内存对齐方式和为什么要进行内存对齐" class="headerlink" title="结构体内存对齐方式和为什么要进行内存对齐"></a>结构体内存对齐方式和为什么要进行内存对齐</h4><h4 id="内存泄露的定义，如何检测与避免"><a href="#内存泄露的定义，如何检测与避免" class="headerlink" title="内存泄露的定义，如何检测与避免"></a>内存泄露的定义，如何检测与避免</h4><h4 id="C-的智能指针有哪些"><a href="#C-的智能指针有哪些" class="headerlink" title="C++的智能指针有哪些"></a>C++的智能指针有哪些</h4><h4 id="调试程序的方法"><a href="#调试程序的方法" class="headerlink" title="调试程序的方法"></a>调试程序的方法</h4><h4 id="遇到coredump要怎么调试"><a href="#遇到coredump要怎么调试" class="headerlink" title="遇到coredump要怎么调试"></a>遇到coredump要怎么调试</h4><h4 id="inline关键字说一下，和宏定义有什么区别"><a href="#inline关键字说一下，和宏定义有什么区别" class="headerlink" title="inline关键字说一下，和宏定义有什么区别"></a>inline关键字说一下，和宏定义有什么区别</h4><h4 id="模板的用法与适用场景-实现原理"><a href="#模板的用法与适用场景-实现原理" class="headerlink" title="模板的用法与适用场景 实现原理"></a>模板的用法与适用场景 实现原理</h4><h4 id="成员初始化列表的概念，为什么用成员初始化列表会快一点"><a href="#成员初始化列表的概念，为什么用成员初始化列表会快一点" class="headerlink" title="成员初始化列表的概念，为什么用成员初始化列表会快一点"></a>成员初始化列表的概念，为什么用成员初始化列表会快一点</h4><h4 id="用过C11吗，知道C11新特性吗"><a href="#用过C11吗，知道C11新特性吗" class="headerlink" title="用过C11吗，知道C11新特性吗"></a>用过C11吗，知道C11新特性吗</h4><h4 id="C-的调用惯例"><a href="#C-的调用惯例" class="headerlink" title="C++的调用惯例"></a>C++的调用惯例</h4><h4 id="C-的四种强制转换"><a href="#C-的四种强制转换" class="headerlink" title="C++的四种强制转换"></a>C++的四种强制转换</h4><h4 id="string的底层实现"><a href="#string的底层实现" class="headerlink" title="string的底层实现"></a>string的底层实现</h4><h4 id="一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4><h4 id="set、map和vector的插入复杂度"><a href="#set、map和vector的插入复杂度" class="headerlink" title="set、map和vector的插入复杂度"></a>set、map和vector的插入复杂度</h4><h4 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h4><h4 id="type和define的区别"><a href="#type和define的区别" class="headerlink" title="type和define的区别"></a>type和define的区别</h4><h4 id="被free回收的内存是立即返还给操作系统吗？为什么"><a href="#被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="被free回收的内存是立即返还给操作系统吗？为什么"></a>被free回收的内存是立即返还给操作系统吗？为什么</h4><h4 id="引用作为函数参数以及返回值的好处"><a href="#引用作为函数参数以及返回值的好处" class="headerlink" title="引用作为函数参数以及返回值的好处"></a>引用作为函数参数以及返回值的好处</h4><h4 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h4><h4 id="说一下Volatile关键字的作用"><a href="#说一下Volatile关键字的作用" class="headerlink" title="说一下Volatile关键字的作用"></a>说一下Volatile关键字的作用</h4><h4 id="STL中sort-算法是用什么实现的，stable-sort-呢"><a href="#STL中sort-算法是用什么实现的，stable-sort-呢" class="headerlink" title="STL中sort()算法是用什么实现的，stable_sort()呢"></a>STL中sort()算法是用什么实现的，stable_sort()呢</h4><h4 id="vector会迭代器失效吗？什么情况下会迭代器失效"><a href="#vector会迭代器失效吗？什么情况下会迭代器失效" class="headerlink" title="vector会迭代器失效吗？什么情况下会迭代器失效"></a>vector会迭代器失效吗？什么情况下会迭代器失效</h4><h4 id="为什么C-没有垃圾回收"><a href="#为什么C-没有垃圾回收" class="headerlink" title="为什么C++没有垃圾回收"></a>为什么C++没有垃圾回收</h4>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—数据结构与算法</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>数据结构</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—计算机网络</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h4 id="1-UDP如何实现可靠传输"><a href="#1-UDP如何实现可靠传输" class="headerlink" title="1. UDP如何实现可靠传输"></a>1. UDP如何实现可靠传输</h4><p>UDP本身是无连接的协议，作用于传输层，想要实现可靠传输，只能从应用层来实现。需要添加如下机制：</p>
<ul>
<li>ack/seq:</li>
</ul>
<p>发送方为每个UDP报文添加一个序号，接收方收到后发送一个ack报文；</p>
<ul>
<li>超时重传机制</li>
</ul>
<p>发送方在一段时间后收不到某个报文的ack，就重传这个报文；</p>
<ul>
<li>滑动窗口：</li>
</ul>
<p>发送窗口/接收窗口，控制发送方的发送速率，防止网络较差时，越丢包越重传、越重传越丢包的恶性循环；</p>
<p>参考：<a href="https://www.zhihu.com/question/283995548?sort=created" target="_blank" rel="noopener">UDP如何实现可靠传输 —— 知乎</a></p>
<h4 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h4><table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>面向连接的</td>
<td>无连接的</td>
</tr>
<tr>
<td>可靠传输（无差错、不丢失、不重复、按序交付）</td>
<td>尽最大努力交付、不可靠传输</td>
</tr>
<tr>
<td>面向字节流</td>
<td>面向报文的</td>
</tr>
<tr>
<td>拥塞控制</td>
<td>没有拥塞控制</td>
</tr>
<tr>
<td>点对点（一对一）</td>
<td>支持一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td>首部开销大（最小长度20字节）</td>
<td>首部开销小（8字节）</td>
</tr>
</tbody></table>
<h4 id="3-TCP和UDP相关的协议与端口号"><a href="#3-TCP和UDP相关的协议与端口号" class="headerlink" title="3. TCP和UDP相关的协议与端口号"></a>3. TCP和UDP相关的协议与端口号</h4><table>
<thead>
<tr>
<th>TCP</th>
<th></th>
<th>UDP</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>协议</td>
<td>端口</td>
<td>协议</td>
<td>端口</td>
</tr>
<tr>
<td>SMTP（简单邮件传输协议）</td>
<td>25</td>
<td>DNS（域名系统）</td>
<td>53</td>
</tr>
<tr>
<td>HTTP（超文本传输协议）</td>
<td>80</td>
<td>RIP（路由信息协议）</td>
<td>520</td>
</tr>
<tr>
<td>FTP（文件传动协议）</td>
<td>21</td>
<td>DHCP（动态主机配置协议）</td>
<td>68</td>
</tr>
<tr>
<td>TELNET（远程终端协议）</td>
<td>23</td>
<td>TFTP（简单文件传送协议）</td>
<td>69</td>
</tr>
<tr>
<td></td>
<td></td>
<td>SNMP（简单网络管理协议）</td>
<td>161</td>
</tr>
</tbody></table>
<h4 id="4-TCP、UDP、IP、HTTP请求报文-响应报文等首部的认识"><a href="#4-TCP、UDP、IP、HTTP请求报文-响应报文等首部的认识" class="headerlink" title="4. TCP、UDP、IP、HTTP请求报文/响应报文等首部的认识"></a>4. TCP、UDP、IP、HTTP请求报文/响应报文等首部的认识</h4><ul>
<li>TCP：</li>
</ul>
<p>源端口（2B）、目的端口（2B）、序号（4B）、确认号（4B）、数据偏移（4bit）、保留（6bit）、6个标识位（USG、ACK、PSH、RST、SYN、FIN，各1bit）、窗口（2B）、检验和（2B）、紧急指针（2B）、选项（长度可变，最长为40字节）、填充</p>
<ul>
<li>UDP：</li>
</ul>
<p>源端口（2B）、目的端口（2B）、长度（2B）、检验和（2B）</p>
<ul>
<li>IP：</li>
</ul>
<p>版本（4bit）、首部长度（4bit）、区分服务（8bit）、总长度（16bit）、标识（16bit）、标志（3bit）、片偏移（13bit）、生存时间（8bit）、协议（8bit）、首部检验和（16bit）、源地址（4B）、目的地址（4B）、可选字段（最大40B）、填充</p>
<ul>
<li>HTTP请求报文</li>
</ul>
<p>请求方法、空格、URI、空格、版本、回车换行、首部行（首部字段名：值）、空行、实体主体 </p>
<ul>
<li>HTTP响应报文</li>
</ul>
<p>版本、空格、状态码、空格、短语、回车换行、首部行（首部字段名：值）、空行、实体主体</p>
<h4 id="5-网页解析的过程与方法"><a href="#5-网页解析的过程与方法" class="headerlink" title="5. 网页解析的过程与方法"></a>5. 网页解析的过程与方法</h4><ul>
<li>HTML文档解析，生成解析树，即DOM树；</li>
<li>如果加载过程中遇到外部CSS资源或者图片资源，会发出另外的请求，来获取资源。这是异步请求，不会影响HTML文档的加载；</li>
<li>浏览器将CSS文件解析成样式表对象，用来渲染DOM树。</li>
<li>如果加载过程遇到JS文件，HTML文档会发出另外的请求来获取JS资源，并挂起HTML的渲染线程，等JS文件加载解析完毕，才可以恢复HTML文档的渲染；</li>
</ul>
<h4 id="6-在浏览器中输入URL后执行的全部过程"><a href="#6-在浏览器中输入URL后执行的全部过程" class="headerlink" title="6. 在浏览器中输入URL后执行的全部过程"></a>6. 在浏览器中输入URL后执行的全部过程</h4><ul>
<li><p>URL解析，检查有效性、字符编码等</p>
</li>
<li><p>域名解析（DNS），根据URL解析出相应的IP地址，检查过程：浏览器缓存、操作系统缓存、路由器缓存、ISP DNS查询；</p>
</li>
<li><p>建立TCP连接，三次握手；</p>
</li>
<li><p>建立HTTP连接（无需格外连接，直接通过已经建立的TCP连接发送），发送请求报文；</p>
</li>
<li><p>服务端处理请求，发送响应报文；</p>
</li>
<li><p>客户端接收报文，解析，并将结果渲染展示给用户；</p>
</li>
</ul>
<h4 id="7-网络层分片的原因与具体实现"><a href="#7-网络层分片的原因与具体实现" class="headerlink" title="7. 网络层分片的原因与具体实现"></a>7. 网络层分片的原因与具体实现</h4><ul>
<li>原因：</li>
</ul>
<p>每一种物理网络中的数据链路层协议都规定了一个数据帧中的<strong>数据字段的最大长度</strong>，即最大传送单元MTU（Maximum Tranfer Unit），当一个IP数据报封装成链路层的帧时，此数据报的总长度（首部加数据部分）一定不能超过下面数据链路层所规定的的MTU，否则，需要将过长的数据报进行分片处理；</p>
<ul>
<li>实现：</li>
</ul>
<p>IP数据报分片涉及到了IP数据报首部中的三个字段：标识、标志（MF、DF）、片偏移</p>
<ol>
<li>标识: 16bit。IP软件在存储器中维持这一个计数器，每产生一个数据报，计数器加1，并将此值付给标识字段。当数据报需要分片时，这个标识字段就被复制到所有的数据报片的标识字段中。相同标识字段的值使分片后的各数据报片最后能够正确地组装为原来的数据报；</li>
<li>标志MF：MF=1表示后面还有分片，MF=0表示这已是若干分片中的最后一片；</li>
<li>标志DF：DF=0表示可以分片；DF=1表示不能分片，当DF=1且数据报长度大于MTU时，则将数据报丢弃，并发送一个ICMP不可达差错报文给源主机；</li>
<li>片偏移：13bit。片偏移指的是较长的分组在分片后，某片在原分组中的相对位置。</li>
</ol>
<h4 id="8-TCP三次握手与四次挥手的详细介绍（为什么、处于什么状态）"><a href="#8-TCP三次握手与四次挥手的详细介绍（为什么、处于什么状态）" class="headerlink" title="8. TCP三次握手与四次挥手的详细介绍（为什么、处于什么状态）"></a>8. TCP三次握手与四次挥手的详细介绍（为什么、处于什么状态）</h4><ul>
<li>三次握手：</li>
</ul>
<p>初始状态：客户端：CLOSED状态；服务端：LISTEN状态；</p>
<p>第一次：客户端向服务端发送连接请求报文段，置SYN=1，并选择一个初始的seq=x。客户端进入SYN-SENT（同步已发送）状态。</p>
<p>第二次：服务端收到请求后，如同意建立连接，则向客户端发送确认。置SYN=1，ACK=1，ack=x+1，并选择一个初始的seq=y。服务端进入SYN-RCVD（同步收到）状态。</p>
<p>第三次：客户端收到服务端的确认后，还需要向服务端发送确认。ACK=1，ack=y+1，seq=x+1。这时连接已经建立，客户端进入ESTABLISHED（已建立连接）状态。</p>
<p>服务端收到客户端的确认后，也进入到ESTABLISHED（已建立连接）的状态。</p>
<p>三次握手的过程中，前两次握手发送的SYN报文段（即SYN=1报文段）不能携带数据，但要消耗掉一个序号。</p>
<ul>
<li>第三次握手的原因：防止已失效的连接请求报文段突然又传到服务端，从而引发错误。</li>
</ul>
<p>考虑这样一种异常情况：客户端发送了一个连接请求报文，由于某种原因滞留在了网络中，但并没有丢失，以至在连接释放后的某个时间到达了服务端。服务端误以为客户端又发送了一次连接请求，于是向客户端发送一个确认报文。如果没有第三次握手，服务端发送确认报文后连接就建立了。客户端收到服务端的确认后，不予理睬，也不会向B发送数据。但B却认为新的连接已经建立了，并一直等待A发来数据，B的许多资源就浪费了。</p>
<ul>
<li>四次挥手：</li>
</ul>
<p>初始状态：客户端：ESTABLISHED；服务端：ESTABLISHED;</p>
<p>第一次挥手：客户端向服务端发送连接释放请求报文，并停止发送数据，主动关闭TCP连接。置FIN=1，seq=u。进入FIN-WAIT-1（终止等待1）状态。</p>
<p>第二次挥手：服务端收到连接释放请求报文后，发送一个确认报文。置ACK=1，ack=u+1，seq=v。进入CLOSE-WAIT（关闭等待）状态。</p>
<p>这时从客户端到服务端这个方向的连接就释放了，这时的TCP处于半关闭状态。客户端收到服务端的确认后，进入FIN-WAIN-2（终止等待2）状态，等待服务端发送连接释放报文。</p>
<p>第三次挥手：服务端发送完数据后，发送连接释放报文，置FIN=1，ack=u+1，seq=w。进入LAST-ACK（最后确认）状态。</p>
<p>第四次挥手：客户端收到服务端的连接释放报文后，必须对此确认。置ACK=1，ack=w+1，seq=u+1。然后进入到TIME-WAIT（时间等待）状态。 注意，此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间<strong>2MSL</strong>后，客户端才进入CLOSED状态。</p>
<p>服务端收到客户端的确认后，进入到CLOSED状态。</p>
<h4 id="9-TIME-WAIT的状态，为什么要等2MSL"><a href="#9-TIME-WAIT的状态，为什么要等2MSL" class="headerlink" title="9. TIME_WAIT的状态，为什么要等2MSL"></a>9. TIME_WAIT的状态，为什么要等2MSL</h4><p>客户端在TIME-WAIT状态必须等待2MSL时间，有两个理由：</p>
<ul>
<li>为了保证客户端发送的最后一个ACK确认报文能够到达服务端。</li>
</ul>
<p>假如客户端发送的最后一个ACK在网络中丢失了，那么处于LAST-ACK状态的服务端就无法收到对已发送的FIN+ACK报文段的确认。服务端会超时重传FIN+ACK报文段。接着A重传一次确认，重新启动时间等待计时器。最后客户端和服务端都进入CLOSED状态。如果客户端没有等待2MSL时间，而是发送完ACK就释放连接，那么就无法收到服务端重传的FIN-ACK报文段，因而也不会再发送一次确认报文段，这样服务端就无法正常进入CLOSED状态。</p>
<ul>
<li>防止“已失效的连接请求报文”出现在本连接中</li>
</ul>
<p>客户端在发送完最后一个ACK后，在经过2MSL，就可以使本次连接持续时间内的所有报文段都从网络中消失。这样下一个新的连接中就不会出现这种旧的连接请求报文段。</p>
<h4 id="10-超时重传机制"><a href="#10-超时重传机制" class="headerlink" title="10. 超时重传机制"></a>10. 超时重传机制</h4><p>超时重传：TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。超时时间设置太短，会引起很多报文段不必要的重传；太长，则会使网络空闲时间增大，降低了传输效率。</p>
<ul>
<li>超时重传时间的选择：</li>
</ul>
<p>TCP采用了一种自适应算法，它记录一个报文段的往返时间RTT。同时维护了一个加权平均往返时间RTTs。</p>
<p>RTTs = (1-α)（旧的RTTs） + α*（新的RTT）</p>
<p>超时重传时间RTO=RTTs + 4*RTTD。其中RTTD是RTT的偏差的加权平均值。</p>
<h4 id="11-TCP如何保证可靠性"><a href="#11-TCP如何保证可靠性" class="headerlink" title="11. TCP如何保证可靠性"></a>11. TCP如何保证可靠性</h4><p>无差错、不丢失、不重复、按序到达</p>
<ul>
<li><p>检验和：检验和字段检验的范围包括首部和数据这两个部分；</p>
</li>
<li><p>确认应答/序号/确认号：接收方收到发送方的报文后，会发送一个确认报文。报文中有一个序号字段，表示此报文第一个字节的序号。还有一个确认号字段，表示期望收到对方下一个报文段的第一个数据字节的序号；</p>
</li>
<li><p>超时重传：发送方发送一个报文段后，启动时间计时器，等到接收方的确认报文，若超时未收到确认报文，则会重发一次刚才的报文段。</p>
</li>
<li><p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。滑动窗口：发送方的发送窗口不能超过接收方的接收窗口。窗口单位是字节。</p>
</li>
<li><p>拥塞控制：拥塞控制是防止过得数据注入网络中，这样就可以使网络中的路由器或链路不致过载。（在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可能部分，网络的性能就要变坏，这种情况就叫做拥塞。）</p>
</li>
</ul>
<h4 id="12-流量控制的作用，采用滑动窗口会有什么问题"><a href="#12-流量控制的作用，采用滑动窗口会有什么问题" class="headerlink" title="12. 流量控制的作用，采用滑动窗口会有什么问题"></a>12. 流量控制的作用，采用滑动窗口会有什么问题</h4><p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。TCP的流量控制功能借助滑动窗口机制实现。</p>
<p>发送方和接收方分别维护着发送窗口与接收窗口，TCP报文的首部中包含一个<strong>窗口</strong>的字段，窗口指的是发送本报文段的一方的接收窗口，窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。发送方的发送窗口不能超过接收方给出的接收窗口的数值。窗口单位为字节，不是报文段。</p>
<ul>
<li>问题1：死锁问题</li>
</ul>
<p>假设有发送方A和接收方B。</p>
<p>B向A发送了一个零窗口报文段，不久后，B的接收缓存又有了一些存储空间，于是B向A发送了一个窗口非零的报文段，但这个报文段在网络中丢失了。A一直在等待B发送的窗口非零的报文段，B在等待A发来新的数据，如果没有其他措施，这种互相等待的死锁局面将一直存在下去。</p>
<p>解决方法：TCP为每一个连接设置了一个<strong>持续计时器</strong>，只要一方收到一个零窗口报文段，就启动持续计时器。若持续计时器设置的时间到了，就发送一个零窗口<strong>探测报文段</strong>（仅携带1字节数据），而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍为零，则重置持续计时器，否则，死锁局面就打破了。</p>
<ul>
<li>问题2：糊涂窗口综合症</li>
</ul>
<p>设想这样一种情况：TCP接收方接收缓存已满，但交互式应用每次只从接收缓存取出一个字节，然后向发送方发送确认，窗口值设为1，发送方接收到确认后，又发送1个字节的数据，接收方发回确认，仍将窗口值设为1。这样持续下去，网络的效率会很低。（数据1个字节，TCP报文首部最小为20字节，IP报文首部为20字节）。</p>
<p>解决办法：让接收方等待一段时间，使得接收缓存有足够的空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。出现以上情况时，接收方才发出确认报文。另外，发送方也不要发送太小的报文段，而是把数据累积成足够大的报文段，或者达到接收方缓存空间大小的一半。</p>
<h4 id="13-拥塞控制和流量控制的区别"><a href="#13-拥塞控制和流量控制的区别" class="headerlink" title="13. 拥塞控制和流量控制的区别"></a>13. 拥塞控制和流量控制的区别</h4><p>拥塞控制是防止过多的数据注入网络中，不至于使得网络中的路由器或链路不过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>流量控制指的是点对点通信量的控制，是个端对端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便接收端来得及接收。</p>
<h4 id="14-TCP拥塞控制、算法名字"><a href="#14-TCP拥塞控制、算法名字" class="headerlink" title="14. TCP拥塞控制、算法名字"></a>14. TCP拥塞控制、算法名字</h4><p>拥塞窗口cwnd，慢开始门限ssthresh，四种算法：</p>
<ul>
<li><p>慢开始：每经过一个传输轮次，拥塞窗口加倍；</p>
</li>
<li><p>拥塞避免：拥塞窗口大小达到慢开始门限时，每经过一个传输轮次，拥塞窗口加一；</p>
</li>
</ul>
<p>如果发生了超时，即发送方设置的超时计时器时限已到但还没有收到确认，那么网络很可能是出现了拥塞，致使报文段在网络某处丢失。在这种情况下，TCP马上把拥塞窗口减小为1，并开始慢开始算法。同时，置慢开始门限为超时时拥塞窗口数值的一半。</p>
<ul>
<li>快重传：</li>
</ul>
<p>接收方没收到一个失序的报文段就立即发出重复确认。发送方一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不用等待设置的重传计时器到期。</p>
<ul>
<li>快恢复：</li>
</ul>
<p>当出现三个重复确认时，启动快恢复算法。置慢开始门限为当前拥塞窗口数值的一半，拥塞窗口值等于慢开始门限，进入拥塞避免阶段。</p>
<h4 id="15-HTTP协议与TCP的联系和区别"><a href="#15-HTTP协议与TCP的联系和区别" class="headerlink" title="15. HTTP协议与TCP的联系和区别"></a>15. HTTP协议与TCP的联系和区别</h4><ul>
<li>联系：</li>
</ul>
<p>HTTP协议是建立在TCP协议基础上的。</p>
<p>当浏览器需要从服务器获取网页数据的时候，会发出一次HTTP请求，HTTP会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，HTTP会立即将TCP连接断开。</p>
<ul>
<li>区别：</li>
</ul>
<p>HTTP协议与TCP协议位于不同的层级。</p>
<p>TCP协议位于传输层，定义的是数据的传输和连接的规范。而HTTP协议位于应用层，定义的是数据的内容的规范。</p>
<p>建立一个TCP连接需要三次握手，而由于HTTP是建立在TCP连接之上的，建立一个HTTP请求通常包含请求和响应两个步骤。</p>
<h4 id="16-HTTP-1-0-HTTP-1-1"><a href="#16-HTTP-1-0-HTTP-1-1" class="headerlink" title="16. HTTP 1.0 / HTTP 1.1"></a>16. HTTP 1.0 / HTTP 1.1</h4><ul>
<li>长连接</li>
</ul>
<p>HTTP 1.0为短连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。</p>
<p>HTTP 1.1为持久连接（HTTP 1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗。</p>
<ul>
<li>带宽优化及网络连接的使用</li>
</ul>
<p>HTTP 1.0存在浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。HTTP 1.0不支持断点续传功能。</p>
<p>HTTP 1.1在请求头引入了range头域，他允许只请求资源的某个部分。</p>
<ul>
<li>错误通知的管理</li>
</ul>
<p>在HTTP 1.1中新增了24个错误状态响应码。</p>
<ul>
<li>Host头处理</li>
</ul>
<p>HTTP 1.0认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们共享一个IP地址。</p>
<p>HTTP 1.1的请求消息和响应消息都支持Host头域，且请求消息中如果没有Host头域会报告一个错误。</p>
<ul>
<li>缓存处理</li>
</ul>
<p>在HTTP 1.0中主要使用header里的If-Modified-Since，Expires来作为缓存判断的标准。</p>
<p>在HTTP 1.1中引入了更多的缓存控制策略，例如：Entity tag，If-Unmodified-Since, If-Match, If-None-Match。</p>
<h4 id="17-HTTP-1-HTTP-2-0"><a href="#17-HTTP-1-HTTP-2-0" class="headerlink" title="17. HTTP 1.* / HTTP 2.0"></a>17. HTTP 1.* / HTTP 2.0</h4><ul>
<li>新的二进制格式</li>
</ul>
<p>HTTP 1.*的解析是基于文本。HTTP2.0协议解析基于二进制格式，实现方便且健壮。</p>
<ul>
<li>多路复用</li>
</ul>
<p>即连接共享，每一个request都是用作连接共享机制的。一个request对应一个ID，这样一个连接上就可以由多个request，每个连接的request可以随机的混杂在一起，接收方根据request的ID将request归属到不同的服务端请求里面。</p>
<ul>
<li>Header压缩</li>
</ul>
<p>HTTP 1.*的header中带有大量信息，而且每次都要重复发送;</p>
<p>HTTP 2.0使用encoder来减少需要传输的header大小，通讯双方各自缓存一份header fields表，即避免了重复header的传输，又减少了需要传输的大小。</p>
<ul>
<li>服务端推送</li>
</ul>
<p>HTTP 2.0具有server push的功能，允许服务端推送资源给浏览器。</p>
<h4 id="18-HTTP-的请求方法有哪些"><a href="#18-HTTP-的请求方法有哪些" class="headerlink" title="18. HTTP 的请求方法有哪些"></a>18. HTTP 的请求方法有哪些</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>请求指定的页面信息，返回实体主体</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求，例如提交表单或上传文件。数据被包含在请求体中。</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>CONNECT</td>
<td></td>
</tr>
<tr>
<td>OPTIONS</td>
<td></td>
</tr>
<tr>
<td>TRACE</td>
<td></td>
</tr>
<tr>
<td>PATCH</td>
<td></td>
</tr>
</tbody></table>
<h4 id="19-get和post的区别"><a href="#19-get和post的区别" class="headerlink" title="19. get和post的区别"></a>19. get和post的区别</h4><ul>
<li><p>get不会修改服务器上的资源；post可能会导致新的资源的建立或已有资源的修改；</p>
</li>
<li><p>get可以存为书签，能被缓存；post不能;</p>
</li>
<li><p>get后退按钮或刷新是无害的；post数据会被重新提交，浏览器应该提醒用户；</p>
</li>
<li><p>get把参数追加在URL中，会被完整保存在浏览器历史中（登录时密码会显示，不安全）；post把参数放在请求实体中，不会保存；</p>
</li>
<li><p>get的URL长度是有限制的；post无限制；</p>
</li>
<li><p>get参数数据类型只允许ASCII字符；post还支持二进制格式；</p>
</li>
</ul>
<h4 id="20-HTTP状态码"><a href="#20-HTTP状态码" class="headerlink" title="20. HTTP状态码"></a>20. HTTP状态码</h4><p>参考：<a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">HTTP状态码——菜鸟教程</a></p>
<h4 id="21-HTTP-HTTPS区别"><a href="#21-HTTP-HTTPS区别" class="headerlink" title="21. HTTP/HTTPS区别"></a>21. HTTP/HTTPS区别</h4><ul>
<li><p>HTTP协议是超文本传输协议，信息是明文传输；HTTPS是具有安全性的SSL加密传输协议；</p>
</li>
<li><p>HTTPS协议需要到CA申请证书，一般免费证书比较少，因而需要一定费用；</p>
</li>
<li><p>HTTP与HTTPS使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>
</li>
<li><p>HTTP连接很简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</p>
</li>
<li><p>HTTPS协议需要多次握手，导致页面的加载时间延长近50%。</p>
</li>
<li><p>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗。</p>
</li>
</ul>
<h4 id="22-由HTTP升级为HTTPS需要做哪些操作"><a href="#22-由HTTP升级为HTTPS需要做哪些操作" class="headerlink" title="22. 由HTTP升级为HTTPS需要做哪些操作  (?)"></a>22. 由HTTP升级为HTTPS需要做哪些操作  (?)</h4><ul>
<li>申请证书</li>
<li>配置服务器支持SSL</li>
<li>将页面中所有链接由HTTP改为HTTPS</li>
<li>…</li>
</ul>
<h4 id="23-HTTPS的具体实现，怎么确保安全性"><a href="#23-HTTPS的具体实现，怎么确保安全性" class="headerlink" title="23. HTTPS的具体实现，怎么确保安全性"></a>23. HTTPS的具体实现，怎么确保安全性</h4><ul>
<li><p>客户端发送HTTPS连接请求，同时，会将客户端支持的加密算法/哈希算法（密钥算法套件）发送给服务器；</p>
</li>
<li><p>服务端收到请求后，与自己支持的加密算法进行对比，如果不符合，则断开连接；否则，选出一组加密算法和哈希算法，并将自己的身份信息已证书的形式发回给客户端；</p>
</li>
<li><p>客户端验证服务端的证书：</p>
<ul>
<li>客户端验证证书，包括颁发证书的机构是否合法与是否过期，证书中包含的网址是否与正在访问的地址一致等；</li>
<li>验证通过后（或者用户选择接受了不信任的证书），客户端会生成一个随机字符串，然后用服务端的公钥进行加密。<strong>（这里就保证了只有服务端才能看到这串随机字符，因为只有服务端拥有公钥对应的密钥）</strong></li>
<li>生成握手信息，用约定好的哈希算法，对握手信息进行HASH，然后用随机字符串加密握手信息和握手信息的HASH值，将结果发送给服务端。<strong>（这里之所以要带上握手信息的HASH是因为，防止信息被篡改，那么服务端接收到信息进行HASH时，就会发现HASH值和客户端传回来的不一样，这里就保证了信息不回被篡改）</strong></li>
</ul>
</li>
<li><p>服务端接收到加密信息后，首先用私钥解密得到随机字符串。然后用随机字符串解密握手信息，获得握手信息和握手信息的HASH值，服务端对握手信息进行HASH，对比客户端发送过来的HASH，如果相同，则说明信息没有被篡改；</p>
</li>
<li><p>服务器验证完客户端的信息以后，同样使用随机字符串加密握手信息和握手信息的HASH值发给客户端。</p>
</li>
<li><p>客户端收到服务端发回来的握手信息后，用一开始生成的随机字符串对密文进行解密，得到握手信息和握手信息的HASH值，像服务端一样进行验证。验证完成后，握手完毕。</p>
</li>
<li><p>握手完成后，双方之间的通信数据将利用之前客户端生成的随机数通过对称加密算法进行加密。</p>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/xtiger/p/11026870.html" target="_blank" rel="noopener">HTTPS安全通信过程</a></li>
<li><a href="https://blog.csdn.net/qq_23960265/article/details/80075642" target="_blank" rel="noopener">HTTPS的通信过程</a></li>
</ul>
<h4 id="24-TCP三次握手时的第一次的seq序号是怎么产生的"><a href="#24-TCP三次握手时的第一次的seq序号是怎么产生的" class="headerlink" title="24. TCP三次握手时的第一次的seq序号是怎么产生的"></a>24. TCP三次握手时的第一次的seq序号是怎么产生的</h4><p>第一次的序号是随机的，但也不是完全随机的，它是由ISN算法得到的：</p>
<p>ISN = M+ F（localhost，localport，remotehost，remoteport） </p>
<ul>
<li><p>M是一个计时器，这个计时器每隔四毫秒加1；</p>
</li>
<li><p>F是一个HASH算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证HASH算法不能被外部轻易推算得出，使用MD5算法是一个比较好的选择；</p>
</li>
</ul>
<h4 id="25-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#25-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="25. 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>25. 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4><p>65536，因为在TCP报文段中端口号的长度为16bit，也就是最多能表示2^16=65536个不同的端口。但是由于0-1023是知名服务端口，所以实际上还要减少1024个端口号；</p>
<p>对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
<h4 id="26-对称密码和非对称密码"><a href="#26-对称密码和非对称密码" class="headerlink" title="26. 对称密码和非对称密码"></a>26. 对称密码和非对称密码</h4><ul>
<li>对称加密算法：加密和解密使用的密钥是同一个</li>
</ul>
<p>优点是计算量小，算法速度快，加密效率高；缺点是密钥容易泄露。不同的会话需要不同的密钥，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一密钥，管理起来很费劲；</p>
<p>常用算法有：DES、AES、3DES等</p>
<ul>
<li>非对称加密：加密和解密使用的密钥为一对，公钥和私钥；使用公钥进行加密，使用私钥进行解密；</li>
</ul>
<p>优点是安全性更高，公钥是公开的，私钥自己保存，不需要交给别人。缺点是加密解密时间长，速度慢，只适合对少量数据进行加密。</p>
<p>常用算法有：RSA，ECC等</p>
<h4 id="27-数字证书的了解"><a href="#27-数字证书的了解" class="headerlink" title="27. 数字证书的了解"></a>27. 数字证书的了解</h4><p>权威CA利用私钥将网站的信息（URL、公钥、CA信息等）加密，形成消息摘要（签名S）进行打包形成数字证书。公钥发给客户端。</p>
<p>在HTTPS握手时，网站将数字证书发送给客户端，客户端利用CA提供的公钥对数字证书进行解密，然后手动对A的网站信息（URL、公钥、CA信息等）进行HASH，得到签名S，将手动计算得到的签名S与证书中包含的签名S进行对比，如果一致，则说明网站是可以信任的。</p>
<h4 id="28-服务器出现大量close-wait的连接的原因以及解决办法"><a href="#28-服务器出现大量close-wait的连接的原因以及解决办法" class="headerlink" title="28. 服务器出现大量close_wait的连接的原因以及解决办法"></a>28. 服务器出现大量close_wait的连接的原因以及解决办法</h4><p>CLOSE-WAIT状态是在TCP四次挥手过程中发生的。服务端收到FIN并确认后，没有发送自己的FIN，就会一直处于CLOSE-WAIT状态。</p>
<p>原因可能有以下两个：</p>
<ul>
<li>服务器内部业务处理占用了太多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法。</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0，无法回收；</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序；</li>
<li>修改程序里的bug；</li>
</ul>
<h4 id="29-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么方法可以加强消息摘要算法的安全性让它不那么容易被破解呢？"><a href="#29-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么方法可以加强消息摘要算法的安全性让它不那么容易被破解呢？" class="headerlink" title="29. 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么方法可以加强消息摘要算法的安全性让它不那么容易被破解呢？"></a>29. 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么方法可以加强消息摘要算法的安全性让它不那么容易被破解呢？</h4><p>常用的消息摘要算法有：MD家族（MD2、MD4、MD5）；SHA家族（SHA-1、SHA-256）；CRC家族（CRC8、CRC16、CRC32）等等；</p>
<p>MD5算法：</p>
<p>MD5以512位分组来处理输入的信息，且每一组又被划分为16个32位子分组，经过一系列的处理后，算法输出是由四个32位分组组成的128位散列值。</p>
<ul>
<li>如果输入信息的长度对512取余不等于448，就需要填充。填充的方法是填充一个1和若干个0。填充完成后的信息长度为N*512+448；</li>
<li>用64位来记录填充前信息的长度，这64位追加在前一步的结果的后面。这样信息长度就变为了（N+1）*512；</li>
<li>对每个512位的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量；</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量。以这四个变量再进行下一分组的运算；</li>
<li>遍历完成所有分组，最后的四个变量即为MD5值。</li>
</ul>
<p>为什么是不可逆的：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，说以不能由结果进行恢复。</p>
<p>加强安全性：加盐（加随机数）</p>
<h4 id="30-单条记录并发访问的优化"><a href="#30-单条记录并发访问的优化" class="headerlink" title="30. 单条记录并发访问的优化"></a>30. 单条记录并发访问的优化</h4><p>服务端：</p>
<ul>
<li>使用缓存，比如redis等；</li>
<li>使用分布式架构进行处理；</li>
<li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回；</li>
<li>将静态资源尽可能在客户端进行缓存；</li>
<li>采用nginx进行负载均衡；</li>
</ul>
<p>数据库：</p>
<ul>
<li>数据库采用主从赋值，读写分离措施；</li>
<li>建立适当的索引；</li>
<li>分库分表；</li>
</ul>
<h4 id="31-介绍一下ping的过程，分别用到了哪些协议"><a href="#31-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="31. 介绍一下ping的过程，分别用到了哪些协议"></a>31. 介绍一下ping的过程，分别用到了哪些协议</h4><p>参考：<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html" target="_blank" rel="noopener">ping原理与ICMP协议</a></p>
<p>ping程序是用来探测主机到主机之间是否可以通信。工作过程如下：</p>
<ul>
<li>首先，执行ping的主机会构建一个固定格式的ICMP请求数据包，ICMP协议会将这个数据包连同目的IP地址和源IP地址一起交给IP协议；</li>
<li>然后IP协议根据这些信息构造一个IP数据报，并在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
<li>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并提取其中的信息交给IP协议，IP协议提取信息并交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</li>
</ul>
<h4 id="32-TCP-IP的粘包与避免介绍一下"><a href="#32-TCP-IP的粘包与避免介绍一下" class="headerlink" title="32. TCP/IP的粘包与避免介绍一下"></a>32. TCP/IP的粘包与避免介绍一下</h4><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzI4MDYzNDc1Mg==&mid=2247484019&amp;idx=1&amp;sn=c8e0b7c7c5095c52481a6474d326172d&source=41#wechat_redirect" target="_blank" rel="noopener">TCP粘包，难道是一个伪命题？</a></p>
<p>TCP层传输是流式传输，流，最大的问题就是没有边界，没有边界就会造成数据粘在一起，这种粘在一起就叫做粘包。</p>
<p>粘包是指发送方发送的若干个包数据到接收方时粘成一个包，从接受方的缓冲区看，后一个包的头紧接着前一个包的数据结尾，无法区分。</p>
<p>导致粘包的原因可能有以下原因：</p>
<ol>
<li>TCP连接复用：多个进程使用一个TCP连接，此时多种不同结构的数据进入到TCP的流式传输，边界分割可定会出这样那样的问题；</li>
<li>发送端等待缓冲区满才进行发送（在发送较小的数据包的时候，会将几个包合并成一个包后发送）；</li>
<li>接收方来不及接收缓冲区内的数据，造成多个包接收；</li>
</ol>
<p>如何避免：</p>
<ul>
<li>通过编程，强制TCP发生数据传送，不必等到缓冲区满（数据包小的时候也立即发送，不合并发送）；</li>
<li>优化接受方接收数据的过程，使其来得及接收数据包，包括提到接收进程优先级等；</li>
<li>设置固定长度的报文，或者设置报文头部指示报文的长度；</li>
<li>设置尾部标记序列；</li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/wiessharling/p/4230878.html" target="_blank" rel="noopener">TCP的封包与拆包</a></p>
<h4 id="33-说一下TCP的封包与拆包"><a href="#33-说一下TCP的封包与拆包" class="headerlink" title="33. 说一下TCP的封包与拆包"></a>33. 说一下TCP的封包与拆包</h4><p>因为TCP是流传输，流，最大的问题就是没有边界，没有边界就会造成数据粘在一起，这种粘在一起就叫做粘包。为了解决这种问题，就需要进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li><p>封包：就是在发送数据包的时候为每个TCP数据包加上一个包头，将数据分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</p>
</li>
<li><p>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</p>
</li>
</ul>
<h4 id="34-一个ip配置多个域名，靠什么识别"><a href="#34-一个ip配置多个域名，靠什么识别" class="headerlink" title="34. 一个ip配置多个域名，靠什么识别"></a>34. 一个ip配置多个域名，靠什么识别</h4><ul>
<li>Hostname 主机名</li>
<li>端口号</li>
</ul>
<h4 id="35-服务器攻击"><a href="#35-服务器攻击" class="headerlink" title="35. 服务器攻击"></a>35. 服务器攻击</h4><h4 id="36-DNS的工作过程与原理"><a href="#36-DNS的工作过程与原理" class="headerlink" title="36. DNS的工作过程与原理"></a>36. DNS的工作过程与原理</h4><p>DNS解析有两种方式：递归查询和迭代查询</p>
<p>递归查询：用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回；</p>
<p>迭代查询：用户向本地域名服务器查询，如果没有缓存，本地域名系统会向根域名服务器查询，根域名服务器返回的顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果。</p>
<h4 id="37-OSA七层协议与五层协议"><a href="#37-OSA七层协议与五层协议" class="headerlink" title="37. OSA七层协议与五层协议"></a>37. OSA七层协议与五层协议</h4><table>
<thead>
<tr>
<th>七层网络协议</th>
<th>TCP/IP 四层协议</th>
<th>五层网络协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td></td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td></td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>运输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网际层</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td></td>
<td>数据链路层</td>
</tr>
<tr>
<td>物理层</td>
<td>网络接口层</td>
<td>物理层</td>
</tr>
</tbody></table>
<h4 id="38-IP寻址与MAC寻址有什么不同，怎么实现的"><a href="#38-IP寻址与MAC寻址有什么不同，怎么实现的" class="headerlink" title="38. IP寻址与MAC寻址有什么不同，怎么实现的"></a>38. IP寻址与MAC寻址有什么不同，怎么实现的</h4><p>MAC寻址是使用mac地址寻找主机；IP寻址是通过IP寻找主机；它们适用于不同的协议层，IP寻址是网络层，MAC寻址是数据链路层；</p>
<ul>
<li>MAC寻址：</li>
</ul>
<p>交换机使用MAC地址通过其指向相应端口的交换结构将网络通信转向目的节点。交换机为了知道要使用哪个端口来传送帧，它必须首先知道自己的每个端口上都存在哪些节点。</p>
<p>交换机使用其MAC地址表来确定如何处理传入的数据帧。交换机通过记录与其每一个端口相连的节点的MAC地址来构建起MAC地址表。</p>
<p>当交换机收到传入的数据帧时，会检查其MAC地址表，如果查到了，则从相应的端口发出；否则，交换机将把该帧从除接收该帧的端口之外的所有端口转发出去。收到该帧的节点会与自身的MAC地址进行比较，目的节点会发送一个响应。当目的节点响应时，交换机从响应帧的源地址段中获得该节点的MAC地址，并将其记录在地址表中；</p>
<p>参考：<a href="https://blog.51cto.com/07net01/586888" target="_blank" rel="noopener">MAC寻址</a></p>
<ul>
<li>IP寻址：</li>
</ul>
<p>在网络层和传输层中，计算机之间通过IP地址定位目标主机，对应的数据报文中只包含目标主机的IP地址，而没有MAC地址。因此在发送前，需要根据IP地址来获取MAC地址，然后才能将数据报发送到正确的目标主机。这个获取的过程是通过ARP协议完成的。</p>
<ol>
<li>主机A首先在本机的ARP缓存中检查主机B的IP地址及MAC地址；</li>
<li>如果在ARP缓存中没有找到主机B的IP地址及对应的MAC地址，它将寻址主机B的MAC地址，又分为本地网络寻址和非本地网络寻址;；</li>
</ol>
<p>本地网络寻址：主机A检查与主机B为与同一个网段</p>
<ol>
<li>将ARP请求帧广播到本地网络上的所有主机，源主机A的IP地址及MAC地址都在ARP请求中；</li>
<li>本地网络上的所有主机都接收到ARP请求，并检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。若匹配，则将A的IP地址与MAC地址映射添加到本地ARP缓存中。</li>
<li>主机B将自身包含的MAC地址的ARP信息回复直接发送给主机A。</li>
<li>当主机A收到B发来的ARP消息时，会用主机B的IP地址和MAC地址更新ARP缓存。</li>
<li>主机B的MAC地址一旦确定，主机A就能向主机B发送IP数据包。本地缓存是有生存期的，过期后将重复上面过程。</li>
</ol>
<p>非本地网络寻址：处于不同的网段</p>
<ol>
<li>主机A将ARP请求帧发送给自己的缺省网关，即路由器的本地接口；</li>
<li>数据帧到达路由器的缺省端口后先解封转，编程IP数据包，对IP进行处理，根据IP地址查找路由表，决定转发接口后做适应转发接口数据链路层协议帧的封装，并且发送到下一跳路由器，此过程继续直到到达目的网络与目的主机。</li>
</ol>
<p>参考：<a href="http://c.biancheng.net/view/6388.html" target="_blank" rel="noopener">ARP协议的工作机制详解</a></p>
<h4 id="39-建立TCP连接时，服务器的各个系统调用"><a href="#39-建立TCP连接时，服务器的各个系统调用" class="headerlink" title="39. 建立TCP连接时，服务器的各个系统调用"></a>39. 建立TCP连接时，服务器的各个系统调用</h4><ul>
<li>socket()：创建一个套接字，并将相应的资源分配给它，并返回一个整型套接字号。</li>
<li>bind()：将创建的套接字绑定到指定的IP地址和端口上。</li>
<li>listen()：启动监听服务。</li>
<li>accept()：从已完成连接队列返回下一个建立成功的连接；</li>
<li>send()：数据发送；</li>
<li>recv()：数据接收；</li>
</ul>
<h4 id="40-继上一题，说明socket网络编程有哪些系统调用？其中close-是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#40-继上一题，说明socket网络编程有哪些系统调用？其中close-是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="40. 继上一题，说明socket网络编程有哪些系统调用？其中close()是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>40. 继上一题，说明socket网络编程有哪些系统调用？其中close()是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4><p>系统调用补充：</p>
<ul>
<li>connect()：通常由客户端调用，建立连接；</li>
<li>read()、recvfrom()：数据接收；</li>
<li>write()、sendto()：数据发送；</li>
<li>close()、shutdown()：关闭套接字；</li>
</ul>
<p>close()用来关闭套接字，使用close()时，只有当套接字的引用计数为0时才会终止连接。而用shutdown()是直接关闭连接。</p>
<h4 id="41-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP。"><a href="#41-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP。" class="headerlink" title="41. 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP。"></a>41. 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP。</h4><p>内部网关协议，即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。有RIP和OSPF；</p>
<p>外部网关协议，若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要一种协议将路由选择信息传递到另一个自治系统中。有BGP。</p>
<ul>
<li><p>RIP：一种基于距离向量的路由选择协议，其最大的优点就是简单。RIP协议中要求网络中每一个路由器都要维护一个从它自己到每一个目的网络的距离纪录。RIP协议规定：仅和相邻的路由器交换信息；交换的信息是当前本路由器所知道的全部信息，及自己的路由表；按照固定的时间间隔交换路由信息，当网络拓扑结构发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。（距离向量算法）</p>
<p>特点：好消息传播的快，坏消息传播的慢。</p>
</li>
<li><p>OSPF：使用分布式的链路状态协议。OSPF协议规定：向本自治系统中的所有路由器发送信息，使用洪泛法，即路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器；发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息；只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。（迪杰斯特拉算法）</p>
</li>
<li><p>BGP：边界网关协议BGP只是力求寻找一条能够到达目的网络且比较好的路由，而非要寻找一条最佳路由。采用路径向量路由选择协议。</p>
</li>
</ul>
<h4 id="42-TCP连接中，客户端主机突然故障，会发生什么，服务端的行为是怎样的？"><a href="#42-TCP连接中，客户端主机突然故障，会发生什么，服务端的行为是怎样的？" class="headerlink" title="42. TCP连接中，客户端主机突然故障，会发生什么，服务端的行为是怎样的？"></a>42. TCP连接中，客户端主机突然故障，会发生什么，服务端的行为是怎样的？</h4><p>在TCP连接中，存在一个<strong>保活计时器</strong>。服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时没有收到客户端的数据，服务器就发送一个探测报文段，以后则每个75分钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出现了故障，接着就关闭这个链接。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—操作系统</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="1-进程与线程的区别和联系-："><a href="#1-进程与线程的区别和联系-：" class="headerlink" title="1. 进程与线程的区别和联系 ："></a>1. 进程与线程的区别和联系 ：</h4><p>区别：</p>
<ul>
<li>进程是对运行时程序的封装，使系统进行资源分配的最小单元；线程是进程的子任务，是处理器进行调度的最小单元；</li>
<li>一个进程可以有多个线程，一个线程只能属于一个进程；</li>
<li>每个进程都有独立的代码和数据空间（程序上下文），进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程有自己独立运行的运行栈和程序计数器，线程之间切换的开销小。</li>
<li>进程之间不会相互影响，一个进程崩溃后不会影响其他进程；而一个线程崩溃后会导致进程崩溃，从而影响进程里面其他线程；</li>
</ul>
<p>联系：</p>
<p>线程是存在进程的内部，一个进程可以有多个线程，一个线程只能存在与一个进程中。</p>
<h4 id="2-Linux理论上最多可以创建多少个进程，一个进程可以创建多少个线程，和什么有关"><a href="#2-Linux理论上最多可以创建多少个进程，一个进程可以创建多少个线程，和什么有关" class="headerlink" title="2. Linux理论上最多可以创建多少个进程，一个进程可以创建多少个线程，和什么有关"></a>2. Linux理论上最多可以创建多少个进程，一个进程可以创建多少个线程，和什么有关</h4><p>32768。因为进程的pid是用pid_t（short类型，两个字节，2^15）来表示的，pid_t的最大值是32768，所以理论上最多有32768个进程。</p>
<p>进程最多可以创建的线程数取决于分配给调用栈的大小。此外还有操作系统等因素。例如：一个进程虚拟内存时4G，在Linux32位平台下，内核分走了1G，留给用户的只有3G，创建一个线程占有10M内存，总共有3G内存可以使用，于是，最多差不多可以创建300个左右的线程。</p>
<h4 id="3-冯诺依曼结构有哪几个模块，分别对应现代计算机的哪几个部分？"><a href="#3-冯诺依曼结构有哪几个模块，分别对应现代计算机的哪几个部分？" class="headerlink" title="3. 冯诺依曼结构有哪几个模块，分别对应现代计算机的哪几个部分？"></a>3. 冯诺依曼结构有哪几个模块，分别对应现代计算机的哪几个部分？</h4><ul>
<li>存储器：内存、外存等</li>
<li>输入设备：键盘、鼠标、摄像头等</li>
<li>输出设备：显示器、打印机等</li>
<li>控制器：</li>
<li>运算器：</li>
</ul>
<p>控制器和运算器：CPU</p>
<h4 id="4-进程之间的通信方法有哪几种？线程之间通信方式"><a href="#4-进程之间的通信方法有哪几种？线程之间通信方式" class="headerlink" title="4. 进程之间的通信方法有哪几种？线程之间通信方式"></a>4. 进程之间的通信方法有哪几种？线程之间通信方式</h4><p>进程间通信方式主要有六种：管道、信号量、消息队列、信号、共享内存、套接字</p>
<ul>
<li><p>管道：管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道的一段的进程顺序的将进程数据写入缓冲区，另一端的进程则顺序的读取数据。有匿名管道和命名管道，匿名管道只允许父子进程通信，命名管道允许具有非血缘关系的进程通信。</p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，信号量只有等待和发送两种操作，等待就是将其值减一或者挂起进程，发送就是将其值加一或者将进程恢复运行。</p>
</li>
<li><p>信号：信号是Linux系统中用于进程间通信或操作的一种机制，信号可在任何时候发送给某一进程，而无需知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程，信号是开销最小的。</p>
</li>
<li><p>共享内存：两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或以上的进程映射到自身的地址空间中。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程通过一个简单的内存读取读出，从而实现了进程间的通信。效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p>
</li>
<li><p>消息队列：消息队列是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。其特点是，每个消息对应特定的类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</p>
</li>
<li><p>套接字：它可用于不同设备及其间的进程通信。</p>
</li>
</ul>
<p>线程之间通信方式：</p>
<ul>
<li>使用全局变量</li>
<li>使用信号机制</li>
<li>使用事件</li>
</ul>
<h4 id="5-进程之间的同步方式有哪些？多线程同步？"><a href="#5-进程之间的同步方式有哪些？多线程同步？" class="headerlink" title="5. 进程之间的同步方式有哪些？多线程同步？"></a>5. 进程之间的同步方式有哪些？多线程同步？</h4><p>进程同步：</p>
<ul>
<li>信号量</li>
<li>管程：其基本思想是将共享变量和对它们的操作集中在一个模块中。</li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html" target="_blank" rel="noopener">进程同步的几种机制</a></p>
<p>线程同步：</p>
<ul>
<li>互斥锁</li>
<li>条件变量：当程序在等待满足某些条件时使线程进入睡眠状态，一旦条件满足，就唤醒因等待满足特定条件而睡眠的线程。</li>
<li>读写锁</li>
<li>信号量</li>
</ul>
<h4 id="6-什么时候用多进程，什么时候用多线程"><a href="#6-什么时候用多进程，什么时候用多线程" class="headerlink" title="6. 什么时候用多进程，什么时候用多线程"></a>6. 什么时候用多进程，什么时候用多线程</h4><ul>
<li>频繁修改：需要频繁创建和销毁的优先使用多线程</li>
<li>计算量：需要大量计算的优先使用多线程，因为需要消耗大量CPU资源且切换频繁；</li>
<li>相关性：任务间相关性比较强的用多线程，相关性比较弱的用多进程，因为线程间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用多进程，多核分布的用多线程</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h4 id="7-进程调度方法详细介绍"><a href="#7-进程调度方法详细介绍" class="headerlink" title="7. 进程调度方法详细介绍"></a>7. 进程调度方法详细介绍</h4><ul>
<li>先来先服务（FCFS，first come first serve）：按照作业到达任务队列的顺序调度调度，FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）不利于短作业（I/O繁忙性）</li>
<li>短作业优先（SJF，short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。不利于长作业，长作业可能一直处于等待状态，处于饥饿状态。完全未考虑作业的优先紧迫程度，不能用于实时系统。</li>
<li>最短剩余时间优先：该算法首先按照作业的服务时间挑选最短的作用运行，在该作业运行期间，一旦有新作业到达系统，并且该作业的服务时间比当前运行作业的剩余服务时间短，则法神抢占。否则，当前作业继续运行，该算法保证一旦新的短作业或短进程进入系统，能够很快得到处理。</li>
<li>高响应比优先调度算法：非抢占式的，主要用于作业调度。基本思想是：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。因为都需要计算响应比，所以比较耗费系统资源。</li>
<li>时间片轮转：用于分时系统的进程调度。基本思想是：系统将CPU处理时间划分为若干个时间片，进程按照先后顺序到达后顺序排列，每次调度选择对首的进程，执行完一个时间片后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能够在给定的时间内响应所有用户的请求，达到分时系统的目的。</li>
<li>多级反馈队列：</li>
</ul>
<h4 id="8-进程的执行过程是什么样的，执行一个进程需要做哪些工作"><a href="#8-进程的执行过程是什么样的，执行一个进程需要做哪些工作" class="headerlink" title="8. 进程的执行过程是什么样的，执行一个进程需要做哪些工作"></a>8. 进程的执行过程是什么样的，执行一个进程需要做哪些工作</h4><p>进程的执行需要经过三大步骤：编译、链接和装入</p>
<ul>
<li>编译：将源代码编译成若干模块</li>
<li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接、装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li>
<li>装入：讲模块装入内存运行</li>
</ul>
<p>进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录，减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p>
<h4 id="9-死锁产生的必要条件"><a href="#9-死锁产生的必要条件" class="headerlink" title="9. 死锁产生的必要条件"></a>9. 死锁产生的必要条件</h4><ul>
<li>互斥：一个资源每次只能被一个进程访问</li>
<li>占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不可剥夺：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<p>产生死锁的原因：</p>
<ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ul>
<h4 id="10-死锁的恢复"><a href="#10-死锁的恢复" class="headerlink" title="10. 死锁的恢复"></a>10. 死锁的恢复</h4><ul>
<li>重新启动：最简单也是最常用的死锁消除方法，但代价很大，因为此前所有进程已经完成的计算工作将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程</li>
<li>终止进程：终止参与死锁的进程并回收它们所占的资源。分为：一次性全部终止；逐步终止（优先级、代价函数）</li>
<li>剥夺资源：剥夺死锁进程所占有的全部或者部分资源。分为：逐步剥夺，一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止；一次剥夺，一次性的剥夺死锁进程所占有的全部资源；</li>
<li>进程回退：让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：要实现回退，必须记住以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间；一个回退的进程应当玩会它在回退点之前所造成的影响，如修改某一文件，给其他进程发送消息等，这些在实现时是难以做到的。</li>
</ul>
<h4 id="11-死锁的避免"><a href="#11-死锁的避免" class="headerlink" title="11. 死锁的避免"></a>11. 死锁的避免</h4><p>死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予以分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。</p>
<ul>
<li>银行家算法</li>
</ul>
<h4 id="12-死锁的预防"><a href="#12-死锁的预防" class="headerlink" title="12. 死锁的预防"></a>12. 死锁的预防</h4><p>可以通过破坏死锁产生的4个必要条件来预防死锁。但由于资源互斥是资源使用的固有特性，是无法改变的，因此，在死锁预防里主要是破坏另外3个条件。</p>
<ul>
<li>破坏“不可剥夺条件”：</li>
</ul>
<p>一个进程不能获得锁需要的全部资源时便处于等待状态，等待期间他占有的资源被隐式的释放重新加入到系统的资源表中，可以被其他的进程使用，而等待的进程只要重新获得自己原有的资源以及新申请的资源才可启动执行。</p>
<ul>
<li>破坏“请求与保持条件”：</li>
</ul>
<p>第一种是静态分配，即每个进程在开始执行时就申请他所需要的全部资源；第二种是动态分配，即每个进程在申请所需要的资源时它本身不占用系统资源。</p>
<ul>
<li>破坏“循环等待条件”：</li>
</ul>
<p>采用资源有序分配，其基本思想是将系统中的所有资源顺序标号，将紧缺的、稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的资源时才能申请较大编号的资源。</p>
<h4 id="13-什么是饥饿"><a href="#13-什么是饥饿" class="headerlink" title="13. 什么是饥饿"></a>13. 什么是饥饿</h4><p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而一直不能继续执行时，就会发生饥饿现象。</p>
<h4 id="14-孤儿进程、僵尸进程"><a href="#14-孤儿进程、僵尸进程" class="headerlink" title="14. 孤儿进程、僵尸进程"></a>14. 孤儿进程、僵尸进程</h4><p>孤儿进程：父进程退出后，它的子进程还在执行。这些子进程就变成了孤儿进程，孤儿进程会被init进程收养并完成状态收集。</p>
<p>僵尸进程：一个进程使用fork()创建了子进程，子进程完成退出后，父进程没有调用wait()或者wait_pid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就称为僵尸进程。</p>
<h4 id="15-内核空间和用户空间是怎么区分的"><a href="#15-内核空间和用户空间是怎么区分的" class="headerlink" title="15. 内核空间和用户空间是怎么区分的"></a>15. 内核空间和用户空间是怎么区分的</h4><p>在Linux中虚拟地址空间范围为0到4G，最高的1G字节（从虚拟地址0xC0000000 到 0xFFFFFFFF）由内核使用，称为内核空间，低的3G字节（从虚拟地址0x00000000 到 0xBFFFFFFF）由各个进程使用，称为用户空间。</p>
<p>参考：<a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">Linux内核空间和用户空间</a></p>
<h4 id="16-同一个进程内的线程会共享什么资源"><a href="#16-同一个进程内的线程会共享什么资源" class="headerlink" title="16. 同一个进程内的线程会共享什么资源"></a>16. 同一个进程内的线程会共享什么资源</h4><ul>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<h4 id="17-一般情况下在Linux-Windows平台下栈空间的大小"><a href="#17-一般情况下在Linux-Windows平台下栈空间的大小" class="headerlink" title="17. 一般情况下在Linux/Windows平台下栈空间的大小"></a>17. 一般情况下在Linux/Windows平台下栈空间的大小</h4><p>在Linux下栈空间通常为8M；Windows下是1M；</p>
<h4 id="18-服务器高并发的解决方案"><a href="#18-服务器高并发的解决方案" class="headerlink" title="18. 服务器高并发的解决方案"></a>18. 服务器高并发的解决方案</h4><ul>
<li>应用数据与静态资源分离（图片、视频、js、css等），单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</li>
<li>客户端缓存：因为效率最高、消耗资源最少的就是纯静态的HTML页面，所以可以把网站上的页面尽可能用静态来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</li>
<li>集群和分布式：可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上，同时加快请求处理的速度。（集群是所有服务器都有相同的功能，请求哪台都可以，主要起分流的作用；分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度）</li>
<li>反向代理：在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</li>
</ul>
<h4 id="19-协程了解吗？"><a href="#19-协程了解吗？" class="headerlink" title="19. 协程了解吗？"></a>19. 协程了解吗？</h4><p>协程就是子程序在执行时转去执行别的子程序，在适当的时候又返回来执行。这种子程序之间的跳转不是函数调用，也不是多线程执行，省去了线程切换的开销，效率很高，并且不需要多线程之间的锁机制，不会发生变量写冲突。</p>
<h4 id="20-协程的底层是怎么实现的，怎么使用协程"><a href="#20-协程的底层是怎么实现的，怎么使用协程" class="headerlink" title="20. 协程的底层是怎么实现的，怎么使用协程"></a>20. 协程的底层是怎么实现的，怎么使用协程</h4><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p>
<h4 id="21-进程的状态以及转换图"><a href="#21-进程的状态以及转换图" class="headerlink" title="21. 进程的状态以及转换图"></a>21. 进程的状态以及转换图</h4><p>三态模型：</p>
<ul>
<li>执行：进程占有处理器，正在运行</li>
<li>就绪：进程已经就绪，只要分配到处理器就可以运行</li>
<li>阻塞：进程不具备运行条件，正在等待某个事件的完成</li>
</ul>
<p>五态模型：新建-就绪-运行-等待-终止</p>
<p>七态模型：新建-就绪挂起-就绪-运行-等待-挂起等待-终止</p>
<h4 id="22-在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的。"><a href="#22-在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的。" class="headerlink" title="22. 在执行malloc申请内存的时候，操作系统是怎么做的？/ 内存分配的原理说一下 / malloc函数底层是怎么实现的？ / 进程是怎么分配内存的。"></a>22. 在执行malloc申请内存的时候，操作系统是怎么做的？/ 内存分配的原理说一下 / malloc函数底层是怎么实现的？ / 进程是怎么分配内存的。</h4><p>参考：<a href="https://blog.csdn.net/yusiguyuan/article/details/39496057" target="_blank" rel="noopener">进程分配内存的两种方式</a></p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的：brk()和mmap()</p>
<ul>
<li>brk()：是将进程数据段（.data）的最高地址向高处移动，这一步可以扩大进程在运行时的堆大小。</li>
<li>mmap()：是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128K时，使用brk()调用获得虚拟内存，大于128K时使用mmap()来获得虚拟内存。</p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
<h4 id="23-什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#23-什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="23. 什么是字节序？怎么判断是大端还是小端？有什么用？"></a>23. 什么是字节序？怎么判断是大端还是小端？有什么用？</h4><p>参考：<a href="https://www.cnblogs.com/broglie/p/5645200.html" target="_blank" rel="noopener">字节序：大端法和小端法</a></p>
<p>多字节对象被存储为连续的字节序列，对象的地址为使用字节中的最小字节。字节序即为多字节对象存储在内存中的顺序。</p>
<ul>
<li><p>大端法：最高有效字节在最前面的方式称为大端法。</p>
</li>
<li><p>小端法：最低有效字节在最前面的方式成为小端法。</p>
</li>
</ul>
<p>示例：假设变量x类型为int型，地址位于0x100，其16进制值为0x12345678，地址范围为0x100到0x103。</p>
<p>大端法表示为：</p>
<table>
<thead>
<tr>
<th>0x100</th>
<th>0x101</th>
<th>0x102</th>
<th>0x103</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>34</td>
<td>56</td>
<td>78</td>
</tr>
</tbody></table>
<p>小端法表示为：</p>
<table>
<thead>
<tr>
<th>0x100</th>
<th>0x101</th>
<th>0x102</th>
<th>0x103</th>
</tr>
</thead>
<tbody><tr>
<td>78</td>
<td>56</td>
<td>34</td>
<td>12</td>
</tr>
</tbody></table>
<p>如何判断是大端法还是小端法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">	short s;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">2</span>]; <span class="comment">// sizeof(short)=2;</span></span><br><span class="line">&#125;un;</span><br><span class="line">un.s=<span class="number">0x0102</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"大端"</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"小端"</span>;</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<ul>
<li>编写网络程序时，主机之间通过网络互相通信，不同主机之间可能采用不同的方法，而且网络字节序和主机字节序也有可能不同。当小端法机器产生的数据被发送到大端法机器或者反方向发送时会发现程序里面的字节变成了反序的。为了避免这种情况的发生，规定网络应用程序在将数据发送之前先将数据转换为网络字节序，在接收主机那边，主机再将网络字节序的数据转换成适合本机的主机字节序，从而避免了字节序异常。</li>
<li>当调试程序时常常需要将程序编译成汇编形式，当阅读汇编代码时数据的字节序很重要，需要根据自己的机器是大端法还是小端法来不同对待，以免搞错字节顺序。</li>
</ul>
<h4 id="24-说一下PCB-说一下进程地址空间"><a href="#24-说一下PCB-说一下进程地址空间" class="headerlink" title="24. 说一下PCB/说一下进程地址空间"></a>24. 说一下PCB/说一下进程地址空间</h4><p>PCB进程控制块，是一个数据结构，是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个PCB，然后根据PCB的信息对进程实施控制和管理。进程任务完成时系统撤销它的PCB，进程也随之消亡。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>进程标识符</td>
<td></td>
</tr>
<tr>
<td>进程状态</td>
<td></td>
</tr>
<tr>
<td>当前队列指针 next</td>
<td>处于同一状态的下一个PCB的地址</td>
</tr>
<tr>
<td>进程优先级 priority</td>
<td>进程将依据其优先级的高低去争夺使用CPU的权利</td>
</tr>
<tr>
<td>CPU现场保护区 cpustatus</td>
<td>当进程由于某种原因释放处理机时，CPU现场信息被保存在PCB的该区域中，以便在该进程获得处理机后能继续执行。</td>
</tr>
<tr>
<td>通信信息 communication information</td>
<td>每个进程在运行过程中，与其他进程进行通信时所记录的有关信息。</td>
</tr>
<tr>
<td>家族联系 process family</td>
<td>有的系统允许一个进程创建自己的子进程。</td>
</tr>
<tr>
<td>占有资源清单 own resource</td>
<td></td>
</tr>
</tbody></table>
<p>进程地址空间从低到高如下：</p>
<ul>
<li>代码段text：存放程序的二进制代码</li>
<li>初始化的数据data：已经初始化的变量和数据</li>
<li>未初始化的数据BSS：还没有初始化的数据</li>
<li>堆</li>
<li>栈</li>
</ul>
<h4 id="25-操作系统的内存管理说一下"><a href="#25-操作系统的内存管理说一下" class="headerlink" title="25. 操作系统的内存管理说一下"></a>25. 操作系统的内存管理说一下</h4><p>参考：<a href="https://www.cnblogs.com/peterYong/p/6556619.html#_label0" target="_blank" rel="noopener">操作系统总结3-内存管理</a></p>
<p>包括物理内存管理和虚拟内存管理：</p>
<ul>
<li>物理内存管理包括：交换与覆盖、分页管理、分段管理和段页式管理；</li>
<li>虚拟内存管理包括：虚拟内存的概念、页面置换算法、页面分配策略等；</li>
</ul>
<h4 id="26-虚拟内存的了解"><a href="#26-虚拟内存的了解" class="headerlink" title="26. 虚拟内存的了解"></a>26. 虚拟内存的了解</h4><ul>
<li>每个进程都有自己的4G内存，都是虚拟内存，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址；</li>
<li>所有进程共享同一物理地址，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上；</li>
<li>进程需要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录；</li>
<li>页表的每一表项分为两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在）；</li>
<li>当进程访问某个虚拟地址时，去看页表，如果发现对应的数据不在物理内存中，则缺页异常；</li>
<li>缺页异常的处理过程：就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存满了，那就找一个页覆盖，如果这个要覆盖的页曾经被修改过，需要将此页写回磁盘。</li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/Przz/p/6876988.html" target="_blank" rel="noopener">虚拟内存和物理内存的理解</a></p>
<h4 id="27-实现一个LRU算法"><a href="#27-实现一个LRU算法" class="headerlink" title="27. 实现一个LRU算法"></a>27. 实现一个LRU算法</h4><p>参考：<a href="https://leetcode-cn.com/problems/lru-cache-lcci/" target="_blank" rel="noopener">LeetCode-面试题16.25</a></p>
<h4 id="28-如果要实现一个mutex互斥锁，你要怎么实现"><a href="#28-如果要实现一个mutex互斥锁，你要怎么实现" class="headerlink" title="28. 如果要实现一个mutex互斥锁，你要怎么实现"></a>28. 如果要实现一个mutex互斥锁，你要怎么实现</h4><p>参考：<a href="https://blog.csdn.net/kid551/article/details/84338619" target="_blank" rel="noopener">互斥锁mutex的简单实现</a></p>
<h4 id="29-文件读写使用的系统调用"><a href="#29-文件读写使用的系统调用" class="headerlink" title="29. 文件读写使用的系统调用"></a>29. 文件读写使用的系统调用</h4><p>open()-create()-close()-read()-write()</p>
<h4 id="30-异常和中断的区别"><a href="#30-异常和中断的区别" class="headerlink" title="30. 异常和中断的区别"></a>30. 异常和中断的区别</h4><p>中断是指CPU对系统发生某事件时的一种响应；CPU暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序，执行完后，在返回到原程序的断点继续执行；</p>
<p>异常时指CPU内部出现的中断，即在CPU执行特定指令时出现的非法情况，同时异常也称为同步中断。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>操作系统</tag>
        <tag>面试基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—数据库</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h4 id="1-关系型和非关系型数据库的区别"><a href="#1-关系型和非关系型数据库的区别" class="headerlink" title="1. 关系型和非关系型数据库的区别"></a>1. 关系型和非关系型数据库的区别</h4><p>关系型数据库指的是采用“关系模型”来组织数据的数据库。关系模型指的是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。常用的概念有：关系，元组，属性，域等。</p>
<p>关系型数据库的特点：</p>
<ul>
<li>容易理解：因为它采用了关系模型（二维表结构）来组织数据；</li>
<li>使用方便：通用的SQL语言使得操作关系型数据库非常方便；</li>
<li>易于维护：丰富的完整性（实体完整性、参照完整性等等）大大减低了数据冗余和数据不一致的概率；</li>
</ul>
<p>非关系型数据库：不使用“关系模型”，一般不保证遵循ACID原则，通常以键值对的形式存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限与固定的结构，可以减少一些时间和空间的开销。有Redis、MongoDB等等。</p>
<p>非关系型数据库的特点：</p>
<ul>
<li>效率高，存储在内存中；不需要经过SQL层的解析；</li>
<li>可以支持多种类型数据的存储，如图片、文档等；</li>
<li>可扩展性好；</li>
</ul>
<h4 id="2-说一下MySQL执行一条查询语句的内部执行过程"><a href="#2-说一下MySQL执行一条查询语句的内部执行过程" class="headerlink" title="2. 说一下MySQL执行一条查询语句的内部执行过程"></a>2. 说一下MySQL执行一条查询语句的内部执行过程</h4><ul>
<li>客户端通过连接器连接到MySQL服务器，将SQL发送给服务器；</li>
<li>服务器先检查缓存，如果命中了，直接返回缓存结果；否则，进入下一阶段；</li>
<li>服务器进行词法解析和语法解析，再由优化器生成执行计划；</li>
<li>根据生成的执行计划调用存储引擎的API来执行查询；</li>
<li>将执行结果返回给客户端。</li>
</ul>
<h4 id="3-数据库的索引类型"><a href="#3-数据库的索引类型" class="headerlink" title="3. 数据库的索引类型"></a>3. 数据库的索引类型</h4><p>数据库的索引类型可以分为逻辑分类和物理分类：</p>
<p>逻辑分类：</p>
<ul>
<li>主键索引：当关系表中定义主键时会自动创建主键索引，每张表的主键索引只能有一个，要求主键中的每个值都唯一，也不能有空值。</li>
<li>唯一索引：数据列不能重复值，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。</li>
<li>普通索引：一张表可以有多个普通索引，可以重复，可以为空值；</li>
<li>全文索引：可以加快模糊查询，不常用；</li>
<li>复合索引：在多个字段上创建的索引；</li>
</ul>
<p>物理分类：</p>
<ul>
<li>聚集索引（聚簇索引）：数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中ID从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一张表只能有一个聚集索引。对于聚集索引，叶子节点即存储了真实的数据行，不再有另外单独的数据页。</li>
<li>非聚集索引：数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。叶结点包含索引字段值以及指向数据页数据行的逻辑指针，该页紧邻数据行，其行数量与数据表行数量一直。</li>
</ul>
<h4 id="4-说一下事务是怎么实现的"><a href="#4-说一下事务是怎么实现的" class="headerlink" title="4. 说一下事务是怎么实现的"></a>4. 说一下事务是怎么实现的</h4><p>参考：<a href="https://www.cnblogs.com/takumicx/p/9998844.html" target="_blank" rel="noopener">数据库事务的概念及其实现原理</a></p>
<p>数据库事务是构成单一逻辑工作单元的操作集合；实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<p>并发控制有以下几种实现方式：</p>
<ol>
<li>基于锁的并发控制（悲观）</li>
</ol>
<p>思想：对于并发可能冲突的操作，比如读写、写读、写写等，通过锁使它们互斥执行。锁通常分为共享锁和排它锁两种类型。</p>
<p>流程：</p>
<ul>
<li><p>事务根据自己对数据项的操作类型申请相应的锁（读申请共享锁，写申请排它锁）；</p>
</li>
<li><p>申请锁的请求发送给锁管理器。锁管理器根据当前数据项是否已有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁；</p>
</li>
<li><p>若锁被授予，则申请锁的事务可以继续执行；若被拒绝，则申请锁的事务将进行等待，直到锁被其他事务释放；</p>
</li>
</ul>
<p>可能会出现的问题：死锁；饥饿（数据项A一直被加共享锁，导致事务一直无法获取A的排它锁）</p>
<ol start="2">
<li>基于时间戳的并发控制（悲观）</li>
</ol>
<p>思想：对于并发可能冲突的操作，基于时间戳排序规则选定某事务继续执行，其他事务回滚</p>
<ol start="3">
<li>基于有效性检查的并发控制（乐观）</li>
</ol>
<p>思想：事务对数据的更新首先在自己的工作空间进行，等到要写会数据库时才进行有效性检查，对不符合要求的事务进行回滚‘</p>
<ol start="4">
<li>基于快照隔离的并发控制（乐观）</li>
</ol>
<p>思想：数据库为每个数据项维护多个版本，每个事务只对属于自己的私有快照进行更新，在事务真正提交前进行有效性检查，使得事务正常提交或者失败回滚。</p>
<p>日志恢复有以下几种实现方式：</p>
<ol>
<li>redo log：记录已经成功提交的事务操作信息，用来恢复数据。</li>
<li>undo log：记录事务修改之前的数据信息，用来回滚数据。</li>
</ol>
<h4 id="5-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引"><a href="#5-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引" class="headerlink" title="5. MySQL怎么建立索引，怎么建立主键索引，怎么删除索引"></a>5. MySQL怎么建立索引，怎么建立主键索引，怎么删除索引</h4><p>建立索引有两种方式：alter table和create index</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span>(column_list)  <span class="comment">-- 添加一个主键索引 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> (column_list)       <span class="comment">-- 添加一个普通索引 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">unique</span> (column_list)      <span class="comment">-- 添加一个唯一索引</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name (column_list)   <span class="comment">-- 创建一个普通索引 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index_name <span class="keyword">on</span> table_name (column_list)  <span class="comment">-- 创建一个唯一索引</span></span><br></pre></td></tr></table></figure>

<p>删除同样有两种方式：alter table和drop index</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">index</span> index_name    <span class="comment">-- 删除一个普通索引 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> primary <span class="keyword">key</span>         <span class="comment">-- 删除一个主键索引</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure>



<h4 id="6-索引的优缺点，什么时候用索引，什么时候不用索引"><a href="#6-索引的优缺点，什么时候用索引，什么时候不用索引" class="headerlink" title="6. 索引的优缺点，什么时候用索引，什么时候不用索引"></a>6. 索引的优缺点，什么时候用索引，什么时候不用索引</h4><p>优点：</p>
<ul>
<li>可以大大加快数据的检索速度；</li>
<li>通过创建唯一性索引，可以保证数据库中每一行数据的唯一性；</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义；</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引需要占用物理空间，除了数据表占数据空间外，每一个索引也要占一定的物理空间，如果建立的是聚簇索引，那么需要的空间会更大。</li>
<li>当对表中的数据进行增加、删除和修改时，索引也要动态维护，这样就降低了数据的维护效率；</li>
</ul>
<p>什么时候建索引/哪些列上适合建立索引？</p>
<ul>
<li>在经常需要搜索的列上；</li>
<li>作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上；</li>
<li>在经常需要根据范围进行搜索的列上；</li>
<li>在经常需要排序的列上；</li>
<li>在经常使用在WHERE子句中的列上；</li>
</ul>
<p>不适合建立索引的列：</p>
<ul>
<li>很少查询的列；</li>
<li>很少数据值的列；</li>
<li>对那些定义为text,image数据类型的列；</li>
<li>频繁更新的列；</li>
<li>当修改性能远远大于检索性能时；</li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/wezheng/p/8399305.html" target="_blank" rel="noopener">数据库中的索引</a></p>
<h4 id="7-索引的底层实现"><a href="#7-索引的底层实现" class="headerlink" title="7. 索引的底层实现"></a>7. 索引的底层实现</h4><p>数据库的索引是通常是使用B+Tree来实现的。</p>
<p>（为什么用B+Tree，而不用B树或者红黑树）</p>
<p>B+Tree是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存在叶子节点上，中间节点只保存索引字段。这样一来，相对于B树来说，减少了数据对中间节点的空间的占用，使得中间节点可以存放更多的指针，使得树深度变得更小，从而减少查询的磁盘I/O次数，提高查询效率。另一个原因是，B+Tree将叶子节点用指针顺序连接了起来，所以可以进行范围查询，方便区间访问；</p>
<p>红黑树是二叉的，它的深度相对B+Tree大很多，更大意味着查找次数更多，更频繁的磁盘I/O。所以红黑树更适合在内存中进行查找。</p>
<h4 id="8-B树和B-树的区别"><a href="#8-B树和B-树的区别" class="headerlink" title="8. B树和B+树的区别"></a>8. B树和B+树的区别</h4><p>以一个m阶树为例：</p>
<ul>
<li>关键字数量不同：</li>
</ul>
<p>B+Tree中分支节点有m个关键字，其叶子节点也有m个，其关键字只是起到一个索引的作用；但是B树有m个叶子节点，只有m-1个关键字。</p>
<ul>
<li>数据存储的位置不同：</li>
</ul>
<p>B+Tree中的数据都存在与叶子节点上。B树的数据存储在每一个节点上。</p>
<ul>
<li>分支节点的构造不同：</li>
</ul>
<p>B+Tree分支节点只存储关键字信息（索引字段信息）和指向儿子节点的指针。</p>
<ul>
<li>查询过程不同：</li>
</ul>
<p>B树在找到具体的数值后就结束，二B+Tree树要通过索引找到叶子节点中的数据才结束。也就是说B+Tree的搜索过程走了一条从根节点到叶子节点的路径。</p>
<h4 id="9-索引最左前缀-最左匹配"><a href="#9-索引最左前缀-最左匹配" class="headerlink" title="9. 索引最左前缀/最左匹配"></a>9. 索引最左前缀/最左匹配</h4><p>假如对（a, b, c）三个字段建立了联合索引，则已经对（a）（a, b）（a, b, c）上都建立了索引。对查询时字段的顺序没有限制，也就是a,b,c；b,a,c；c,a,b等都可以匹配；</p>
<p>在联合索引中，会从最左边的字段开始，一直向右匹配到范围查询（&gt;, &lt;, between, like）就停止匹配。比如where a = 1 and b = 2 and c &gt; 3 and d = 4，如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<h4 id="10-MySQL的优化（索引优化、性能优化）"><a href="#10-MySQL的优化（索引优化、性能优化）" class="headerlink" title="10. MySQL的优化（索引优化、性能优化）"></a>10. MySQL的优化（索引优化、性能优化）</h4><p>高频访问优化：</p>
<ul>
<li>分库分表：将数据库进行水平拆分，较少表的长度；</li>
<li>增加缓存：在WEB和DB之间加一层缓存层；</li>
<li>增加数据库索引：在合适的字段上加上索引；</li>
</ul>
<p>并发优化：</p>
<ul>
<li>主从读写分离：只能从主服务器上写，其他从服务器都可以读；</li>
<li>负载均衡集群：通过集群或者分布式的方式解决并发压力；</li>
</ul>
<h4 id="11-MySQL数据库引擎介绍（InnoDB和Myisam的区别）"><a href="#11-MySQL数据库引擎介绍（InnoDB和Myisam的区别）" class="headerlink" title="11. MySQL数据库引擎介绍（InnoDB和Myisam的区别）"></a>11. MySQL数据库引擎介绍（InnoDB和Myisam的区别）</h4><ul>
<li><p>InnoDB：</p>
<p>恢复。适合更新频繁和多并发，表\行级锁。</p>
</li>
<li><p>Myisam：</p>
</li>
</ul>
<p>插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用，表级锁。</p>
<ul>
<li>Memory：</li>
</ul>
<p>将表中数据保存在内存里，适合数据量比较小且频繁访问的场景。</p>
<ul>
<li>…</li>
</ul>
<h4 id="12-数据库中事务的ACID"><a href="#12-数据库中事务的ACID" class="headerlink" title="12. 数据库中事务的ACID"></a>12. 数据库中事务的ACID</h4><ul>
<li>A-原子性：事务是一个不可分割的单位，这组操作要么全部发生，要么全部不发生；</li>
<li>C-一致性：在事务开始前，数据库中数据处于一个一致性状态，事务发生后，数据库中的数据也应该保持一种一致性。</li>
<li>I-隔离性：要求数据库中的事务不会受其他并发执行的事务的影响。</li>
<li>D-持久性：事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。</li>
</ul>
<h4 id="13-什么是脏读、不可重读度、幻读"><a href="#13-什么是脏读、不可重读度、幻读" class="headerlink" title="13. 什么是脏读、不可重读度、幻读"></a>13. 什么是脏读、不可重读度、幻读</h4><ul>
<li>脏读：</li>
</ul>
<p>指的是一个事务读取了另一个事务还没有提交的数据；</p>
<p>例如：事务T1修改了一个数据，事务T2在T1 commit或者rollback前读取了该数据，如果T1最终执行了rollback，T2将会读到一个不存在的数据。</p>
<ul>
<li>不可重复读：</li>
</ul>
<p>指的是对于数据库中的一条数据，一个事务多次查询却返回了不同的值。这是由于在查询的间隔中，该字段被另一个事务修改并提交了。</p>
<p>例如：事务T1读取一个数据，之后事务T2修改了这个数据并且commit了，那么如果T1再次读取这个数据，将读不到该数据或者读到一个修改过的数据。</p>
<ul>
<li>幻读：</li>
</ul>
<p>事务多次按照某个条件查找数据时，查询结果不一致。这是由于在查询间隔中，有其他事务删除或者新增了数据。</p>
<p>例如：事务T1读取了一些满足某个条件的数据，之后事务T2插入或者删除了满足这个条件的一些数据并且Commit，如果T1再次按照该条件读取数据，将会读到和第一次不一样的数据。</p>
<h4 id="14-数据库的隔离级别，MySQL和Oracle的隔离级别分别是什么？"><a href="#14-数据库的隔离级别，MySQL和Oracle的隔离级别分别是什么？" class="headerlink" title="14. 数据库的隔离级别，MySQL和Oracle的隔离级别分别是什么？"></a>14. 数据库的隔离级别，MySQL和Oracle的隔离级别分别是什么？</h4><p>四种隔离级别：</p>
<table>
<thead>
<tr>
<th>级别名</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交<br />(Read Uncommited)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读已提交<br />(Read Commited)</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读<br />(Repeatable Read)</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化<br />(Serializable)</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<ul>
<li>读未提交(Read Uncommited)  </li>
</ul>
<p>一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而且还能看到其他事务没有提交的对已有记录的更新。</p>
<ul>
<li>读已提交(Read Commited)</li>
</ul>
<p>一个事务在执行过程中可以看到其他事务已经提交过的新插入的记录，而且还能看到其他事务已经提交的对已有记录的更新。</p>
<ul>
<li>可重复读(Repeatable Read)</li>
</ul>
<p>一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务已经提交的对已有记录的更新。</p>
<ul>
<li>串行化(Serializable)</li>
</ul>
<p>一个事务执行过程中完全看不到其他事务对数据库所做的更新。当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。因此，这两个事务实际上是串行化方式运行。         </p>
<p>MySQL默认的事务隔离级别是<strong>可重复读(Repeatable Read)</strong>；</p>
<p>Oracle默认的事务隔离界别是<strong>读已提交(Read Commited)；</strong> — PG</p>
<h4 id="15-数据库连接池的作用"><a href="#15-数据库连接池的作用" class="headerlink" title="15. 数据库连接池的作用"></a>15. 数据库连接池的作用</h4><p>数据库连接池：为数据库连接建立一个“缓冲池”，池子里预先放入了一定数量的数据库连接管道，需要时，从池子里取出管道进行使用，操作完毕后，再将管道放入池子里，从而避免了频繁向数据库申请资源，释放资源带来的性能消耗。</p>
<ul>
<li><p>资源重用：连接得到了重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，增加了系统环境的平衡性（减少内存碎片以及数据库临时进程线程的数量）</p>
</li>
<li><p>更快的系统响应速度：数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池内。此时连接池的初始化操作均已经完成。对于业务请求，直接利用现有连接即可，避免了数据库连接初始化和释放过程的时间开销，从而缩减系统整体响应时间。</p>
</li>
<li><p>新的资源分配手段：对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接技术。</p>
</li>
<li><p>统一的连接管理，避免数据库连接泄露：在较为完备的数据库连接池实现中，可根据预先设定的连接占用超时设定，强制收回被占用的连接，从而避免常规数据库连接操作中，可能出现的资源泄露。</p>
</li>
</ul>
<h4 id="16-MySQL的表空间方式、各自的优缺点"><a href="#16-MySQL的表空间方式、各自的优缺点" class="headerlink" title="16. MySQL的表空间方式、各自的优缺点"></a>16. MySQL的表空间方式、各自的优缺点</h4><p>InnoDB包含两种表空间文件模式：</p>
<ul>
<li>共享表空间（默认）：</li>
</ul>
<p>指得是数据库中的所有的数据保存在一个表空间内，而这个表空间可以由多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。默认表空间大小最大为64TB，也就是说InnoDB的单表限制基本在64TB左右了，这个大小包括这个表的所有索引等其他相关数据。</p>
<p>优点：表空间可以分成多个文件存放到各个磁盘，所以表也可以分成多个文件存放在磁盘上，表的大小不受磁盘大小的限制，数据和文件放在一起方便管理；</p>
<p>缺点：所有的数据和索引存放到一个文件，虽然可以把一个大文件分成多个小文件，但是多个表以及索引在表空间中混合存储，当数据量非常大的时候，表做了大量删除操作后，表空间中将会有大量的空隙，特别是对于统计分析，对于经常删除操作的这类应用不适合使用共享表空间；共享表空间分配后不能回缩，即当出现临时创建索引或者创建临时表的操作，表空间扩大后，即使删除相关表也没办法回缩那部分空间了。</p>
<ul>
<li>独立表空间：</li>
</ul>
<p>每个表都有独立的多个数据文件，而且做到了索引和数据的分离；</p>
<p>优点：每个表都有自己独立的表空间，每个表的数据和索引都会存在在自己的空间内，可以实现单表在不同的数据库中移动；空间可以回收，Drop Table操作自动回收表空间；对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
<p>缺点：当数据库中表数量达到一定级别时，每次操作所涉及的文件过多；另外，这种数据文件的利用率不高，当大量“不高”的文件集中起来，浪费的空间也很惊人。</p>
<h4 id="17-分布式事务"><a href="#17-分布式事务" class="headerlink" title="17. 分布式事务"></a>17. 分布式事务</h4><h4 id="18-数据库范式"><a href="#18-数据库范式" class="headerlink" title="18. 数据库范式"></a>18. 数据库范式</h4><ul>
<li>第一范式(1NF)：</li>
</ul>
<p>如果一个关系模式R的所有属性都是<strong>不可分</strong>的基本数据项，则这个关系模式属于第一范式；</p>
<ul>
<li>第二范式(2NF)：</li>
</ul>
<p>如果关系模式R属于第一范式，且每个<strong>非主属性</strong>都<strong>完全函数依赖</strong>于键码，则R属于第二范式；第二范式消除了<strong>非主属性</strong>对键码的<strong>部分依赖</strong>；</p>
<ul>
<li>第三范式(3NF)：</li>
</ul>
<p>如果关系模式R属于第一范式，且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于键码，则R属于第三范式；第三范式消除了<strong>非主属性</strong>对键码的<strong>传递依赖</strong>；</p>
<ul>
<li>BC范式(BCNF)：</li>
</ul>
<p>如果关系模式R属于第一范式，且<strong>每个属性</strong>都<strong>不传递依赖</strong>于键码，则R属于BC范式；</p>
<h4 id="19-数据库的锁的种类、加锁的方式"><a href="#19-数据库的锁的种类、加锁的方式" class="headerlink" title="19. 数据库的锁的种类、加锁的方式"></a>19. 数据库的锁的种类、加锁的方式</h4><p>按照类型来分有乐观锁和悲观锁：</p>
<ul>
<li>乐观锁：对于并发执行可能冲突的操作，假设不会真的冲突，允许并发执行，在数据提交更新时，才会去检测数据是否有冲突；</li>
<li>悲观锁：对于并发执行可能冲突的操作，假设其必定发生冲突，所以在数据开始读取的时候就把数据锁住。</li>
</ul>
<p>按照粒度来分有行级锁、页级锁、表级锁。</p>
<p>按照作用来分有共享锁和排它锁：</p>
<ul>
<li>共享锁：读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁；</li>
<li>排它锁：写操作创建的锁，事务对数据加上排它锁后，其他事务不能对数据加上任何类型的锁。</li>
</ul>
<h4 id="20-分库分表的理解和简介"><a href="#20-分库分表的理解和简介" class="headerlink" title="20. 分库分表的理解和简介"></a>20. 分库分表的理解和简介</h4><p>参考：<a href="https://www.cnblogs.com/butterfly100/p/9034281.html" target="_blank" rel="noopener">数据库分库分表思路</a></p>
<h4 id="21-数据库高并发的解决方案"><a href="#21-数据库高并发的解决方案" class="headerlink" title="21. 数据库高并发的解决方案"></a>21. 数据库高并发的解决方案</h4><ul>
<li>在WEB框架中加入缓存，在服务器和数据库层之间加入缓存层，将高频访问的数据放入缓存，较少数据库的读取负担。</li>
<li>增加数据库索引，提高查询速度（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读；</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询速度；</li>
<li>使用分布式架构，分散计算压力；</li>
</ul>
<h4 id="22-乐观锁与悲观锁怎么实现的"><a href="#22-乐观锁与悲观锁怎么实现的" class="headerlink" title="22. 乐观锁与悲观锁怎么实现的"></a>22. 乐观锁与悲观锁怎么实现的</h4><ul>
<li>悲观锁：</li>
</ul>
<p>通过数据库的锁机制实现，有行级锁、表级锁等。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而表级锁则对整张表进行锁定，事务正在对</p>
<p>该表进行访问时不允许其他事务并行访问。</p>
<ul>
<li>乐观锁：</li>
</ul>
<p>大多数是基于数据版本（version）记录机制实现：具体是通过给表加一个版本号或者时间戳字段实现，当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1,。当我们提交更新的时候，判断当前版本信息与第一次取出来的版本值大小，如果一致，则予以更新，否则认为是过期数据，拒绝更新，让用户重新操作。</p>
<h4 id="23-对数据库目前最新技术有什么了解吗"><a href="#23-对数据库目前最新技术有什么了解吗" class="headerlink" title="23. 对数据库目前最新技术有什么了解吗"></a>23. 对数据库目前最新技术有什么了解吗</h4><hr>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h5 id="函数依赖："><a href="#函数依赖：" class="headerlink" title="函数依赖："></a><strong>函数依赖：</strong></h5><p>如果关系R的两个元组在属性A1, A2, …, An上一致，则它们在另一个属性B上也一致。那么，我们就说再关系R中属性B函数依赖于属性A1, A2, …, An。也可以说是”A1, A2, …, An 函数决定B”。其中，A1, A2, …, An称为决定因素。</p>
<p><strong>示例：</strong></p>
<p>考虑学生关系Student，该关系中所涉及的属性包括学生的学号Sno，姓名Sname，所在系Sdept，系主任姓名Mname，课程名Cname和成绩Grade。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/Student.jpg" alt="student"></p>
<p>由于一个学号只对应一个学生，一个学生只在一个系，因而当“学号”确定之后，姓名及其所在系也就唯一的确定了。</p>
<p>因此说Sno函数决定Sname和Sdept，或者说Sname和Sdept函数依赖于Sno。记作Sno-&gt;Sname，Sno-&gt;Sdept。</p>
<h5 id="关系键码："><a href="#关系键码：" class="headerlink" title="关系键码："></a>关系键码：</h5><p>如果一个或多个属性的集合<code>(A1, A2, ..., An)</code>满足如下条件，则称该集合为关系R的键码(key)：</p>
<ul>
<li>这些属性函数决定该关系的其他属性。也就是说，R中不可能有两个不同的元组，它们在<code>A1, A2, ..., An</code>上的取值完全相同；</li>
<li><code>{A1, A2, ..., An}</code>的任何真子集都不能函数决定R的所有其他属性，也就是说，键码必须是最小的。</li>
</ul>
<p>键码所在的属性称为主属性，键码以外的属性称为非主属性。</p>
<p><strong>示例：</strong></p>
<p>在学生关系Student中，属性集<code>{Sno, Cname}</code>构成Student的键码。</p>
<h5 id="函数依赖规则："><a href="#函数依赖规则：" class="headerlink" title="函数依赖规则："></a>函数依赖规则：</h5><ul>
<li><p>分解/合并规则：</p>
<p>我们可以把一个函数依赖<code>A1A2...An -&gt; B1B2...Bm</code>用一组函数依赖<code>A1A2...An -&gt; Bi(i=1, 2, ..., m)</code>来代替。这种转换称为“分解规则”；</p>
<p>我们也可以把一组函数依赖<code>A1A2...An -&gt; Bi(i=1, 2, ..., m)</code>用一个函数依赖<code>A1A2...An -&gt; B1B2...Bm</code>来代替，这种转换称为”合并规则”； </p>
</li>
<li><p>平凡依赖规则：</p>
<p>对于函数依赖<code>A1A2...An -&gt; B</code>，如果B是A中的某一个，则称之为“平凡的”。</p>
<p>函数依赖<code>A1A2...An -&gt; B1B2...Bm</code>等价于<code>A1A2...An -&gt; C1C2...Ck</code>，其中C是B的子集，但不在A中出现。我们称这个规则为“平凡依赖规则”。</p>
</li>
<li><p>传递规则：</p>
<p>如果<code>A1A2...An -&gt; B1B2...Bm</code>和<code>B1B2...Bm -&gt; C1C2...Ck</code>在关系R中成立，则<code>A1A2...An -&gt; C1C2...Ck</code>在R中也成立。这个规则就称为”传递规则“。</p>
</li>
</ul>
<h5 id="完全依赖与部分依赖："><a href="#完全依赖与部分依赖：" class="headerlink" title="完全依赖与部分依赖："></a>完全依赖与部分依赖：</h5><p>对应函数依赖W -&gt; A，如果存在V(V是W的真子集)而函数依赖V -&gt; A成立，则称A部分依赖于W；否则，若不存在这种V，则称A完全依赖于W。</p>
<p>在一个关系模式中，当存在非主属性属性对键码的部分依赖时，就会产生数据冗余和更新异常。比如上述的Student关系示例，对键码部分依赖的属性Sname，Sdept和Mname由于只函数依赖于Sno，因此当一个学生选修几门课时，这些数据就会多次重复出现，造成大量数据冗余；另一方面，当对一个学生的基本情况(学号、姓名、所在系)进行更新时，又会出现更新异常。</p>
<h5 id="传递依赖："><a href="#传递依赖：" class="headerlink" title="传递依赖："></a>传递依赖：</h5><p>对于函数依赖X -&gt; Y，如果Y -/-&gt; X(X不函数依赖于Y)而函数依赖Y-&gt;Z成立，则称Z对X传递依赖。</p>
<p>在学生关系中，Sno-&gt;Sdept，Sdept-&gt;Mname，Sno-&gt;Mname，Mname传递依赖于Sno。可以看出，当一个学生选修多门课时，系主任的名字也会多次重复出现；当对学生的基本情况进行更新时，同样会出现类似的更新异常。</p>
<h5 id="基于锁的实现："><a href="#基于锁的实现：" class="headerlink" title="基于锁的实现："></a>基于锁的实现：</h5><p>数据库管理系统提供的基本类型有两种：排它锁(exclusive lock, 简记为X锁)以及共享锁(share lock, 简记为S锁)。</p>
<p>若事务T对数据对象A加了X锁，则T就可以对A进行读取以及更新(X锁因此又称为写锁)；在T释放A上的X锁之前，任何其他事务都不能再对A加任何类型的锁，从而也不能读取和更新A。</p>
<p>若事务T对A加了S锁，则T就可以对A进行读取，但不能进行更新(S锁因此又称为读锁)，在T释放A上的S锁之前，其他事务可以再对A加S锁，但不能加X锁，从而可以读取A，但不能更新A。</p>
<h5 id="三级封锁协议："><a href="#三级封锁协议：" class="headerlink" title="三级封锁协议："></a>三级封锁协议：</h5><ul>
<li>1级封锁协议</li>
</ul>
<p>事务T在修改数据A之前必须对先对其加X锁，直到事务结束（提交或者回滚）才释放该锁。</p>
<p>1级封锁协议不要求事务在读数据之前加锁，这样“不可重复读”和“脏读”仍有可能发生。</p>
<ul>
<li>2级封锁协议</li>
</ul>
<p>在1级封锁协议的基础上加上这样的约定：事务T在读取A之前必须对其加S锁，读入该数据后即可立即释放S锁。</p>
<p>2级封锁协议避免了“脏读”，不能避免“不可重复读”。</p>
<ul>
<li>3级封锁协议</li>
</ul>
<p>在1级封锁协议的基础上加上这样的约定：事务T在读取A之前必须对其加S锁，直到事务结束（提交或者回滚）才生释放S锁。</p>
<p>3级封锁协议即避免了“脏读”，又避免了“不可重复读”。</p>
<h5 id="两段锁协议："><a href="#两段锁协议：" class="headerlink" title="两段锁协议："></a>两段锁协议：</h5><p>事务T在对数据A进行读或写之前，必须先获得对A的封锁，并且在释放一个封锁之后，T不能再获得任何其他锁。这就是“两段”锁的含义：事务分成获得封锁和释放封锁即加锁和解锁两个阶段。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL内核-添加自定义系统函数</title>
    <url>/2020/05/07/PostgreSQL%E5%86%85%E6%A0%B8-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>最近在做的项目是要在PG数据库上兼容实现Oracle的部分功能，其中一个点就是在PG上去兼容Oracle的四个正则表达式函数，分别是：</p>
<ul>
<li>regexp_count()</li>
<li>regexp_substr()</li>
<li>regexp_instr()</li>
<li>regexp_replace()</li>
</ul>
<p>实现的方式就是在PG中添加同名的内置系统函数，并实现相应功能。</p>
<p>本文的重点在于介绍如何在PG中添加自定义的函数作为内置系统函数，而不是如何实现相关函数。接下来将以兼容实现<code>regexp_count()</code>函数为例进行说明。</p>
<hr>
<h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><h4 id="Oid："><a href="#Oid：" class="headerlink" title="Oid："></a>Oid：</h4><p>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type <code>oid</code> represents an object identifier.</p>
<h4 id="pg-proc系统表："><a href="#pg-proc系统表：" class="headerlink" title="pg_proc系统表："></a>pg_proc系统表：</h4><p>在PG中，所有内置系统函数的基本信息都保存在<code>pg_proc</code>系统表中，每个函数都对应一个<code>Oid</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select oid,proname from pg_proc limit 10; </span></span><br><span class="line"> oid  | proname  </span><br><span class="line">------+----------</span><br><span class="line"> 1242 | boolin</span><br><span class="line"> 1243 | boolout</span><br><span class="line"> 1244 | byteain</span><br><span class="line">   31 | byteaout</span><br><span class="line"> 1245 | charin</span><br><span class="line">   33 | charout</span><br><span class="line">   34 | namein</span><br><span class="line">   35 | nameout</span><br><span class="line">   38 | int2in</span><br><span class="line">   39 | int2out</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<h4 id="函数注册："><a href="#函数注册：" class="headerlink" title="函数注册："></a>函数注册：</h4><p>假设我们已经实现了一个自定义函数，比如<code>regexp_count()</code>，PG如何才能知道该函数的存在呢？答案是通过函数注册实现。</p>
<p>需要将自定义函数的相关信息添加到<code>src/include/catalog/pg_prco.dat</code>中，在PG编译时，perl脚本会根据<code>pg_proc.dat</code>文件生成<code>src/backend/catalog/postgres.bki</code>文件，该文件在执行<code>initdb</code>被解析成一条条的SQL语句，并插入到系统表<code>pg_proc</code>中。</p>
<hr>
<h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h3><h4 id="第一步：函数定义及实现"><a href="#第一步：函数定义及实现" class="headerlink" title="第一步：函数定义及实现"></a>第一步：函数定义及实现</h4><p>经过分析Oracle的<code>regexp_count()</code>函数，根据不同的参数个数，有如下调用形式：</p>
<ul>
<li><p>regexp_count(source_char, pattern)</p>
</li>
<li><p>regexp_count_with_position(source_char, pattern, position)</p>
</li>
<li><p>regexp_count_with_flags(source_char, pattern, position, flags)</p>
</li>
</ul>
<p>函数返回值类型为：<strong>int4</strong>。</p>
<p>实现的代码大致为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Datum</span><br><span class="line">regexp_count(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">text</span>	   *orig_str = PG_GETARG_TEXT_PP(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">text</span>	   *pattern = PG_GETARG_TEXT_PP(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span>        <span class="built_in">position</span> = PG_NARGS() &gt; <span class="number">2</span> ? PG_GETARG_INT32(<span class="number">2</span>) : <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">text</span>	   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(<span class="number">3</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">position</span> &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		ereport(ERROR,</span><br><span class="line">			(errcode(ERRCODE_INVALID_PARAMETER_VALUE),</span><br><span class="line">			errmsg(<span class="string">"argument %d is out of range"</span>, <span class="built_in">position</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	orig_str = text_substring(PG_GETARG_DATUM(<span class="number">0</span>), <span class="built_in">position</span>, <span class="number">-1</span>, <span class="literal">true</span>);			</span><br><span class="line">			</span><br><span class="line">	pg_re_flags re_flags;</span><br><span class="line">	regexp_matches_ctx *matchctx;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Determine options */</span></span><br><span class="line">	<span class="comment">// parse_re_flags(&amp;re_flags, flags);</span></span><br><span class="line">	custom_parse_re_flags(&amp;re_flags, flags);</span><br><span class="line"></span><br><span class="line">	matchctx = setup_regexp_matches(orig_str, pattern, &amp;re_flags,</span><br><span class="line">									PG_GET_COLLATION(), <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	PG_RETURN_INT32((int32)matchctx-&gt;nmatches);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">regexp_count_with_position(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> regexp_count(fcinfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">regexp_count_with_flags(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> regexp_count(fcinfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二步：分配可用OID"><a href="#第二步：分配可用OID" class="headerlink" title="第二步：分配可用OID"></a>第二步：分配可用OID</h4><p>PG提供了<code>unused_oids</code>工具用于快速检索未使用的Oid，该工具位于：<code>src/include/catalog/unused_oids</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">totem@totem-vm:~/SGRDB-AK$ ./src/include/catalog/unused_oids</span><br><span class="line">4 - 9</span><br><span class="line">210</span><br><span class="line">270 - 273</span><br><span class="line">357</span><br><span class="line">380 - 381</span><br><span class="line">421</span><br><span class="line">560 - 583</span><br><span class="line">606</span><br><span class="line">702 - 704</span><br><span class="line">760 - 763</span><br><span class="line">...</span><br><span class="line">6107 - 6109</span><br><span class="line">6116</span><br><span class="line">6122 - 9999</span><br></pre></td></tr></table></figure>

<p>根据列出的未使用的OID范围，为每个函数选择合适的OID，结果如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>OID</th>
</tr>
</thead>
<tbody><tr>
<td>regexp_count</td>
<td>5101</td>
</tr>
<tr>
<td>regexp_count_with_position</td>
<td>5102</td>
</tr>
<tr>
<td>regexp_count_with_flags</td>
<td>5103</td>
</tr>
</tbody></table>
<h4 id="第三步：函数注册"><a href="#第三步：函数注册" class="headerlink" title="第三步：函数注册"></a>第三步：函数注册</h4><p>在文件<code>src/include/catalog/pg_proc.dat</code>中添加如下函数注册信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123; oid =&gt; '5101', descr =&gt; 'find match_count for regexp',</span><br><span class="line">  proname =&gt; 'regexp_count',  prorows =&gt; '1', prorettype =&gt; 'int4',</span><br><span class="line">  proargtypes =&gt; 'text text', prosrc =&gt; 'regexp_count' </span><br><span class="line">&#125;,</span><br><span class="line">&#123; oid =&gt; '5102', descr =&gt; 'find match_count for regexp',</span><br><span class="line">  proname =&gt; 'regexp_count',  prorows =&gt; '1', prorettype =&gt; 'int4',</span><br><span class="line">  proargtypes =&gt; 'text text int4', prosrc =&gt; 'regexp_count_with_position' </span><br><span class="line">&#125;,</span><br><span class="line">&#123; oid =&gt; '5103', descr =&gt; 'find match_count for regexp',</span><br><span class="line">  proname =&gt; 'regexp_count',  prorows =&gt; '1', prorettype =&gt; 'int4',</span><br><span class="line">  proargtypes =&gt; 'text text int4 text', prosrc =&gt; 'regexp_count_with_flags' </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在编译成功后，上面几条记录在<code>postgres.bki</code>中对应的形式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">insert</span> ( <span class="number">5101</span> regexp_count <span class="number">11</span> <span class="number">10</span> <span class="number">12</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> f f f t f i s <span class="number">2</span> <span class="number">0</span> <span class="number">23</span> <span class="string">"25 25"</span> _null_ _null_ _null_ _null_ _null_ regexp_count _null_ _null_ _null_ )</span><br><span class="line"><span class="keyword">insert</span> ( <span class="number">5102</span> regexp_count <span class="number">11</span> <span class="number">10</span> <span class="number">12</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> f f f t f i s <span class="number">3</span> <span class="number">0</span> <span class="number">23</span> <span class="string">"25 25 23"</span> _null_ _null_ _null_ _null_ _null_ regexp_count_with_position _null_ _null_ _null_ )</span><br><span class="line"><span class="keyword">insert</span> ( <span class="number">5103</span> regexp_count <span class="number">11</span> <span class="number">10</span> <span class="number">12</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> f f f t f i s <span class="number">4</span> <span class="number">0</span> <span class="number">23</span> <span class="string">"25 25 23 25"</span> _null_ _null_ _null_ _null_ _null_ regexp_count_with_flags _null_ _null_ _null_ )</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="第四步：添加函数到PG源码"><a href="#第四步：添加函数到PG源码" class="headerlink" title="第四步：添加函数到PG源码"></a>第四步：添加函数到PG源码</h4><p>将自定义函数代码添加到合适的源代码文件中，这里将<code>regexp_count()</code>函数代码添加到了<code>src/backend/utils/adt/regex.c</code>文件中。</p>
<h4 id="第五步：编译安装"><a href="#第五步：编译安装" class="headerlink" title="第五步：编译安装"></a>第五步：编译安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="第六步：初始化、启动数据库"><a href="#第六步：初始化、启动数据库" class="headerlink" title="第六步：初始化、启动数据库"></a>第六步：初始化、启动数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./initdb -D ../data</span><br><span class="line">./pg_ctl -D ../data start</span><br><span class="line">./createdb <span class="built_in">test</span></span><br><span class="line">./psql <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="第七步：验证："><a href="#第七步：验证：" class="headerlink" title="第七步：验证："></a>第七步：验证：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select regexp_count('abc'||CHR(10)||'ABC', 'abc');</span></span><br><span class="line"> regexp_count </span><br><span class="line">--------------</span><br><span class="line">            1</span><br><span class="line">(1 row)</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select regexp_count('abc'||CHR(10)||'ABC', 'abc', 2);</span></span><br><span class="line"> regexp_count </span><br><span class="line">--------------</span><br><span class="line">            0</span><br><span class="line">(1 row)</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select regexp_count('abc'||CHR(10)||'ABC', 'abc', 1, 'i');</span></span><br><span class="line"> regexp_count </span><br><span class="line">--------------</span><br><span class="line">            2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://www.postgresql.org/docs/12/functions-string.html" target="_blank" rel="noopener">PG-9.4. String Functions and Operators</a></li>
<li><a href="https://www.postgresql.org/docs/12/functions-matching.html#FUNCTIONS-POSIX-REGEXP" target="_blank" rel="noopener">PG-9.7. Pattern Matching</a></li>
<li><a href="https://www.postgresql.org/docs/12/catalog-pg-proc.html" target="_blank" rel="noopener">PG-51.39. pg_proc</a></li>
<li><a href="https://docs.oracle.com/database/121/SQLRF/functions161.htm#SQLRF20014" target="_blank" rel="noopener">Oracle-REGEXP_COUNT</a></li>
<li><a href="https://www.postgresql.org/docs/12/catalog-pg-proc.html" target="_blank" rel="noopener">PG-51.39. pg_proc</a></li>
<li><a href="https://docs.oracle.com/database/121/ADFNS/adfns_regexp.htm#ADFNS1003" target="_blank" rel="noopener">Oracle-Using Regular Expressions in Database Applications</a></li>
<li><a href="https://www.postgresql.org/docs/current/datatype-oid.html" target="_blank" rel="noopener">PG-8.19. Object Identifier Types</a></li>
<li><a href="http://blog.itpub.net/6906/viewspace-2642750/" target="_blank" rel="noopener">PostgreSQL 源码解读（180）- 内核研发#4(如何实现自定义系统函数)</a></li>
</ul>
<blockquote>
<p>文中有什么错误或者不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库内核开发</tag>
        <tag>兼容Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内存管理机制</title>
    <url>/2020/04/13/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>在之前的面试中有被问到Python的内存管理机制，回答的不好，之后查阅了一些文章，这里简单做下总结。Python的内存管理机制主要包含以下几个方面：</p>
<ul>
<li>引用计数</li>
<li>垃圾回收</li>
<li>内存池机制</li>
</ul>
<hr>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在Python中，一切皆可视为对象。对每一个对象，都维护了一个指向该对象的引用总数，即引用计数。我们可以使用<code>sys</code>包中的<code>getrefcount()</code>来查看指定对象的引用计数。需要注意的是，<code>getrefcount()</code>函数本身会为参数中对象创建一个引用。因此，<code>getrefcount()</code>的返回值会比期望的多1个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(a))  <span class="comment"># 结果为3而不是2</span></span><br></pre></td></tr></table></figure>

<h4 id="引用计数增加："><a href="#引用计数增加：" class="headerlink" title="引用计数增加："></a>引用计数增加：</h4><ul>
<li>对象被创建：<code>a = [1, 2, 3]</code> </li>
<li>对象被赋值给其他变量：<code>b = a</code></li>
<li>被作为参数传递给函数：<code>func(a)</code></li>
<li>作为容器对象中的一个元素：<code>b = [a, a]</code></li>
</ul>
<h4 id="引用计数减少："><a href="#引用计数减少：" class="headerlink" title="引用计数减少："></a>引用计数减少：</h4><ul>
<li>一个本地引用离开了它的作用域。比如上面的<code>func(a)</code>函数结束时，<code>a</code>指向的对象引用减1。</li>
<li>对象的别名被显示的销毁：<code>del a</code>。</li>
<li>对象的一个别名被赋值给其他对象：如上面置<code>b = [2, 3, 4]</code>，那么<code>a</code>指向的对象引用减1。</li>
<li>对象从一个容器对象中移除：<code>b.remove(a)</code></li>
<li>容器对象本身被销毁：<code>del b</code>；或者容器对象本身离开了作用域。</li>
</ul>
<h4 id="引用环："><a href="#引用环：" class="headerlink" title="引用环："></a>引用环：</h4><p>两个对象可能相互引用，或者一个对象自己引用自己，从而造成所谓的<strong>引用环</strong>(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相互引用</span></span><br><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自身引用</span></span><br><span class="line">a = []</span><br><span class="line">a.append(a)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Python为每个对象维护着引用计数，当某个对象的引用计数为0时，说明没有任何引用指向该对象，即用户不能通过任何方式接触或者运用这个对象。那么这个对象就成为了要被回收的垃圾。</p>
<p>在进行垃圾回收时，Python不能进行其它人任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要立刻启动垃圾回收。所以，Python只会在特定的条件下启动垃圾回收。</p>
<p>在Python运行时，会记录其中<strong>分配对象</strong>(object allocation)和<strong>取消分配对象</strong>(object deallocation)的次数，当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>此阈值可以通过<code>gc</code>模块的<code>get_threshold()</code>函数查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())  <span class="comment"># (700, 10, 10)</span></span><br></pre></td></tr></table></figure>

<p>返回（700， 10， 10）。其中700即是垃圾回收启动的阈值，后面的两个10是与<strong>分代回收</strong>相关的阈值。可以通过<code>gc</code>模块中的<code>set_threshold()</code>函数重新设置。</p>
<p>我们也可以使用<code>gc.collect()</code>函数手动启动垃圾回收。</p>
<h4 id="分代回收："><a href="#分代回收：" class="headerlink" title="分代回收："></a>分代回收：</h4><p>Python同时采用了<strong>分代回收</strong>(generation)的策略。这一策略的假设是：存活时间越久的对象，越不可能在后面的程序中变成垃圾。</p>
<p>我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这些<em>长寿</em>的对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过<strong>一定次数</strong>的垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了<strong>一定次数</strong>的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即为上面<code>get_threshold()</code>函数结果中的两个值。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以使用<code>set_threshold()</code>来调整。</p>
<h4 id="引用环：-1"><a href="#引用环：-1" class="headerlink" title="引用环："></a>引用环：</h4><p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>

<p>上面我们先创建了两个列表对象，并相互引用对方，构成了一个引用环。删除了a, b引用之后，这两个对象都不能再从程序中调用，就没什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200413214658.png" alt=""></p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为<code>gc_ref</code>。假设，每个对象i，该计数为<code>gc_ref_i</code>。Python会遍历所有的对象i。对于每个对象i引用对象j，将相应的<code>gc_ref_j</code>减1。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200413214933.png" alt=""></p>
<p>在结束遍历后，<code>gc_ref</code>不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<hr>
<h3 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h3><p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200413215259.png" alt=""></p>
<p>Python的内存机制呈金字塔型：</p>
<ul>
<li>-1，-2层主要由操作系统进行操作。</li>
<li>第0层是C中的<code>malloc()</code>、<code>free()</code>等内存分配和释放函数进行操作。</li>
<li>第1层和第2层是内存池，由Python的接口函数<code>PyMem_API</code>函数实现，当对象小于256K时由该层直接分配内存。</li>
<li>第3层是最上层，也就是我们对Python对象的直接操作。</li>
</ul>
<p>在C中如果频繁的调用<code>malloc()</code>与<code>free()</code>，是会产生性能问题的。再加上频繁的分配与释放小块内存会产生内存碎片。</p>
<ul>
<li><p>经由内存池登记的内存到最后还是会回收到内存池，并不会调用<code>free()</code>释放掉，以便下次使用。</p>
</li>
<li><p>对于一些特定的Python对象，例如<code>int</code>，<code>string</code>、<code>list</code>、<code>dict</code>等，会分别有专门的内存来存储，即这些内存只能存储指定类型的对象。</p>
</li>
</ul>
<hr>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="https://www.cnblogs.com/CBDoctor/p/3781078.html" target="_blank" rel="noopener">python的内存管理机制</a></li>
<li><a href="https://www.cnblogs.com/vamei/p/3232088.html" target="_blank" rel="noopener">Python深入06 Python的内存管理</a></li>
<li><a href="https://docs.python.org/zh-cn/3.6/c-api/memory.html" target="_blank" rel="noopener">内存管理</a></li>
</ul>
<blockquote>
<p>文中有什么错误或者不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基本数据类型defaultdict</title>
    <url>/2020/04/05/Python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bdefaultdict/</url>
    <content><![CDATA[<h3 id="字典中的KeyError异常"><a href="#字典中的KeyError异常" class="headerlink" title="字典中的KeyError异常"></a>字典中的KeyError异常</h3><p>Python中字典（Dict）这种数据类型是通过键值（key）来存取的，当使用一个不存在的键值取值时，会引发<code>keyerror</code>异常。为避免这种情况，有以下几种方法：</p>
<ul>
<li>判断是否存在此键值</li>
<li>使用<code>dict.setdefault()</code>设置默认值</li>
<li>使用<code>collections</code>模块中的<code>defaultdict</code>数据类型来代替默认的<code>dict</code></li>
</ul>
<hr>
<h4 id="判断是否存在"><a href="#判断是否存在" class="headerlink" title="判断是否存在"></a>判断是否存在</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">        d[key].append(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[key] = []</span><br><span class="line">        d[key].append(value)</span><br><span class="line">print(d)  <span class="comment"># &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="dict-setdefault"><a href="#dict-setdefault" class="headerlink" title="dict.setdefault()"></a>dict.setdefault()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    d.setdefault(key, []).append(value)</span><br><span class="line">print(d)  <span class="comment"># &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>dict.setdefault()</code>方法接收两个参数，一个是键的名称，另一个是默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setdefault</span><span class="params">(self, *args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Insert key with a value of default if key is not in the dictionary. </span></span><br><span class="line"><span class="string">    Return the value for key if key is in the dictionary, else default.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict()"></a>collections.defaultdict()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    d[key].append(value)</span><br><span class="line">print(d)  <span class="comment"># defaultdict(&lt;class 'list'&gt;, &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="collections-defaultdict模块介绍："><a href="#collections-defaultdict模块介绍：" class="headerlink" title="collections.defaultdict模块介绍："></a>collections.defaultdict模块介绍：</h3><p><code>defaultdict</code>是<code>dict</code>的一个子类，可以实现为不存在的键值返回一个默认值。</p>
<ul>
<li><strong>default_factory</strong></li>
</ul>
<p><code>defaultdict</code>在初始化时可以提供一个<code>default_factory</code>的参数。<code>default_factory</code>接收一个工厂函数作为参数，可以是<code>int()/str()/list()</code>等内置函数，也可以是自定义函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, default_factory=None, **kwargs)</span>:</span> <span class="comment"># known case of _collections.defaultdict.__init__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    defaultdict(default_factory[, ...]) --&gt; dict with default factory</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    The default factory is called without arguments to produce</span></span><br><span class="line"><span class="string">    a new value when a key is not present, in __getitem__ only.</span></span><br><span class="line"><span class="string">    A defaultdict compares equal to a dict with the same items.</span></span><br><span class="line"><span class="string">    All remaining arguments are treated the same as if they were</span></span><br><span class="line"><span class="string">    passed to the dict constructor, including keyword arguments.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    # (copied from class doc)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">default_factory = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"><span class="string">"""Factory for default value called by __missing__()."""</span></span><br></pre></td></tr></table></figure>

<p><code>defaultdict</code>可以通过类属性<code>default_factory</code>来查看此工厂函数的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = collections.defaultdict(list)</span><br><span class="line">print(d.default_factory)  <span class="comment"># &lt;class 'list'&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>__missing__(key)</strong></li>
</ul>
<p><code>defaultdict</code>在<code>dict</code>的基础上添加了一个<code>__missing__(key)</code>方法，在调用一个不存的key的时候， <code>defaultdict</code>会调用<code>__missing__()</code>，根据<code>default_factory</code>参数创建一个实例，作为此<code>key</code>的默认值返回。如果初始化时<code>default_factory</code>参数为空，仍然会引发<code>KeyError</code>异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    __missing__(key) # Called by __getitem__ for missing key; pseudo-code:</span></span><br><span class="line"><span class="string">      if self.default_factory is None: raise KeyError((key,))</span></span><br><span class="line"><span class="string">      self[key] = value = self.default_factory()</span></span><br><span class="line"><span class="string">      return value</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="使用自定义函数作为工厂函数"><a href="#使用自定义函数作为工厂函数" class="headerlink" title="使用自定义函数作为工厂函数"></a>使用自定义函数作为工厂函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = collections.defaultdict(custom_function)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    d[key].append(value)</span><br><span class="line">print(d)  <span class="comment"># defaultdict(&lt;function custom_function at 0x0000017038C7C1E0&gt;, &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;)</span></span><br><span class="line">print(d.default_factory)  <span class="comment"># &lt;function custom_function at 0x00000247FD18C1E0&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用lambda函数"><a href="#使用lambda函数" class="headerlink" title="使用lambda函数"></a>使用lambda函数</h4><p>使用匿名函数（lambda function）可以更快、更灵活的创建常值函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant_factory</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: value</span><br><span class="line"></span><br><span class="line">d = collections.defaultdict(constant_factory(<span class="string">'&lt;missing&gt;'</span>))</span><br><span class="line">d.update(name=<span class="string">'John'</span>, action=<span class="string">'ran'</span>)</span><br><span class="line">print(<span class="string">'%(name)s %(action)s to %(object)s'</span> % d)  <span class="comment"># John ran to &lt;missing&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>dict</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题打卡提醒程序实现与部署</title>
    <url>/2020/03/30/leetcode%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1%E6%8F%90%E9%86%92%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="一、前因后果"><a href="#一、前因后果" class="headerlink" title="一、前因后果"></a>一、前因后果</h3><p>今天是3月30号，还差一天 <a href="https://leetcode-cn.com/circle/article/9EZfRE/" target="_blank" rel="noopener">leetcode-cn每日一题</a> 活动就满一个月了，下面这张图是博主这一个月的打卡记录：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/%E6%89%93%E5%8D%A1.png" alt=""></p>
<p>不要问我为什么有一个红叉叉，因为我也记不得当天为什么没有完成打卡了。但是就因为这一个红叉叉，我与下面的打卡奖励就无缘了。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200330215802.png" alt=""></p>
<p>为了更好的完成打卡任务，以及养成刷题的习惯，今天就写了一个leetcode-cn打卡提醒的程序，并且部署在了服务器上，这里记录一下实现的步骤。</p>
<hr>
<h3 id="二、打卡程序"><a href="#二、打卡程序" class="headerlink" title="二、打卡程序"></a>二、打卡程序</h3><p>打卡提醒程序的本质是一个定时的爬虫任务，工作原理是：从每天的上午九点开始，去查询一下我的个人提交记录，如果发现了在当天有提交通过的记录，就认为打卡成功了；否则就认为还未打卡，就会给我的邮箱发送一封提醒的邮件，并且会每隔一个小时再去查询一次，直到发现打卡成功或者时间到了23点。</p>
<p>程序主要分为三个部分：</p>
<ul>
<li>爬虫，查询个人提交记录（登录状态）</li>
<li>邮件提醒功能</li>
<li>定时任务功能</li>
</ul>
<h4 id="爬虫，查询提交记录："><a href="#爬虫，查询提交记录：" class="headerlink" title="爬虫，查询提交记录："></a>爬虫，查询提交记录：</h4><ol>
<li><p>通过分析leetcode-cn的 <a href="https://leetcode-cn.com/submissions/#/1" target="_blank" rel="noopener">个人提交记录</a> 界面，可以发现<strong>提交记录数据</strong>是通过Ajax技术加载的，真正的链接如下：</p>
<blockquote>
<p> <a href="https://leetcode-cn.com/api/submissions/?offset=0&amp;limit=20&amp;lastkey=" target="_blank" rel="noopener">https://leetcode-cn.com/api/submissions/?offset=0&amp;limit=20&amp;lastkey=</a></p>
</blockquote>
<p>其中：limit表示每页展示的记录条数，offset来指定页数，为0即为第一页，lastkey在翻页的时候会更新，第一页时此值为空。</p>
<p>由于我们判断是否打卡成功一般只需要第一页的数据，所以使用上面一条链接就足够了，不需要再去构造翻页的链接。</p>
</li>
<li><p>此链接是在<strong>登录状态</strong>下查询<strong>自己的提交记录</strong>的接口，所以需要我们处于登录的状态，使用<strong>Cookie模拟登录</strong>即可。从浏览器复制cookie信息，构造<code>headers</code>，只需如下几个字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;    </span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">'your_cookie_info'</span>,  <span class="comment"># 在这里替换个人的cookie信息    </span></span><br><span class="line">    <span class="string">'referer'</span>: <span class="string">'https://leetcode-cn.com/submissions/'</span>,    </span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span>,    </span><br><span class="line">    <span class="string">'x-requested-with'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此链接查询的结果为json形式，直接解析即可，需要的字段有<strong>时间</strong>和<strong>状态</strong>两个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submission_check</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 检查是否打卡</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        submissions = response.json()</span><br><span class="line">        records = submissions[<span class="string">"submissions_dump"</span>]</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># 是否已打卡</span></span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> records:</span><br><span class="line">            sub_time, status = record[<span class="string">"time"</span>], record[<span class="string">"status_display"</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"分钟"</span> <span class="keyword">in</span> sub_time:</span><br><span class="line">                hour = sub_time.split()[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> int(hour) &lt;= <span class="number">9</span> <span class="keyword">and</span> status == <span class="string">"Accepted"</span>:  <span class="comment"># 首次检查在上午九点，筛除前一天的打卡记录</span></span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    print(<span class="string">"已打卡！"</span>)</span><br><span class="line">                    print(sub_time, status)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"未打卡！"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        mail_notice(<span class="string">"cookie已失效，请重新登录！"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h4 id="邮件提醒功能："><a href="#邮件提醒功能：" class="headerlink" title="邮件提醒功能："></a>邮件提醒功能：</h4><p>使用的是python的<code>email</code>模块，根据自定义的邮件提示内容向指定邮箱发送邮件，功能实现较为简单，直接看代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail_notice</span><span class="params">(mes)</span>:</span></span><br><span class="line">    <span class="comment"># 邮件提醒功能</span></span><br><span class="line">    from_addr = <span class="string">"********@qq.com"</span>  <span class="comment"># 替换发件人</span></span><br><span class="line">    to_addr = <span class="string">"********@qq.com"</span>  <span class="comment"># 替换收件人</span></span><br><span class="line">    password = <span class="string">"akyijm********jbi"</span>  <span class="comment"># 替换授权码</span></span><br><span class="line">    smtp_server = <span class="string">"smtp.qq.com"</span>  <span class="comment"># 发件人非QQ邮箱需要替换为对应的邮箱服务地址</span></span><br><span class="line"></span><br><span class="line">    subject = <span class="string">'LeetCode每日打卡提醒!'</span></span><br><span class="line">    msg = MIMEText(<span class="string">'&lt;HTML&gt;&lt;H1&gt;&#123;&#125;&lt;/hi&gt;&lt;/html&gt;'</span>.format(mes), <span class="string">'html'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'From'</span>] = Header(<span class="string">"未来"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'To'</span>] = Header(<span class="string">"现在"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line">    smtp = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>)</span><br><span class="line">    smtp.login(from_addr, password)</span><br><span class="line">    smtp.sendmail(from_addr, to_addr, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br></pre></td></tr></table></figure>

<h4 id="定时任务功能："><a href="#定时任务功能：" class="headerlink" title="定时任务功能："></a>定时任务功能：</h4><p>使用的是python的<code>schedule</code>模块，指定在每天的上午九点开始执行。另外每隔一个小时执行一次的实现直接采用的<code>time.sleep(60*60)</code>。代码也比较简单，直接看代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        flag = submission_check()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            mail_notice(<span class="string">"今天不要忘了打卡哦！"</span>)  <span class="comment"># 未打卡则发送邮件提醒</span></span><br><span class="line">            cur_hour = time.localtime().tm_hour</span><br><span class="line">            <span class="keyword">if</span> cur_hour == <span class="number">23</span>:   <span class="comment"># 时间超过23:00 今日不再提醒</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">60</span>*<span class="number">60</span>)  <span class="comment"># 一小时后再检查</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    schedule.every().day.at(<span class="string">"09:00"</span>).do(job)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        schedule.run_pending()</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、程序部署"><a href="#三、程序部署" class="headerlink" title="三、程序部署"></a>三、程序部署</h3><p>本来想将程序直接挂在自己电脑上一直运行的，但一直以来都想折腾一下服务器，然后就看了下阿里云，发现服务器正在做活动，价格还可以接受，就买了一个准备折腾一下。没有服务器的话，还是运行在自己电脑上吧。对于一台全新的服务器，部署过程如下：</p>
<ol>
<li><p>使用root用户登录（阿里云买了之后只有root用户，需要在控制台管理界面设置下root用户的密码才能登录）后，创建一个新用户，并赋予相应的权限。（也可以使用root用户配置，但不推荐）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd -m newuser  <span class="comment"># 创建用户,-m表示自动创建用户的登入目录</span></span><br><span class="line">sudo passwd newuser  <span class="comment"># 为新建的用户创建密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的用户加入sudo组sudo </span></span><br><span class="line">chmod +w /etc/sudoers  <span class="comment"># /etc/sudoers文件只有读权限，先赋予写权限</span></span><br><span class="line">sudo vim /etc/sudoers  </span><br><span class="line"><span class="comment"># 编辑此文件，在 root　ALL=(ALL:ALL) ALL行下面添加 newuser ALL=(ALL:ALL) ALL</span></span><br><span class="line">sudo chmod -w /etc/sudoers  <span class="comment"># 将/etc/sudoers文件的权限改为只读权限</span></span><br><span class="line"></span><br><span class="line">su newuser  <span class="comment"># 切换到新用户</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装环境依赖，主要包括<code>requests</code>以及<code>schedule</code>模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install requests schedule</span><br></pre></td></tr></table></figure>
</li>
<li><p>将程序文件拷贝到服务器合适位置，博主直接使用的<code>xftp</code>传输的，放在了用户目录下。</p>
</li>
<li><p>开通阿里云服务器的<code>465</code>端口</p>
<p>之所以在邮件提醒功能中使用的邮件服务端口是<code>465</code>端口，是因为阿里云服务器屏蔽了<code>25</code>端口，申请开通的步骤比较麻烦，需要域名等其他的要求，所以直接采用了<code>465</code>端口。基本配置需要两个步骤：</p>
<ul>
<li>配置安全组规则，将<code>465</code>端口加入入站规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200402182452.png" alt=""></p>
<ul>
<li>在服务器防火墙中打开<code>465</code>端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install iptables</span><br><span class="line">sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT  <span class="comment"># 将80替换</span></span><br><span class="line">sudo iptables-save  <span class="comment"># 临时保存配置，重启后失效</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install iptables-persistent  <span class="comment"># 安装 iptables-persistent工具，持久化开放端口配置</span></span><br><span class="line">sudo netfilter-persistent save</span><br><span class="line">sudo netfilter-persistent reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>在后台运行python程序</p>
<p>让python后台运行的方法有很多，这里采用了比较简单的一种。在终端运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 leetcode_check.py &gt;lc.log &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&gt;lc.log</code>：表示将标准输出存储在log文件中。</p>
</li>
<li><p><code>&amp;</code> ：表示后台运行。</p>
</li>
</ul>
</li>
<li><p>部署完毕，退出。</p>
</li>
</ol>
<hr>
<h3 id="四、最后："><a href="#四、最后：" class="headerlink" title="四、最后："></a>四、最后：</h3><p>此打卡提醒程序只是为了满足日常的一个小需求，程序代码以及部署方式都很简单，很多方面都没有考虑，以后有需要和时间再来慢慢完善吧。大家有什么建议也可以在下方留言。</p>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>爬虫</tag>
        <tag>脚本工具</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04服务器常用配置</title>
    <url>/2020/03/30/Ubuntu18-04%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd -m newuser  <span class="comment"># 创建用户,-m表示自动创建用户的登入目录</span></span><br><span class="line">sudo passwd newuser  <span class="comment"># 为新建的用户创建密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的用户加入sudo组</span></span><br><span class="line">sudo chmod +w /etc/sudoers  <span class="comment"># /etc/sudoers文件只有读权限，先赋予写权限</span></span><br><span class="line">sudo vim /etc/sudoers  </span><br><span class="line"><span class="comment"># 编辑此文件，在 root　ALL=(ALL:ALL) ALL行下面添加 newuser ALL=(ALL:ALL) ALL</span></span><br><span class="line">sudo chmod -w /etc/sudoers  <span class="comment"># 将/etc/sudoers文件的权限改为只读权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">sudo userdel newuser</span><br><span class="line">sudo rm -rf /home/newuser  <span class="comment"># 删除用户目录</span></span><br><span class="line"><span class="comment"># 接下来删除此用户相关的配置文件</span></span><br><span class="line">sudo vim /etc/sudoers  </span><br><span class="line">sudo vim /etc/passwd</span><br><span class="line">sudo vim /etc/group</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="后台运行单个Python程序"><a href="#后台运行单个Python程序" class="headerlink" title="后台运行单个Python程序"></a>后台运行单个Python程序</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python test.py &gt;test.log &amp;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成公钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul>
<li>开放某个端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install iptables</span><br><span class="line">sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT  <span class="comment"># 将80替换</span></span><br><span class="line">sudo iptables-save  <span class="comment"># 临时保存配置，重启后失效</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install iptables-persistent  <span class="comment"># 安装 iptables-persistent工具，持久化开放端口配置</span></span><br><span class="line">sudo netfilter-persistent save</span><br><span class="line">sudo netfilter-persistent reload</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础命令</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内置序列类型总结</title>
    <url>/2020/03/28/Python%E5%86%85%E7%BD%AE%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>Python 标准库用C实现了丰富的序列类型，这些类型大都支持迭代、排序、切片、拼接等操作。</p>
<h5 id="按照存储的内容可以分为："><a href="#按照存储的内容可以分为：" class="headerlink" title="按照存储的内容可以分为："></a>按照存储的内容可以分为：</h5><ul>
<li><p>容器序列：可以存放不同类型的数据</p>
<blockquote>
<p>list、tuple、collections.deque</p>
</blockquote>
</li>
<li><p>扁平序列：只能容纳一种类型</p>
<blockquote>
<p>str、bytes、bytearray、memoryview、array.array</p>
</blockquote>
</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。换句话说，扁平序列其实是一段连续的内存空间。</p>
<h5 id="按照能否被修改可以分为："><a href="#按照能否被修改可以分为：" class="headerlink" title="按照能否被修改可以分为："></a>按照能否被修改可以分为：</h5><ul>
<li><p>可变序列：序列内容可以被修改</p>
<blockquote>
<p>list、bytearray、array.array、collections.deque、memoryview</p>
</blockquote>
</li>
<li><p>不可变序列</p>
<blockquote>
<p>tuple、str、bytes</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a><a href="https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Lists.html" target="_blank" rel="noopener">列表list</a></h4><h5 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h5><ul>
<li>属于容器序列：可以存放不同类型的数据</li>
<li>属于可变序列：序列内容可以被修改</li>
</ul>
<h5 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h5><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>index[]</td>
<td>取值</td>
<td>O(1)</td>
</tr>
<tr>
<td>index assignment</td>
<td>赋值</td>
<td>O(1)</td>
</tr>
<tr>
<td>list.append(value)</td>
<td>Append object to the end of the list.</td>
<td>O(1)</td>
</tr>
<tr>
<td>list.clear()</td>
<td>Remove all items from list.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.copy()</td>
<td>Return a shallow copy of the list.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.count(value)</td>
<td>Return number of occurrences of value.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.extend()</td>
<td>Extend list by appending elements from the iterable.</td>
<td>O(k)</td>
</tr>
<tr>
<td>list.index(value,[start,[stop])</td>
<td>Return first index of value.<br />Raises ValueError if the value is not present.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.insert(index, value)</td>
<td>Insert object before index.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.pop()</td>
<td>Remove and return item at  last.</td>
<td>O(1)</td>
</tr>
<tr>
<td>list.pop(index)</td>
<td>Remove and return item at index (default last).</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.remove()</td>
<td>Remove first occurrence of value.<br />Raises ValueError if the value is not present.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.reverse()</td>
<td>Reverse <em>IN PLACE</em>.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.sort()</td>
<td>Stable sort <em>IN PLACE</em>.</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>len(list)</td>
<td>求列表长度</td>
<td>O(1)</td>
</tr>
<tr>
<td>get slice [x:y]</td>
<td>切片</td>
<td>O(k)</td>
</tr>
<tr>
<td>in 关键字</td>
<td>判断元素是否在列表中</td>
<td>O(n)</td>
</tr>
<tr>
<td>multiply</td>
<td>列表乘法</td>
<td>O(nk)</td>
</tr>
</tbody></table>
<ul>
<li>‘n’是容器中当前的元素数， ‘k’是需要操作的元素个数。</li>
</ul>
<h5 id="列表推导-list-comprehension，简称-listcomps"><a href="#列表推导-list-comprehension，简称-listcomps" class="headerlink" title="列表推导(list comprehension，简称: listcomps):"></a>列表推导(list comprehension，简称: listcomps):</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_a = <span class="string">"1234567890"</span></span><br><span class="line">list_a = []</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> str_a:</span><br><span class="line">    list_a.append(int(c))</span><br><span class="line">print(list_a)</span><br><span class="line"></span><br><span class="line">list_b = [int(c) <span class="keyword">for</span> c <span class="keyword">in</span> str_a]</span><br><span class="line">print(list_b)</span><br></pre></td></tr></table></figure>

<p>以上代码就是一个用<strong>列表推导</strong>代替<strong>for循环</strong>来新建列表的示例。</p>
<p>通常只使用<strong>列表推导</strong>来创建新的列表，并且使代码尽量简短。如果列表推导的代码超过了两行，就要考虑是不是要使用<strong>for循环</strong>进行重写。</p>
<ul>
<li>Python2中列表推导存在变量泄露问题，Python3中不存在。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line">c = <span class="string">"ABC"</span></span><br><span class="line">list_a = [c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"DEF"</span>]</span><br><span class="line">print(c)  <span class="comment"># F</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">c = <span class="string">"ABC"</span></span><br><span class="line">list_a = [c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"DEF"</span>]</span><br><span class="line">print(c)  <span class="comment"># ABC</span></span><br></pre></td></tr></table></figure>

<h5 id="列表推导的性能："><a href="#列表推导的性能：" class="headerlink" title="列表推导的性能："></a>列表推导的性能：</h5><p>列表推导可以实现的操作也有一些替代选择，这里比较一下他们的性能，具体见如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">TIMES = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">SETUP = <span class="string">"""</span></span><br><span class="line"><span class="string">symbols = '$¢£¥€¤'</span></span><br><span class="line"><span class="string">def non_ascii(c):</span></span><br><span class="line"><span class="string">    return c &gt; 127</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(label, cmd)</span>:</span></span><br><span class="line">    res = timeit.repeat(cmd, setup=SETUP, number=TIMES)</span><br><span class="line">    print(label, *(<span class="string">'&#123;:.3f&#125;'</span>.format(x) <span class="keyword">for</span> x <span class="keyword">in</span> res))</span><br><span class="line"></span><br><span class="line">clock(<span class="string">'listcomp        :'</span>, <span class="string">'[ord(s) for s in symbols if ord(s) &gt; 127]'</span>)</span><br><span class="line">clock(<span class="string">'listcomp + func :'</span>, <span class="string">'[ord(s) for s in symbols if non_ascii(ord(s))]'</span>)</span><br><span class="line">clock(<span class="string">'filter + lambda :'</span>, <span class="string">'list(filter(lambda c: c &gt; 127, map(ord, symbols)))'</span>)</span><br><span class="line">clock(<span class="string">'filter + func   :'</span>, <span class="string">'list(filter(non_ascii, map(ord, symbols)))'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># listcomp        : 0.016 0.015 0.015 0.014 0.015</span></span><br><span class="line"><span class="comment"># listcomp + func : 0.025 0.019 0.020 0.077 0.030</span></span><br><span class="line"><span class="comment"># filter + lambda : 0.022 0.022 0.019 0.020 0.023</span></span><br><span class="line"><span class="comment"># filter + func   : 0.017 0.018 0.024 0.020 0.020</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码出处为：<a href="https://github.com/fluentpython/example-code/blob/master/02-array-seq/listcomp_speed.py" target="_blank" rel="noopener">流畅的Python-listcomp_speed.py </a></p>
</blockquote>
<hr>
<h4 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a><a href="https://docs.python.org/3.5/library/stdtypes.html#tuple" target="_blank" rel="noopener">元组tuple</a></h4><h5 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h5><ul>
<li>属于容器序列：可以存放不同类型的数据</li>
<li>属于不可变序列：序列内容不可以被修改</li>
</ul>
<h5 id="内置函数：-1"><a href="#内置函数：-1" class="headerlink" title="内置函数："></a>内置函数：</h5><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>count()</td>
<td>Return number of occurrences of value.</td>
<td>O(n)</td>
</tr>
<tr>
<td>index(value,[start,[stop])</td>
<td>Return first index of value.<br />Raises ValueError if the value is not present.</td>
<td>O(n)</td>
</tr>
<tr>
<td>in 关键字</td>
<td>判断是否在元组中</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h5 id="元组与记录："><a href="#元组与记录：" class="headerlink" title="元组与记录："></a>元组与记录：</h5><p>元组其实是<strong>对数据的记录</strong>：<strong>元组中的每个元素都对应记录中一个字段的数据，外加这个字段的位置，</strong>正是这个位置信息给数据赋予了意义。</p>
<p>如果只是把元组理解为不可变的列表，那其他信息——它所含有的元素的总数和元素的位置——似乎就变得可有可无。但是如果把元组当做是一些字段的集合，那么数量和位置信息就变得非常重要的。</p>
<ul>
<li><strong>示例：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">city, year, pop, chg, area = (<span class="string">'Tokyo'</span>, <span class="number">2003</span>, <span class="number">32450</span>, <span class="number">0.66</span>, <span class="number">8014</span>)</span><br></pre></td></tr></table></figure>

<p>以上是东京市的一条数据记录，包含了市名、年份、人口、人口变化和面积五个字段的信息。 如何我们对元组内的数据排序，那这些元素所携带的信息就会丢失。</p>
<p><strong>拆包</strong>让元组可以完美地被当作记录来使用。</p>
<h5 id="元组拆包："><a href="#元组拆包：" class="headerlink" title="元组拆包："></a>元组拆包：</h5><p>元组拆包可以应用到任何可迭代对象上。有如下几种应用方式：</p>
<ul>
<li>平行赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lax_coordinates = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line">latitude, longitude = lax_coordinates <span class="comment"># 元组拆包</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不使用中间变量交换两个变量的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>*</code>运算符把一个可迭代对象拆开作为函数的参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">divmod(<span class="number">20</span>, <span class="number">8</span>)  <span class="comment"># (2, 4)</span></span><br><span class="line">t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">divmod(*t)  <span class="comment"># (2, 4)</span></span><br><span class="line">quotient, remainder = divmod(*t)  <span class="comment"># 2, 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>*</code>处理剩下的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, *rest = range(<span class="number">5</span>)  <span class="comment"># 0, 1, [2, 3, 4]</span></span><br><span class="line">a, b, *rest = range(<span class="number">3</span>)  <span class="comment"># 0, 1, [2]</span></span><br><span class="line">a, b, *rest = range(<span class="number">2</span>)  <span class="comment"># 0, 1, []</span></span><br><span class="line"><span class="comment"># *前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置</span></span><br><span class="line">a, *body, c, d = range(<span class="number">5</span>)  <span class="comment"># 0, [1, 2], 3, 4</span></span><br><span class="line">*head, b, c, d = range(<span class="number">5</span>)  <span class="comment"># [0, 1], 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<h5 id="嵌套元组拆包："><a href="#嵌套元组拆包：" class="headerlink" title="嵌套元组拆包："></a>嵌套元组拆包：</h5><p>接受表达式的元组可以是嵌套式的，例如(a, b, (c, d))。需要接受元组的嵌套结构符合表达式本身的嵌套结构。</p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">'Mexico City'</span>, <span class="string">'MX'</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">    (<span class="string">'New York-Newark'</span>, <span class="string">'US'</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">'Sao Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line">print(<span class="string">'&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;'</span>.format(<span class="string">''</span>, <span class="string">'lat.'</span>, <span class="string">'long.'</span>))</span><br><span class="line">fmt = <span class="string">'&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;'</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:</span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:</span><br><span class="line">        print(fmt.format(name, latitude, longitude))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#                 |   lat.    |   long.  </span></span><br><span class="line"><span class="comment"># Mexico City     |   19.4333 |  -99.1333</span></span><br><span class="line"><span class="comment"># New York-Newark |   40.8086 |  -74.0204</span></span><br><span class="line"><span class="comment"># Sao Paulo       |  -23.5478 |  -46.6358</span></span><br></pre></td></tr></table></figure>

<h5 id="具名元组："><a href="#具名元组：" class="headerlink" title="具名元组："></a>具名元组：</h5><p><code>collections.namedtuple</code>模块可以用来构建一个带字段名的元组和一个有名字的类。</p>
<p>使用<code>namedtuple</code>构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些，因为Python不会用<code>__dict__</code>来存放这些实例的属性。</p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="comment"># 创建具名元组</span></span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, <span class="string">'name country population coordinates'</span>) </span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">tokyo = City(<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br><span class="line">print(tokyo)</span><br><span class="line">print(tokyo.population)</span><br><span class="line">print(tokyo.coordinates)</span><br><span class="line">print(tokyo[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))</span></span><br><span class="line"><span class="comment"># 36.933</span></span><br><span class="line"><span class="comment"># (35.689722, 139.691667)</span></span><br><span class="line"><span class="comment"># JP</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建一个具名元组需要两个参数：类名和类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格所分隔开的字段名组成的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上述示例中的创建具名元组等价于下面这种方式</span></span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, [<span class="string">"name"</span>, <span class="string">"country"</span>, <span class="string">"population"</span>, <span class="string">"coordinates"</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>存放在对应字段里的数据要以一串参数的形式传入到构造函数参数中。需要注意的是，构造函数可接受的参数形式单一，只接受可迭代对象。</p>
</li>
<li><p>可以通过字段名或位置来获取一个字段的位置。</p>
</li>
</ul>
<p>具名元组继承自普通元组，除普通元组的属性外，还有自己专有的属性，比如<strong>_fields类属性</strong>、<strong>类方法_make(iterable)</strong>和<strong>实例方法_asdict()</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(City._fields)</span><br><span class="line">LatLong = namedtuple(<span class="string">'LatLong'</span>, <span class="string">'lat long'</span>)</span><br><span class="line">delhi_data = (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line">delhi = City._make(delhi_data)</span><br><span class="line">print(delhi._asdict())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> delhi._asdict().items():</span><br><span class="line">    print(key + <span class="string">':'</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('name', 'country', 'population', 'coordinates')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name: Delhi NCR</span></span><br><span class="line"><span class="comment"># country: IN</span></span><br><span class="line"><span class="comment"># population: 21.935</span></span><br><span class="line"><span class="comment"># coordinates: LatLong(lat=28.613889, long=77.208889)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>_fields</strong>属性是一个包含这个类所有字段名称的元组</p>
</li>
<li><p>用<strong>_make()</strong>接收一个可迭代对象来生成这个类的一个实例，等价于如下写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">City(*delhi_data)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>_asdict()</strong> 把具名元组以<code>collections.OrderedDict</code>的形式返回。</p>
</li>
</ul>
<hr>
<h4 id="数组array-array"><a href="#数组array-array" class="headerlink" title="数组array.array"></a><a href="https://docs.python.org/3.5/library/array.html#module-array" target="_blank" rel="noopener">数组array.array</a></h4><h5 id="特性：-2"><a href="#特性：-2" class="headerlink" title="特性："></a>特性：</h5><ul>
<li>扁平序列：只能容纳一种类型的数据</li>
<li>可变序列：序列内容可以被修改</li>
</ul>
<p>如果我们需要一个只包含数字的列表，那么array.array比list会更高效。数组支持所有跟可变序列有关的操作。另外，还提供了从文件读取和存入文件的更快的方法。</p>
<h5 id="内置函数：-2"><a href="#内置函数：-2" class="headerlink" title="内置函数："></a>内置函数：</h5><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>append a new item to the end of the array</td>
<td></td>
</tr>
<tr>
<td>buffer_info()</td>
<td>Return a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array’s contents.<br />The length should be multiplied by the itemsize attribute to calculatethe buffer length in bytes.</td>
<td></td>
</tr>
<tr>
<td>byteswap()</td>
<td>Byteswap all items of the array.<br />If the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError israised.</td>
<td></td>
</tr>
<tr>
<td>count()</td>
<td>Return number of occurrences of v in the array.</td>
<td></td>
</tr>
<tr>
<td>extend()</td>
<td>Append items to the end of the array.</td>
<td></td>
</tr>
<tr>
<td>fromfile()</td>
<td>Read n objects from the file object f and append them to the end of the array.</td>
<td></td>
</tr>
<tr>
<td>fromlist()</td>
<td>Append items to array from list.</td>
<td></td>
</tr>
<tr>
<td>frombytes()</td>
<td>Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method).</td>
<td></td>
</tr>
<tr>
<td>fromunicode()</td>
<td>Extends this array with data from the unicode string ustr.<br />The array must be a unicode type array; otherwise a ValueError is raised.<br />Use array.frombytes(ustr.encode(…)) to append Unicode data to an array ofsome other type.</td>
<td></td>
</tr>
<tr>
<td>index()</td>
<td>Return index of first occurrence of v in the array.</td>
<td></td>
</tr>
<tr>
<td>insert()</td>
<td>Insert a new item v into the array before position i.</td>
<td></td>
</tr>
<tr>
<td>pop()</td>
<td>Return the i-th element and delete it from the array.<br />i defaults to -1.</td>
<td></td>
</tr>
<tr>
<td>remove()</td>
<td>Remove the first occurrence of v in the array.</td>
<td></td>
</tr>
<tr>
<td>reverse()</td>
<td>Reverse the order of the items in the array.</td>
<td></td>
</tr>
<tr>
<td>tofile()</td>
<td>Write all items (as machine values) to the file object f.</td>
<td></td>
</tr>
<tr>
<td>tolist()</td>
<td>Convert array to an ordinary list with the same items.</td>
<td></td>
</tr>
<tr>
<td>tobytes()</td>
<td>Convert the array to an array of machine values and return the bytes representation.</td>
<td></td>
</tr>
<tr>
<td>tounicode()</td>
<td>Extends this array with data from the unicode string ustr.<br />Convert the array to a unicode string.  The array must be a unicode type array;otherwise a ValueError is raised.  <br />Use array.tobytes().decode() to obtain aunicode string from an array of some other type.</td>
<td></td>
</tr>
</tbody></table>
<h5 id="类属性：typecode-amp-itemsize"><a href="#类属性：typecode-amp-itemsize" class="headerlink" title="类属性：typecode&amp;itemsize"></a>类属性：typecode&amp;itemsize</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">a = array(<span class="string">'i'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(a.itemsize)</span><br><span class="line">print(a.typecode)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># i</span></span><br><span class="line"><span class="comment"># array('i', [1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>

<p>创建数组需要指定<strong>类型码</strong>以及一个<strong>可迭代对象</strong>，两者可以分别通过内置的类属性<code>typecode</code>以及<code>itemsize</code>来查看。</p>
<ul>
<li>类型码用来表示在底层的C语言应该存放怎样的数据类型，有以下种类：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Type code</th>
<th align="left">C Type</th>
<th align="left">Python Type</th>
<th align="left">Minimum size in bytes</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&#39;b&#39;</code></td>
<td align="left">signed char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;B&#39;</code></td>
<td align="left">unsigned char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;u&#39;</code></td>
<td align="left">Py_UNICODE</td>
<td align="left">Unicode character</td>
<td align="left">2</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>&#39;h&#39;</code></td>
<td align="left">signed short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;H&#39;</code></td>
<td align="left">unsigned short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;i&#39;</code></td>
<td align="left">signed int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;I&#39;</code></td>
<td align="left">unsigned int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;l&#39;</code></td>
<td align="left">signed long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;L&#39;</code></td>
<td align="left">unsigned long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;q&#39;</code></td>
<td align="left">signed long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>&#39;Q&#39;</code></td>
<td align="left">unsigned long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>&#39;f&#39;</code></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;d&#39;</code></td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Notes:</p>
<ol>
<li><p>The <code>&#39;u&#39;</code> type code corresponds to Python’s obsolete unicode character (<a href="https://docs.python.org/3.5/c-api/unicode.html#c.Py_UNICODE" target="_blank" rel="noopener"><code>Py_UNICODE</code></a> which is <code>wchar_t</code>). Depending on the platform, it can be 16 bits or 32 bits.</p>
<p><code>&#39;u&#39;</code> will be removed together with the rest of the <a href="https://docs.python.org/3.5/c-api/unicode.html#c.Py_UNICODE" target="_blank" rel="noopener"><code>Py_UNICODE</code></a> API.</p>
<p><em>Deprecated since version 3.3, will be removed in version 4.0.</em> </p>
</li>
<li><p>The <code>&#39;q&#39;</code> and <code>&#39;Q&#39;</code> type codes are available only if the platform C compiler used to build Python supports C <code>long long</code>, or, on Windows, <code>__int64</code>.</p>
</li>
</ol>
<hr>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h5 id="序列的增量赋值："><a href="#序列的增量赋值：" class="headerlink" title="序列的增量赋值："></a>序列的增量赋值：</h5><p>增量赋值运算符 <code>+=</code>和<code>*=</code>的表现取决于它们的第一个操作对象。</p>
<p>考虑表达式<code>a += b</code>，<code>+=</code>背后的特殊方法是<code>__iadd__</code>(用于“就地加法”)，对于可变序列来说，a就会就地改动，就像调用了<code>a.extend(b)</code>这样。如果一个类没有实现这个方法的话，Python会退一步调用<code>__add__</code>，这样<code>a += b</code>的效果就变得跟<code>a = a + b</code>一样了：首先计算<code>a + b</code>，得到一个新的对象，然后赋值给a。</p>
<p>总体来讲，可变序列一般都实现了<code>__iadd__</code>方法，因而<code>+=</code>是就地加法。而不可变序列根本就不支持这个操作，对这个方法的实现也就无从谈起了。</p>
<p>上面所说的这些关于<code>+=</code>的概念也适用于<code>*=</code>，不同的是，后者对应的是<code>__imul__</code>。</p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(id(a))  <span class="comment"># 2862020911752</span></span><br><span class="line">a += [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(id(a))  <span class="comment"># 2862020911752</span></span><br><span class="line">a *= <span class="number">2</span></span><br><span class="line">print(id(a))  <span class="comment"># 2862020911752</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 2862021748992</span></span><br><span class="line">print(id(b))</span><br><span class="line">b += (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(id(b))  <span class="comment"># 2862020978208</span></span><br><span class="line">b *= <span class="number">2</span></span><br><span class="line">print(id(b))  <span class="comment"># 2862020594632</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array</span></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">c = array(<span class="string">'i'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">d = array(<span class="string">'i'</span>, [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">print(id(c))  <span class="comment"># 2862021863536</span></span><br><span class="line">c += d</span><br><span class="line">print(id(c))  <span class="comment"># 2862021863536</span></span><br><span class="line">c *= <span class="number">2</span></span><br><span class="line">print(id(c))  <span class="comment"># 2862021863536</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str</span></span><br><span class="line">a = <span class="string">"123"</span></span><br><span class="line">print(id(a))  <span class="comment"># 2316514911712</span></span><br><span class="line">a += <span class="string">"456"</span></span><br><span class="line">print(id(a))  <span class="comment"># 2316515702128</span></span><br><span class="line">a *= <span class="number">2</span></span><br><span class="line">print(id(a))  <span class="comment"># 2316516515952</span></span><br></pre></td></tr></table></figure>

<p>对于不可变序列进行重复拼接操作的话，效率会很低，因为每次都要建立一个新对象，而解释器需要把原来对象的元素先复制到新的对象里，然后再追加新的元素。</p>
<h5 id="改变不可变元组中的列表："><a href="#改变不可变元组中的列表：" class="headerlink" title="改变不可变元组中的列表："></a>改变不可变元组中的列表：</h5><ul>
<li>看下面一段代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>] += [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>a的类型为不可变类型tuple，其中第二个元素为可变类型list，可以看到我们在修改a[2]这个元素时，运行报错，但a还是被修改成功。</p>
<ul>
<li>让我们先来看一下代码运行前后a的状态</li>
</ul>
<ol>
<li><code>a = (1, 2, [3, 4])</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200329174757.png" alt=""></p>
<ol start="2">
<li><code>a[2] += [4, 5]</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200329174949.png" alt=""></p>
<p>可以发现a[2]存储的并不是列表[3, 4]的值，而是列表的引用。</p>
<blockquote>
<p><a href="http://www.pythontutor.com" target="_blank" rel="noopener">Python Tutor</a> 是一个对 Python 运行原理进行可视化分析的工具。  </p>
</blockquote>
<ul>
<li><p>接下来看一下Python 表达式<code>s[a] += b</code>生成的字节码：</p>
<p>为简化分析，我们将前面的示例代码改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a[<span class="number">2</span>] += b</span><br></pre></td></tr></table></figure>

<p>利用python的<a href="https://docs.python.org/3/library/dis.html" target="_blank" rel="noopener">dis模块</a>查看<code>a[2]+=b</code>的执行字节码：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a[2]+=b'</span>)</span><br><span class="line">    <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (a)  </span><br><span class="line">                <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line">                <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">                <span class="number">6</span> BINARY_SUBSCR                    <span class="comment"># node 1</span></span><br><span class="line">                <span class="number">8</span> LOAD_NAME                <span class="number">1</span> (b)</span><br><span class="line">               <span class="number">10</span> INPLACE_ADD                      <span class="comment"># node 2</span></span><br><span class="line">               <span class="number">12</span> ROT_THREE</span><br><span class="line">               <span class="number">14</span> STORE_SUBSCR                     <span class="comment"># node 3</span></span><br><span class="line">               <span class="number">16</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">               <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>node 1：</strong>将a[2]的值存入TOS(Top Of Stack，栈的顶端)</li>
<li><strong>node 2：</strong>计算TOS + b。这一步能够完成，是因为TOS指向的是一个可变对象。</li>
<li><strong>node3：</strong>a[2] = TOS赋值。这一步会失败。因为a是不可变的元组tuple。</li>
</ul>
</li>
</ul>
<p>由以上分析，我们可以发现：<strong>增量赋值</strong>操作不是原子操作。前面示例可以看到，代码抛出了异常，但还是完成了操作。</p>
<hr>
<blockquote>
<p>本篇博客内容大部分总结自《流畅的Python》一书，文中有什么写的不清楚的，读者可以阅读《流畅的Python》自己分析一下。</p>
<p>另外，文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>内置序列类型</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内置模块bisect</title>
    <url>/2020/03/25/Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97bisect/</url>
    <content><![CDATA[<h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p><code>bisect</code>模块是Python内置的一个功能模块，这个模块的功能是在对列表<code>list</code>进行插入操作时，维护列表保持有序的状态。使用<code>bisect</code>模块中的方法时需要满足一个条件，即<strong>执行插入操作的列表<code>list</code>本身需要是有序的。</strong></p>
<hr>
<h4 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h4><p><code>bisect</code> 模块包含如下四个主要函数，这四个函数都利用二分查找算法来在有序列表中查找或者插入元素。</p>
<h5 id="1-bisect-a-x-lo-0-hi-None"><a href="#1-bisect-a-x-lo-0-hi-None" class="headerlink" title="1. bisect(a, x, lo=0, hi=None):"></a>1. bisect(a, x, lo=0, hi=None):</h5><ul>
<li><p>此函数其实是<code>bisect_right()</code>的别名，函数的作用是返回元素x在列表a中的插入位置，a需要是有序的。</p>
</li>
<li><p>如果存在与x相等的元素，返回的结果是最后x出现位置的下一位。</p>
</li>
<li><p>参数lo和hi指定了查找范围。</p>
</li>
<li><p>源码：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<h5 id="2-insort-a-x-lo-0-hi-None-："><a href="#2-insort-a-x-lo-0-hi-None-：" class="headerlink" title="2. insort(a, x, lo=0, hi=None)："></a>2. insort(a, x, lo=0, hi=None)：</h5><ul>
<li>此函数其实是<code>insort_right()</code>的别名，函数的作用是在列表a中插入元素x，并保持列表a有序。</li>
<li>如果存在与x相等的元素，则插入在最后一个x的右侧。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br></pre></td></tr></table></figure>

<h5 id="3-bisect-left-a-x-lo-0-hi-None"><a href="#3-bisect-left-a-x-lo-0-hi-None" class="headerlink" title="3. bisect_left(a, x, lo=0, hi=None):"></a>3. bisect_left(a, x, lo=0, hi=None):</h5><ul>
<li>函数作用同样是返回元素x在列表a中的插入位置。</li>
<li>但如果存在与x相等的元素，返回的结果是第一个x出现位置。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<h5 id="4-insort-left-a-x-lo-0-hi-None"><a href="#4-insort-left-a-x-lo-0-hi-None" class="headerlink" title="4. insort_left(a, x, lo=0, hi=None):"></a>4. insort_left(a, x, lo=0, hi=None):</h5><ul>
<li>函数的作用同样是在列表a中插入元素x，并保持列表a有序。</li>
<li>但如果存在与x相等的元素，则插入在第一个x的左侧。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="与list内置index-性能的比较："><a href="#与list内置index-性能的比较：" class="headerlink" title="与list内置index()性能的比较："></a>与<code>list</code>内置<code>index()</code>性能的比较：</h4><p>由<code>bisect</code>的源码可以看出，<code>bisect</code>模块内的函数使用<strong>二分查找</strong>的方式来加快<strong>寻找元素插入位置</strong>。对于<strong>插入元素，并保持列表有序</strong> 这样的操作要求我们可以结合<code>list</code>内置的<code>index()</code>函数与<code>insert()</code>函数来实现相同的效果。但由于<code>index()</code>函数是采用顺序查找的方式，故<code>bisect</code>模块的效率应高于<code>list</code>内置的<code>index()</code>函数。</p>
<h5 id="1-list-内置index-函数源码："><a href="#1-list-内置index-函数源码：" class="headerlink" title="1.  list 内置index()函数源码："></a>1.  <code>list</code> 内置<code>index()</code>函数源码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*[clinic input]</span></span><br><span class="line"><span class="comment">list.index</span></span><br><span class="line"><span class="comment">    value: object</span></span><br><span class="line"><span class="comment">    start: slice_index(accept=&#123;int&#125;) = 0</span></span><br><span class="line"><span class="comment">    stop: slice_index(accept=&#123;int&#125;, c_default="PY_SSIZE_T_MAX") = sys.maxsize</span></span><br><span class="line"><span class="comment">    /</span></span><br><span class="line"><span class="comment">Return first index of value.</span></span><br><span class="line"><span class="comment">Raises ValueError if the value is not present.</span></span><br><span class="line"><span class="comment">[clinic start generated code]*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">list_index_impl(PyListObject *self, PyObject *value, Py_ssize_t start,</span><br><span class="line">                Py_ssize_t <span class="built_in">stop</span>)</span><br><span class="line"><span class="comment">/*[clinic end generated code: output=ec51b88787e4e481 input=40ec5826303a0eb1]*/</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stop</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stop</span> += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stop</span> &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; <span class="built_in">stop</span> &amp;&amp; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="keyword">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> PyLong_FromSsize_t(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_Format(PyExc_ValueError, <span class="string">"%R is not in list"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出<code>index()</code>函数是从<code>start</code>到<code>stop</code>顺序遍历的。</li>
</ul>
<h5 id="2-效率比较"><a href="#2-效率比较" class="headerlink" title="2. 效率比较"></a>2. 效率比较</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">list_ = list(range(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    list_.index(i)  <span class="comment"># 查找list中的每一个元素</span></span><br><span class="line">print(time.time() - start)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    bisect.bisect(list_, i)  <span class="comment"># 查找list中的每一个元素</span></span><br><span class="line">print(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 1.013824462890625</span></span><br><span class="line"><span class="comment"># 0.007440805435180664</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>bisect</code>模块的功能和实现都较为简单，通过调用此模块可以来让我们的代码更简洁。当然了，我们也可以自己实现二分查找的过程。</p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python内置模块</tag>
        <tag>Python</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 多表插入操作 insert all/first子句</title>
    <url>/2020/03/20/Oracle-insert-all-first%E5%AD%90%E5%8F%A5/</url>
    <content><![CDATA[<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>在Oracle 中如果需要将一个子查询得到的数据进行多表插入操作的话，可以使用insert all/first 子句进行操作，相比使用多次单表插入效率会更高，因为主表只访问了一次。</p>
<hr>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/INSERT.html#GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank" rel="noopener">多表插入操作</a> 可以分为<strong>有条件</strong>插入和<strong>无条件</strong>插入两种：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200320210500.png"  />

<ul>
<li><p>执行<strong>有条件插入</strong>时，可以选择<strong>insert all/first</strong>子句来执行不同的插入策略。</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200320211224.png" style="zoom:80%;" />

<ul>
<li>一条多表插入操作的SQL语句最多支持<strong>127</strong>个<strong>when</strong>子句。</li>
</ul>
<p>两者的区别在于：</p>
<ul>
<li>insert all: 会对每个when条件进行匹配，如果满足则插入</li>
<li>insert first: 数据库会将数据依次对when条件进行匹配，遇到满足条件的when条件就进行插入，并且跳过之后的when条件的判断。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/insert all-first.png" style="zoom:80%;" />

<hr>
<h4 id="简单示例："><a href="#简单示例：" class="headerlink" title="简单示例："></a>简单示例：</h4><h5 id="1-数据准备："><a href="#1-数据准备：" class="headerlink" title="1. 数据准备："></a>1. 数据准备：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_a(a <span class="built_in">number</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_b <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_c <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-insert-all"><a href="#2-insert-all" class="headerlink" title="2.  insert all"></a>2.  insert all</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert all</span><br><span class="line">	when a &lt;&#x3D; 2 then into table_b</span><br><span class="line">	when a &lt;&#x3D; 5 then into table_c</span><br><span class="line">select * from table_a;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：</p>
<table>
<thead>
<tr>
<th>表</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>table_a</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
<tr>
<td>table_b</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>table_c</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
</tbody></table>
<blockquote>
<p>数据1和2同时满足两个when条件，两个表都进行了插入。</p>
</blockquote>
</li>
</ul>
<h5 id="3-insert-first"><a href="#3-insert-first" class="headerlink" title="3. insert first"></a>3. insert first</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">first</span></span><br><span class="line">	<span class="keyword">when</span> a &lt;= <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">into</span> table_b</span><br><span class="line">	<span class="keyword">when</span> a &lt;= <span class="number">5</span> <span class="keyword">then</span> <span class="keyword">into</span> table_c</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：</p>
<table>
<thead>
<tr>
<th>表</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>table_a</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
<tr>
<td>table_b</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>table_c</td>
<td>[3, 4, 5]</td>
</tr>
</tbody></table>
<blockquote>
<p>数据1和2同时满足两个when条件，但插入了第一个表后就跳过了第二个when条件的检查。</p>
</blockquote>
</li>
</ul>
<p>推荐使用Oracle 的<a href="https://livesql.oracle.com/apex/f?p=590:1:1114621173697::NO:RP::" target="_blank" rel="noopener">Live SQL</a>动手测试一下。</p>
<p>更多的示例可以参考Oracle官方文档 <a href="https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/INSERT.html#GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank" rel="noopener"><strong>Multitable Inserts: Examples</strong></a></p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中sort()/sorted()自定义排序规则</title>
    <url>/2020/03/17/Python%E4%B8%ADsort-sorted%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h4 id="问题：面试题45-把数组排成最小的数——《剑指Offer》"><a href="#问题：面试题45-把数组排成最小的数——《剑指Offer》" class="headerlink" title="问题：面试题45. 把数组排成最小的数——《剑指Offer》"></a>问题：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">面试题45. 把数组排成最小的数——《剑指Offer》</a></h4><p>先来看这样一道算法题：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200317161920.png" alt=""></p>
<p>解题思路：</p>
<ul>
<li>找到一个排序规则，数组根据这个规则排序后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就是给出两个数字<code>m</code>和<code>n</code>,我们需要确定一个规则来判断<code>m</code>和<code>n</code>哪个应该排在前面，而不是仅仅比较这两个数字的值的大小。</li>
</ul>
<p>排序规则设计：</p>
<ul>
<li>根据题目的要求，两个数字<code>m</code>和<code>n</code>能拼接成数字<code>mn</code>和<code>nm</code>。如果<code>mn</code>&lt;<code>nm</code>，那么我们应该打印<code>mn</code>，也就是<code>m</code>应该排在<code>n</code>的前面，此时我们定义<code>m</code>小于<code>n</code>；反之，如果<code>mn</code>&gt;<code>nm</code>，我们定义<code>m</code>大于<code>n</code>。</li>
</ul>
<hr>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><ul>
<li><p>基于以上排序规则，我们可以实现如下的排序函数：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="comment"># 将数组元素转换为str,是为了处理大数问题</span></span><br><span class="line">    str1 = m + n</span><br><span class="line">    str2 = n + m</span><br><span class="line">    <span class="keyword">if</span> str1 &lt; str2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> str1 &gt; str2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自定义的排序规则函数进行排序</p>
<p><code>nums</code>的排序可以使用<code>sort()</code>或者<code>sorted()</code>，但要注意的是：在Python3版本中，<code>sort()</code>以及<code>sorted()</code>都舍弃了<code>cmp</code>参数，引进了新的<code>key</code>参数，</p>
<ul>
<li><p><strong>cmp:</strong> 接受两个参数<code>a</code>和<code>b</code>，然后根据它们的大小关系返回不同的值：<code>a &lt; b</code>时返回负值，<code>a &gt; b</code>时返回正值，<code>a = b</code>时返回0。</p>
</li>
<li><p><strong>key:</strong> 接收一个参数，返回一个可比较对象。新的<code>key</code>函数这种模式并不直接比较任意两个原始元素，而是通过<code>key</code>函数把那些元素转换成一个个新的可比较对象，也就是元素的key，然后用元素的key代替元素去参与比较。</p>
</li>
</ul>
</li>
<li><p>如果我们习惯了Python2中<code>cmp</code>参数格式的写法，可以使用<a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" target="_blank" rel="noopener">functools.cmp_to_key()</a>函数进行转换，它相当于旧接口和新接口的转换器。完整代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            str1 = a + b</span><br><span class="line">            str2 = b + a</span><br><span class="line">            <span class="keyword">if</span> str1 &lt; str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> str1 &gt; str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=functools.cmp_to_key(compare)))</span><br></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>其实很巧妙，Python对象的比较过程可以用<code>__lt__</code>等函数重写，<code>cmp_to_key</code>的返回值也是一个重写了比较过程的对象，在调用自定义比较过程时会调用输入的比较函数，从而实现了设计目标。以下是<code>cmp_to_key()</code>的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_to_key</span><span class="params">(mycmp)</span>:</span></span><br><span class="line">    <span class="string">"""Convert a cmp= function into a key= function"""</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">K</span><span class="params">(object)</span>:</span></span><br><span class="line">        __slots__ = [<span class="string">'obj'</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">            self.obj = obj</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) == <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) != <span class="number">0</span></span><br><span class="line">        __hash__ = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>cmp_to_key()</code>函数返回的是一个类对象，在这里重载了进行元素比较的各个函数。</p>
<hr>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h4><ul>
<li><p>如果我们不想使用<code>cmp_to_key()</code>函数进行转换，我们也可以自己实现一个这样的类对象，只需重载其中的<code>__lt__</code>函数即可，完整代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Compare</span><span class="params">(str)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> self + s &lt; s + self</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=Compare))</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>cmp_to_key()</code>这种形式时，还可以利用<code>lambda</code>表达式来代替自定义排序规则函数，达到简化代码的效果，等效代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">import</span> functools</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=functools.cmp_to_key(<span class="keyword">lambda</span> x, y: int(x+y)-int(y+x))))</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较：</p>
<blockquote>
<p>This(key) is easier to use and faster to run. When using the cmp parameter, the sorting compares pairs of values, so the compare-function is called multiple times for every item. The larger the set of data, the more times the compare-function is called per item. With the key function the sorting instead keeps the key value for each item and compares those, so the key function is only called once for every item. This results in much faster sorts for large sets of data.</p>
<p>查看 <a href="http://python3porting.com/preparing.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p><strong>1. sort()与sorted()基础知识</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>sort()</th>
<th>sorted()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">调用方式</td>
<td><code>list1.sort()</code></td>
<td><code>sort(list1)</code></td>
</tr>
<tr>
<td align="center">返回值</td>
<td>自身被排序，没有返回值</td>
<td>返回一个新的排序好的list</td>
</tr>
<tr>
<td align="center">适用性</td>
<td>只适用于list</td>
<td>适用于所有可迭代序列</td>
</tr>
</tbody></table>
<ul>
<li>都有一个<code>reverse</code> 参数，指定升序或降序，默认为<code>False</code>(升序)</li>
<li>都有一个<code>key</code> 参数，此参数为一个只有一个参数的函数，这个函数会应用在序列里的每个元素, 所产生的结果将是排序算法依赖的对比关键字。默认值为恒等函数，即默认用元素自己的值来排序。</li>
<li>两个函数都是稳定的，即具有相同顺序的元素排序后还是原来的顺序。</li>
</ul>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中queue模块及常用方法</title>
    <url>/2020/03/07/Python%E4%B8%ADqueue%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Python中的<code>queue</code>模块对应数据结构中<code>队列</code>的概念，实现了一些基本的队列操作。</p>
</blockquote>
<h4 id="一、queue-Queue-maxsize-0"><a href="#一、queue-Queue-maxsize-0" class="headerlink" title="一、queue.Queue(maxsize=0)"></a>一、queue.Queue(maxsize=0)</h4><ul>
<li><p>普通<code>FIFO</code>队列</p>
<p>  初始化时指定 <code>maxsize</code>参数可设定队列的最大容量， 若<code>maxsize &lt;= 0</code>，则队列容量无限。</p>
<p>  常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td>如果队列为空，返回True</td>
<td></td>
</tr>
<tr>
<td>full()</td>
<td>如果队满，返回True</td>
<td></td>
</tr>
<tr>
<td>put()</td>
<td>向队列添加元素</td>
<td></td>
</tr>
<tr>
<td>get()</td>
<td>从队列取元素，并从队列删除该元素</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="二、queue-deque"><a href="#二、queue-deque" class="headerlink" title="二、queue.deque()"></a>二、queue.deque()</h4><ul>
<li><p>双端队列</p>
<p>  其实是<code>collections.deque</code>模块。<code>deque()</code> 的设计是为了在两端实现高效的插入和删除操作。</p>
<p>  常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>在队列右侧添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>appendleft()</td>
<td>在队列左侧添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>clear()</td>
<td>删除所有元素</td>
<td>O(n)</td>
</tr>
<tr>
<td>copy()</td>
<td>浅拷贝</td>
<td>O(n)</td>
</tr>
<tr>
<td>count(value)</td>
<td>统计Value出现的次数</td>
<td>O(n)</td>
</tr>
<tr>
<td>extend(value)</td>
<td>Extend the right side of the deque with elements from the iterable</td>
<td>O(k)</td>
</tr>
<tr>
<td>extendleft</td>
<td>Extend the left side of the deque with elements from the iterable</td>
<td>O(k)</td>
</tr>
<tr>
<td>index(value)</td>
<td>返回value的第一个位置的索引</td>
<td>O(n)</td>
</tr>
<tr>
<td>insert(index, value)</td>
<td>在指定位置插入元素</td>
<td>O(n)</td>
</tr>
<tr>
<td>pop()</td>
<td>Remove and return the rightmost element</td>
<td>O(1)</td>
</tr>
<tr>
<td>popleft()</td>
<td>Remove and return the leftmost element</td>
<td>O(1)</td>
</tr>
<tr>
<td>remove(value)</td>
<td>remove first occurrence of value</td>
<td>O(n)</td>
</tr>
<tr>
<td>reverse()</td>
<td>reverse IN PLACE</td>
<td>O(n)</td>
</tr>
<tr>
<td>rotate()</td>
<td>Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left</td>
<td>O(k)</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="三、与list的对比"><a href="#三、与list的对比" class="headerlink" title="三、与list的对比"></a>三、与list的对比</h4><p>我们有时为了方便会使用<code>list</code>这一数据类型来模拟队列的实现，但在某些功能实现的效率上会有所不同。比如：</p>
<ol>
<li><p>从队列中弹出队首元素</p>
<ul>
<li><p><code>list</code>:<br> 实现方式：<code>pop(0)</code> </p>
<ul>
<li><p><code>deque</code>：<br>实现方式：<code>popleft()</code></p>
</li>
<li><p><code>Queue</code>：<br>实现方式：<code>get()</code></p>
</li>
<li><p>以下是三种方法的时间复杂度比较：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>pop(0)</td>
<td>O(n)</td>
</tr>
<tr>
<td>popleft()</td>
<td>O(1)</td>
</tr>
<tr>
<td>get()</td>
<td>O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p><code>list</code> 中pop()函数不加参数时间复杂度为O(1)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python内置模块</tag>
        <tag>Python</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3使用‘*’初始化list的陷阱</title>
    <url>/2020/03/06/Python%E4%BD%BF%E7%94%A8%E2%80%98%E2%80%BB%E2%80%99%E5%88%9D%E5%A7%8B%E5%8C%96list%E7%9A%84%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<ul>
<li><p>问题发现：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [[<span class="number">0</span>]*<span class="number">2</span>]*<span class="number">3</span></span><br><span class="line">list2 = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">list1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">list2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(list1)  <span class="comment"># [[1, 0], [1, 0], [1, 0]]</span></span><br><span class="line">print(list2)  <span class="comment"># [[1, 0], [0, 0], [0, 0]]</span></span><br></pre></td></tr></table></figure>
<p>  在上述示例代码中，list1, list2这两种初始化的方式都会得到 [[0, 0], [0, 0]] 这样的list。<br>  但在我们想要修改list1以及list2的[0][0]位置的值时，我们发现list2中修改结果如我们所愿，而list1中所有元素均被修改。</p>
</li>
<li><p>解释：<br>在Python3中，list1 以及list2 两种初始化方式分别对应如下两种方式：</p>
<ul>
<li>list1<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, list1 &#x3D; [0]*2, []</span><br><span class="line">for i in range(3):    </span><br><span class="line">    list1.append(x)</span><br></pre></td></tr></table></figure></li>
<li>list2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list2 &#x3D; []</span><br><span class="line">for i in range(3):</span><br><span class="line">    x &#x3D; [0]*2</span><br><span class="line">    list2.append(x)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  <strong>list1:</strong> 将同一个对象x添加到list1当中三次，即list1中三个元素为同一个对象<br>  <strong>list2:</strong> 每次迭代创建一个新的对象，并将其添加到list2中</p>
</li>
<li><p>验证：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(list1[<span class="number">0</span>] <span class="keyword">is</span> list1[<span class="number">1</span>])  <span class="comment"># True</span></span><br><span class="line">print(list2[<span class="number">0</span>] <span class="keyword">is</span> list2[<span class="number">1</span>])  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次网络配置故障排查记录</title>
    <url>/2020/03/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="一、问题出现"><a href="#一、问题出现" class="headerlink" title="一、问题出现"></a>一、问题出现</h4><p>问题源自之前做的一个项目，客户换了新电脑之后，无论如何都打不开软件。</p>
<p>在多台电脑上测试后，都可以正常运行，唯独客户打不开，简单检查排除了软件自身的原因。</p>
<p>之后经过长时间检查，发现是客户新电脑网络配置的问题，以此文来记录下排查故障的过程和问题解决的方式。</p>
<hr>
<h4 id="二、基本环境"><a href="#二、基本环境" class="headerlink" title="二、基本环境"></a>二、基本环境</h4><ul>
<li>项目基础：<ol>
<li><code>Python3</code> + <code>PyQt5</code> 制作的桌面应用程序，在win10系统下使用，主要使用的模块还有<code>requests</code>；</li>
<li>使用<code>pyinstaller</code> 打包成单个exe程序，无需客户配置程序运行环境；</li>
</ol>
</li>
<li>客观因素：客户网络不是很好，网速比较慢</li>
</ul>
<h4 id="三、排查故障及解决过程"><a href="#三、排查故障及解决过程" class="headerlink" title="三、排查故障及解决过程"></a>三、排查故障及解决过程</h4><ol>
<li><p>错误提示<br> 客户每次运行软件，都会弹出<code>Failed to execute script ***</code>的错误提示窗口，此外没有其他信息。</p>
</li>
<li><p>重新打包<br> 之前的打包方式为 <code>pyinstall -F -w ***.py</code>，生成的为不带命令行窗口的单个EXE文件。为了查看更多、更详细的错误提示信息，需要重新打包软件，使用以下命令可以打包成使用命令行窗口执行的EXE文件。<br> <code>pyinstall -F -c ***.py</code><br> 在命令行窗口中再次运行程序，观察命令行窗口错误信息，主要有如下信息：<br> <img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/error.png" alt=""><br> 发现是在通过 <code>requests</code>库连接目标网址的时候，连接失败了。</p>
<blockquote>
<p> 考虑到客户说他网络不好，首先怀疑是网速的原因，但通过在浏览器网页打开目标网站的速度来看，应该不是由网速引起的，决定进一步排查。</p>
</blockquote>
</li>
<li><p>检查网络配置<br> 借助win10 自带工具<code>ping</code> 和 <code>telnet</code> 在命令行窗口排查故障</p>
<ul>
<li><p>在命令行中 <code>ping www.目标网址.com</code> ：<strong>提示找不到主机，请检查名称，然后重试。</strong>（博主自己的电脑可以）</p>
</li>
<li><p>在命令行中 <code>ping www.baidu.com</code>：ping 不通，同样的提示信息。</p>
</li>
<li><p>在命令行中 <code>telnet www.目标网址.com 443</code>：<strong>提示无法打开到主机的连接，在端口443，连接失败。</strong>（博主自己的电脑可以）</p>
</li>
<li><p>在命令行中 <code>ping 221.**.**.190(目标网址IP)</code>：可以ping通</p>
</li>
<li><p>在命令行中 <code>ping 111.206.223.172(百度网址的IP)</code>：可以ping通</p>
<p>可以发现客户电脑在 <code>ping</code> 域名时无法ping通，在直接 <code>ping</code>IP地址时可以ping通。推测是客户电脑在解析域名为IP地址时发生问题。</p>
</li>
<li><p>在命令行中 <code>nslookup www.目标网址.com</code>：失败（意料之中）</p>
</li>
<li><p>在命令行中 <code>nslookup www.baidu.com</code>：失败</p>
<p>由此可以判断是客户电脑DNS配置有问题，在解析域名时失败。</p>
</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>配置DNS服务器<strong>手动模式</strong>，输入<code>8.8.8.8</code></li>
<li>在命令行中刷新DNS缓存，执行 <code>ipconfig /flushdns</code></li>
<li>在命令行中（管理员身份）重置网络配置，执行 <code>netsh winsock reset</code></li>
<li>重新启动</li>
</ul>
</li>
</ol>
<hr>
<h4 id="四、事后"><a href="#四、事后" class="headerlink" title="四、事后"></a>四、事后</h4><p>通过一步一步的排查故障，到最后解决之后，感觉浑身通畅、无比舒服，也许这就是计算机的魅力之处吧</p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub搭建部署个人网站</title>
    <url>/2020/02/29/Hexo-GitHub%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><ul>
<li>安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
<li>安装 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li>
</ul>
<hr>
<h4 id="二、安装配置Hexo"><a href="#二、安装配置Hexo" class="headerlink" title="二、安装配置Hexo"></a>二、安装配置Hexo</h4><ol>
<li><p>安装</p>
<p>打开Git-bash，输入以下命令安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<br>选择合适的文件夹，如 <code>E:\hexo</code>，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd E:\hexo</span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>执行成功后，在 <code>hexo</code>文件夹下的目录结构类似为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _config.yml </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source|   </span><br><span class="line">├       ├── _drafts|   </span><br><span class="line">├       └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<ul>
<li>_config.yml: 网站的配置 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 文件，可以在此配置大部分的参数。</li>
<li>文件详细介绍可见 <a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">Hexo 官方网站</a></li>
</ul>
</li>
<li><p>测试，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>按照信息提示，使用浏览器访问 <code>http://localhost:4000/</code>。可以看到Hexo默认主题则说明本地建站成功。</p>
</li>
<li><p>修改主题</p>
<p>本网站使用的是 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next 主题</a></p>
<ul>
<li><p>下载主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用主题<br>修改 <code>_config.yml</code> 文件，找到 <code>theme</code>字段，并将其值改为 <code>next</code></p>
</li>
<li><p>验证主题<br>执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p> 此时使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行 <code>Next</code>主题。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="三、配置GitHub"><a href="#三、配置GitHub" class="headerlink" title="三、配置GitHub"></a>三、配置GitHub</h4><ul>
<li><p>创建仓库</p>
<p>新建一个名为<code>GitHub账户名.github.io</code>的仓库，之后网站的访问网址就是<code>http://GitHub账户名.github.io</code></p>
</li>
</ul>
<hr>
<h4 id="四、将Hexo部署到GitHub-Pages"><a href="#四、将Hexo部署到GitHub-Pages" class="headerlink" title="四、将Hexo部署到GitHub Pages"></a>四、将Hexo部署到GitHub Pages</h4><ol>
<li><p>安装 <code>hexo-deploy-git</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>_config.yml</code> 文件，找到<code>deploy</code> 配置项，修改为如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo:  https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt; </span><br><span class="line">    #示例：https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io </span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>注：要确保可以向 <code>GitHub</code>正常 <code>Push</code>，若出错，请检查是否配置好了<code>ssh key</code></p>
</li>
<li><p>验证部署<br>使用浏览器打开 <code>http://GitHub账户名.github.io</code>，验证是否部署成功。</p>
</li>
</ol>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫篇-动态网页的处理方式下:模拟浏览器行为</title>
    <url>/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8B-%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>在上篇文章<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/#more" target="_blank" rel="noopener">爬虫篇-动态网页的处理方式中:渲染动态网页</a>中，我们使用<code>WebKit</code>库，可以自定义浏览器渲染引擎，这样就可以完全控制想要执行的行为。如果不需要那么高的灵活性，那么还有一个不错的替代品 <a href="https://docs.seleniumhq.org/" target="_blank" rel="noopener">Selenium</a> 可以选择，它提供了使浏览器自动化的API 接口。</p>
<hr>
<h4 id="一、Selenium-简介："><a href="#一、Selenium-简介：" class="headerlink" title="一、Selenium 简介："></a>一、Selenium 简介：</h4><p>Selenium 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持市面上几乎所有的主流浏览器。</p>
<p>本来打算使用的是selenium + PhantomJS的组合，但发现Chrome以及FireFox也相继推出无头 ( <em>headless</em> ) 浏览器模式，个人比较倾向Chrome。本文采用的是Selenium+Chrome的组合。</p>
<hr>
<h4 id="二、爬虫示例："><a href="#二、爬虫示例：" class="headerlink" title="二、爬虫示例："></a>二、爬虫示例：</h4><p>运用到爬虫中的思路是：</p>
<ul>
<li>使用Selenium 渲染网页，解析渲染后的网页源码，或者直接通过Selenium 接口获取页面中的元素。</li>
</ul>
<p>还是以 <a href="http://book.sina.com.cn/excerpt/" target="_blank" rel="noopener">新浪读书——书摘</a> 这个网站为例，目标是获取列表中每篇文章详情页的地址，直接看示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinaBookSpider</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建可见的Chrome浏览器， 方便调试</span></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建Chrome的无头浏览器</span></span><br><span class="line">    <span class="comment"># opt = webdriver.ChromeOptions()</span></span><br><span class="line">    <span class="comment"># opt.set_headless()</span></span><br><span class="line">    <span class="comment"># driver = webdriver.Chrome(options=opt)</span></span><br><span class="line"></span><br><span class="line">    driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    total = <span class="number">1526</span>  <span class="comment"># 预先计算的总数据量</span></span><br><span class="line">    count = <span class="number">0</span>  <span class="comment"># 已爬取的数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录解析以及翻页位置</span></span><br><span class="line">    location = <span class="number">0</span></span><br><span class="line">    click_times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        开始爬虫</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># get方式打开网页</span></span><br><span class="line">        self.driver.get(<span class="string">"http://book.sina.com.cn/excerpt/rwws/"</span>)</span><br><span class="line"></span><br><span class="line">        self.parselist()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.count &lt; self.total:</span><br><span class="line">            <span class="keyword">if</span> self.click_times <span class="keyword">is</span> <span class="number">2</span>:</span><br><span class="line">                self.driver.find_element_by_css_selector(<span class="string">'#subShowContent1_page &gt; span:nth-child(6) &gt; a'</span>).click()</span><br><span class="line">                <span class="comment"># 等待页面加载完成</span></span><br><span class="line">                time.sleep(<span class="number">5</span>)</span><br><span class="line">                self.click_times = <span class="number">0</span></span><br><span class="line">                self.location = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.driver.find_element_by_css_selector(<span class="string">'#subShowContent1_loadMore'</span>).click()</span><br><span class="line">                <span class="comment"># 等待页面加载完成</span></span><br><span class="line">                time.sleep(<span class="number">3</span>)</span><br><span class="line">                self.click_times += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 分析加载的新内容，从location开始</span></span><br><span class="line">            self.parselist()</span><br><span class="line">        self.driver.quit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parselist</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        解析列表</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        divs = self.driver.find_elements_by_class_name(<span class="string">"item"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.location, len(divs)):</span><br><span class="line">            link = divs[i].find_element_by_tag_name(<span class="string">'a'</span>).get_attribute(<span class="string">"href"</span>)</span><br><span class="line">            <span class="keyword">print</span> link</span><br><span class="line">            self.location += <span class="number">1</span></span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> self.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    spider = SinaBookSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 代码地址：<a href="https://github.com/linbo-lin/dynamic-web-process" target="_blank" rel="noopener">dynamic-web-process —— GitHub</a><br> 如果你想实际运行上述代码，请在运行之前确定：安装了与浏览器版本对应的驱动，并正确的添加到了环境变量中。</p>
</blockquote>
<p>使用<code>selenium</code>时同样要特别注意的是如何确定<strong>网页是否加载完成</strong>，有三种方式：</p>
<ul>
<li>强制等待</li>
<li>隐形等待</li>
<li>显性等待</li>
</ul>
<blockquote>
<p>有关这三种方式的讲解可以看这里：<a href="https://huilansame.github.io/huilansame.github.io/archivers/sleep-implicitlywait-wait" target="_blank" rel="noopener">Python selenium —— 一定要会用selenium的等待，三种等待方式解读 —— 灰蓝的博客</a></p>
</blockquote>
<hr>
<h4 id="三、小结："><a href="#三、小结：" class="headerlink" title="三、小结："></a>三、小结：</h4><p>到此，我们介绍了动态页面处理的三种思路：</p>
<ul>
<li><a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8A-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" target="_blank" rel="noopener">逆向工程</a></li>
<li>渲染动态页面：<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/" target="_blank" rel="noopener">使用<code>PySide</code>或<code>ghost.py</code></a></li>
<li><a href="">selenium 模拟浏览器</a></li>
</ul>
<p>做一下简单的比较：</p>
<ul>
<li>前者在运行上更快，开销更小。在实际情况中，大多数网页都可以被逆向，但是有些网页足够复杂逆向要花费极大的功夫。</li>
<li>后两者在思路上更直观，更容易被接受和理解。浏览器渲染引擎能够为我们节省了解网站后端工作原理的时间，但是渲染网页增大了开销，使其比单纯下载HTML更慢。另外，使用后两者通常需要轮训网页来检查是否已经得到所需的HTML元素，这种方式非常脆弱，在网络较慢时经常会失败。</li>
</ul>
<p>采用哪种方法，取决于爬虫活动中的具体情况：</p>
<ul>
<li>易于逆向、对速度和资源要求高的，应使用前者；</li>
<li>难以逆向、没有工程上的优化的要求的，可以使用后者。</li>
</ul>
<p>个人认为模拟浏览器的方法应尽量避免，因为浏览器环境对内存和CPU的消耗非常多，可以作为短期决绝方案，此时长期的性能和可靠性并不算重要；而作为长期解决方案，我会尽最大努力对网站进行逆向工程。</p>
<blockquote>
<p>本文有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫篇-动态网页的处理方式中:渲染动态网页</title>
    <url>/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>上一篇文章中我们介绍了爬取动态网页的一种方式：<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8A-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/#more" target="_blank" rel="noopener">逆向工程</a></p>
<p>这种方式有一点美中不足：这种方式要求我们对JavaScript以及Ajax有一定的了解，而且当网页的JS代码混乱，难以分析的时候，上述过程会花费我们大量的时间和精力。</p>
<p>这时候，如果对爬虫的执行效率没有过多要求，又不想浪费太多时间在了解JavaScript代码逻辑、找寻Ajax请求链接上，我们可以尝试另一种方式——<strong>渲染动态网页</strong> 。</p>
<hr>
<h4 id="一、浏览器渲染引擎："><a href="#一、浏览器渲染引擎：" class="headerlink" title="一、浏览器渲染引擎："></a>一、浏览器渲染引擎：</h4><p>在介绍这种方式之前，我们需要首先了解一些浏览器渲染引擎的基本知识。渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。浏览器向服务器发送请求，得到服务器返回的资源文件后，经过需要渲染引擎的处理，将资源文件显示在浏览器窗口中。目前使用较为广泛的渲染引擎有两种：</p>
<ul>
<li>webkit——使用者有Chrome, Safari</li>
<li>Geoko——使用者有Firefox</li>
</ul>
<p><strong>渲染主流程：</strong></p>
<ul>
<li><p>渲染引擎首先通过网络获得所请求文档的内容；</p>
</li>
<li><p>下面是渲染引擎在取得内容之后的基本流程：</p>
<p><code>解析html以构建dom树</code> -&gt; <code>构建render树</code> -&gt; <code>布局render树</code> -&gt; <code>绘制render树</code></p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/aHR0cHM6Ly9waWMwMDIuY25ibG9ncy5jb20vaW1hZ2VzLzIwMTEvMjY1MTczLzIwMTExMTAzMTYyNjM3MTUucG5n.jfif" style="zoom:67%;" />
</li>
<li><p>渲染引擎开始解析html，并将标签转化为内容树中的dom节点。如果遇到JS，那么此时会启用单独连接进行下载，并且在下载后进行解析。</p>
</li>
<li><p>接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树—render树。</p>
<p>Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。</p>
</li>
<li><p>Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。</p>
</li>
<li><p>再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</p>
</li>
</ul>
<p>想要了解更多有关浏览器渲染引擎的知识，可以阅读这些：</p>
<ul>
<li><p><a href="http://www.cnblogs.com/lhb25/p/how-browsers-work.html#Resources" target="_blank" rel="noopener">前端文摘：深入解析浏览器的幕后工作原理</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xiaozhuxmen/article/details/52014901" target="_blank" rel="noopener">浏览器加载、解析、渲染的过程</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xifeijian/article/details/10813339" target="_blank" rel="noopener">浏览器加载和渲染html的顺序-css渲染效率的探究</a></p>
</li>
</ul>
<p><strong>思考：</strong></p>
<p>了解了浏览器渲染引擎的基本原理，我们可以发现：</p>
<ul>
<li>当浏览器渲染引擎完成了dom树以及render树的构建之后，树中就已经包含了我们在浏览器窗口中可以看到的所有数据。</li>
</ul>
<p>那么我们就有了一种爬取动态网页的新思路：</p>
<ul>
<li>在浏览器渲染引擎执行<code>layout</code>以及<code>printing</code>之前，得到<code>dom</code>树或者<code>render</code>树，从树中获取动态加载的数据。</li>
</ul>
<hr>
<h4 id="二、渲染动态网页："><a href="#二、渲染动态网页：" class="headerlink" title="二、渲染动态网页："></a>二、渲染动态网页：</h4><p>有两种选择：</p>
<ul>
<li><p>自己从头实现一个浏览器渲染引擎，在合适的时机返回构建的<code>dom</code>树或<code>render</code>树。这需要进行大量的工作，需要考虑html、js、css等不同格式文件的解析方式以及解析顺序等。</p>
<p>本人参考以下资料进行了尝试，但最终没有成功，有兴趣的可以尝试下。</p>
<ul>
<li><p><a href="http://ju.outofmemory.cn/entry/36085" target="_blank" rel="noopener">使用PyV8解析HTML 文档</a> （文中提到的demo可以从下面的链接得到）</p>
</li>
<li><p><a href="https://storage.googleapis.com/google-code-archive-source/v2/code.google.com/pyv8/source-archive.zip" target="_blank" rel="noopener">PyV8源码以及demo</a></p>
</li>
</ul>
</li>
<li><p>利用已有的渲染引擎。</p>
</li>
</ul>
<p>接下来将使用WebKit 渲染引擎，通过 <a href="http://pyside.github.io/docs/pyside/" target="_blank" rel="noopener">PySide</a> 这个python库可以获得该引擎的一个便捷接口。</p>
<hr>
<h4 id="三、爬虫示例："><a href="#三、爬虫示例：" class="headerlink" title="三、爬虫示例："></a>三、爬虫示例：</h4><p>还是以 <a href="http://book.sina.com.cn/excerpt/rwws/" target="_blank" rel="noopener">新浪读书——书摘</a> 为例，可以发现：页面中文章列表的部分是动态加载的。</p>
<p><strong>爬虫代码：</strong></p>
<p>使用<code>PySide</code>库进行处理的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PySide.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide.QtWebKit <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    url = <span class="string">"http://book.sina.com.cn/excerpt/rwws/"</span></span><br><span class="line"></span><br><span class="line">    app = QApplication([])  <span class="comment"># 完成其他Qt对象之前，必须先创建该对象</span></span><br><span class="line">    webview = QWebView()  <span class="comment"># 该对象是Web 对象的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用show方法显示窗口</span></span><br><span class="line">    <span class="comment"># webview.show()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置循环事件， 并等待网页加载完成</span></span><br><span class="line">    loop = QEventLoop()</span><br><span class="line">    webview.loadFinished.connect(loop.quit)</span><br><span class="line">    webview.load(QUrl(url))</span><br><span class="line">    loop.exec_()</span><br><span class="line"></span><br><span class="line">    frame = webview.page().mainFrame()  <span class="comment"># QWebFrame类有很多与网页交互的有用方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到页面渲染后的html代码</span></span><br><span class="line">    html = frame.toHtml()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> html</span><br></pre></td></tr></table></figure>

<p>通过<code>print</code>语句，我们可以发现：页面的源码<code>html</code>中已经包含了动态加载的内容。</p>
<p><strong>与网站交互：</strong></p>
<p>得到动态加载的内容后，需要解决的另一个问题是翻页问题。还好<code>PySide</code>库的<code>QWebKit</code>模块还有一个名为<code>QWebFrame</code>的类，支持很多与网页的交互操作。如“点击”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据CSS Selector 找到所需“进行翻页”的元素</span></span><br><span class="line">elem = frame.findFirstElement(<span class="string">'#subShowContent1_loadMore'</span>)</span><br><span class="line"><span class="comment"># 点击：通过evaluateJavaScript()函数可以执行Js代码</span></span><br><span class="line">elem.evaluateJavaScript(<span class="string">'this.click()'</span>)</span><br></pre></td></tr></table></figure>

<p>除了点击事件，还可以进行填充表单，滚动窗口等操作。</p>
<p><strong>数据加载时间：</strong></p>
<p>需要注意的是，在进行了翻页、或者获取更多内容时，一个最大的难点在于如何确定页面是否完成了加载，因为我们难以估计Ajax事件或者Js准备数据的时间。对于这个问题有两种解决思路：</p>
<ul>
<li><p>等待固定的一段时间，比如<code>time.sleep(3)</code>：这种方法容易实现，但效率较低；</p>
</li>
<li><p>轮询网页，等待特定内容出现；这种方法虽然会在检查是否加载完成时浪费CPU周期，但更加可靠。以下是一个简单的实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elem = <span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> elem:</span><br><span class="line">    app.processEvents()</span><br><span class="line">    elem = frame.findAllElemnets(<span class="string">'#pattern'</span>)</span><br></pre></td></tr></table></figure>

<p>代码循环，直到出现特定元素。每次循环，调用<code>app.processEvents()</code>方法，用于给Qt事件循环执行任务的时间，比如响应点击事件。</p>
<blockquote>
<p>更多有关PySide的内容请看这里：<a href="http://pyside.github.io/docs/pyside/" target="_blank" rel="noopener">PySide官方文档</a></p>
</blockquote>
<hr>
<h4 id="四、ghost-py"><a href="#四、ghost-py" class="headerlink" title="四、ghost.py"></a>四、ghost.py</h4><p>但是<code>PySide</code>毕竟是一个为了Python的GUI 编程而开发的， 其功能对于爬虫来说实在是太过于庞大，所以我们可以把爬虫经常使用的功能进行封装，来提升编写爬虫的效率。<a href="http://ghost-py.readthedocs.io/en/latest/#" target="_blank" rel="noopener">ghost.py</a>  是目前一个针对爬虫且功能比较完善的<code>PySide</code>的封装模块，使用它可以很方便的进行数据采集。</p>
<p>还是以获取列表页中每篇文章详情页地址为目标，直接看示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ghost <span class="keyword">import</span> Ghost, Session</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinaBookSpider</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化相关参数</span></span><br><span class="line">    gh = Ghost()</span><br><span class="line">    ss = Session(gh, display=<span class="literal">True</span>)  <span class="comment"># 设置display为true, 方便调试</span></span><br><span class="line"></span><br><span class="line">    total = <span class="number">1526</span>  <span class="comment"># 预先计算的总数据量</span></span><br><span class="line">    count = <span class="number">0</span>  <span class="comment"># 已爬取的数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录解析以及翻页位置</span></span><br><span class="line">    location = <span class="number">0</span></span><br><span class="line">    click_times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        开始爬虫</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 打开网页</span></span><br><span class="line">        self.ss.open(<span class="string">"http://book.sina.com.cn/excerpt/rwws/"</span>)</span><br><span class="line">        <span class="comment"># 等待数据加载完成</span></span><br><span class="line">        self.ss.wait_for_selector(<span class="string">'#subShowContent1_static &gt; div:nth-child(20)'</span>)</span><br><span class="line"></span><br><span class="line">        self.parselist()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.count &lt; self.total:</span><br><span class="line">            <span class="keyword">if</span> self.click_times <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 点击加载更多</span></span><br><span class="line">                self.ss.click(<span class="string">'#subShowContent1_loadMore'</span>)</span><br><span class="line">                <span class="comment"># 每次翻页，或加载更多，要等待至加载完成</span></span><br><span class="line">                self.ss.wait_for_selector(<span class="string">'#subShowContent1_static &gt; div:nth-child(21)'</span>)</span><br><span class="line"></span><br><span class="line">                self.click_times += <span class="number">1</span></span><br><span class="line">                self.parselist()</span><br><span class="line">            <span class="keyword">elif</span> self.click_times <span class="keyword">is</span> <span class="number">1</span>:</span><br><span class="line">                self.ss.click(<span class="string">'#subShowContent1_loadMore'</span>)</span><br><span class="line">                self.ss.wait_for_selector(<span class="string">'#subShowContent1_static &gt; div:nth-child(41)'</span>)</span><br><span class="line"></span><br><span class="line">                self.click_times += <span class="number">1</span></span><br><span class="line">                self.parselist()</span><br><span class="line">            <span class="keyword">elif</span> self.click_times <span class="keyword">is</span> <span class="number">2</span>:</span><br><span class="line">                self.ss.click(<span class="string">'#subShowContent1_page .pagebox_next a'</span>)</span><br><span class="line">                self.ss.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                self.click_times = <span class="number">0</span></span><br><span class="line">                self.location = <span class="number">0</span></span><br><span class="line">                self.parselist()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parselist</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        解析列表页</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        html = self.ss.content.encode(<span class="string">'utf8'</span>)</span><br><span class="line">        <span class="comment"># print html</span></span><br><span class="line"></span><br><span class="line">        pattern = re.compile(<span class="string">r'&lt;div class="item"&gt;&lt;h4&gt;&lt;a href="(.*?)" target="_blank"&gt;'</span>, re.M)</span><br><span class="line">        links = pattern.findall(html)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.location, len(links)):</span><br><span class="line">            <span class="keyword">print</span> links[i]</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            self.location += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> self.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    spider = SinaBookSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 代码地址：<a href="https://github.com/linbo-lin/dynamic-web-process" target="_blank" rel="noopener">dynamic-web-process —— GitHub</a></p>
</blockquote>
<p><strong>补充：</strong></p>
<ul>
<li><p><code>ghost.py</code>对直接获取元素支持的不是很好，但可以借助<code>BeautifulSoup</code>或<code>正则表达式</code>来解决。</p>
</li>
<li><p><code>ghost.py</code>支持与网页的简单交互，如点击，填充表单等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set_field_value(*args, **kwargs)</span><br><span class="line">fill(*args, **kwargs)</span><br><span class="line">click(*args, **kwargs)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ghost.py</code>很好的解决了<strong>确定元素加载完成</strong>的问题，通过以下方法可以让爬虫等待，直到满足设置的条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wait_for(condition, timeout_message, timeout=<span class="literal">None</span>)</span><br><span class="line">wait_for_page_loaded(timeout=<span class="literal">None</span>)</span><br><span class="line">wait_for_selector(selector, timeout=<span class="literal">None</span>)</span><br><span class="line">wait_for_text(text, timeout=<span class="literal">None</span>)</span><br><span class="line">wait_while_selector(selector, timeout=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有关更多<code>ghost.py</code>的方法请看这里：<a href="http://ghost-py.readthedocs.io/en/latest/#" target="_blank" rel="noopener">Ghost.py</a></p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>动态网页</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫篇-动态网页的处理方式上:逆向工程</title>
    <url>/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8A-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="一、动态网页简介："><a href="#一、动态网页简介：" class="headerlink" title="一、动态网页简介："></a>一、动态网页简介：</h4><p>在我们编写爬虫时，可能会碰到以下两种问题：</p>
<ul>
<li>我们所需要爬取的数据在网页源代码中并不存在；</li>
<li>点击下一页跳转页面时，网页的URL 并没与发生变化；</li>
</ul>
<p>造成这种问题原因是，你所正在爬取的页面采取了动态加载的方式，是一个动态网页。所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码生成，页面的内容和显示效果就不会发生变化了。而动态网页则不然，其显示的页面则是经过Javascript处理数据后生成的结果，可以发生改变。这些数据的来源有多种，可能是经过Javascript计算生成的，也可能是通过Ajax加载的。动态网页经常使用的一种技术是Ajax请求技术。</p>
<p><code>Ajax(Asynchronous JavaScript and XML)</code>，其最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页的内容。想要了解更多有关Ajax技术的可以看这里：</p>
<ol>
<li><a href="http://www.runoob.com/ajax/ajax-tutorial.html" target="_blank" rel="noopener">AJAX教程——菜鸟教程</a></li>
<li><a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">jQuery ajax -ajax()方法——W3school</a></li>
</ol>
<p>目前，越来越多的网站采取的是这种动态加载网页的方式，一来是可以实现web开发的前后端分离，减少服务器直接渲染页面的压力；二来是可以作为反爬虫的一种手段。</p>
<hr>
<h4 id="二、爬虫处理动态页面的三种方式："><a href="#二、爬虫处理动态页面的三种方式：" class="headerlink" title="二、爬虫处理动态页面的三种方式："></a>二、爬虫处理动态页面的三种方式：</h4><ul>
<li>逆向工程</li>
<li>渲染动态网页：使用<code>pyside</code>或<code>ghost.py</code><ul>
<li>selenium模拟浏览器</li>
</ul>
</li>
</ul>
<hr>
<h4 id="三、逆向工程："><a href="#三、逆向工程：" class="headerlink" title="三、逆向工程："></a>三、逆向工程：</h4><p>对于动态加载的网页，我们想要获取其网页数据，需要了解网页是如何加载数据的，该过程就被成为<strong>逆向工程</strong>。对于使用了Ajax 请求技术的网页，我们可以找到Ajax请求的具体链接，直接得到Ajax请求得到的数据。需要注意的是，构造Ajax请求有两种方式：</p>
<ul>
<li>原生的Ajax请求，会直接创建一个<code>XMLHTTPReques</code>t对象。</li>
<li>调用jQuery的ajax()方法。一般情况下，<code>$.ajax()</code>会返回其创建的<code>XMLHTTPRequest</code>对象；但是，如果<code>$.ajax()</code>的<code>dataType</code>参数指定了为<code>script</code>或<code>jsonp</code>类型，<code>$.ajax()</code>不再返回其创建的<code>XMLHTTPRequest</code>对象。</li>
</ul>
<p>对于这两种方式，只要创建返回了<code>XMLHTTPRequest</code>对象，就可以通过Chrome浏览器的调试工具在<code>NetWork</code>窗口通过设置<code>XHR</code>过滤条件，直接筛选出Ajax请求的链接；如果是<code>$.ajax()</code>并且<code>dataType</code>指定了为<code>script</code>或<code>jsonp</code>，则无法通过这种方式筛选出来。</p>
<hr>
<h4 id="四、爬虫示例："><a href="#四、爬虫示例：" class="headerlink" title="四、爬虫示例："></a>四、爬虫示例：</h4><p>接下来以 <a href="http://book.sina.com.cn/excerpt/" target="_blank" rel="noopener">新浪读书——书摘</a> 这个网站的爬取为例，介绍如何得到无法筛选出来的Ajax请求链接：</p>
<p>在Chrome中打开网页，右键<code>检查</code>，会发现首页中书摘列表包含在一个id为<code>subShowContent1_static</code>的div中，而<code>查看网页源代码</code>会发现id为<code>subShowContent1_static</code>的div为空。点击<code>更多书摘</code>或<code>下一页</code>时，网页URL并没有发生变化。与我们最前面所说的两种情况相同。</p>
<p><code>F12</code>打开调试工具，打开<code>NetWork</code>窗口<em>（功能是记录浏览器的活动记录<code>network activities</code>）</em>，<code>F5</code>刷新，可以看到浏览器发送以及接收到的数据记录，其实我们所找的Ajax请求链接就是其中一条。</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194144329.png" alt="活动记录" style="zoom:80%;" />

<p><strong>第一步：</strong></p>
<p>首先设置<code>XHR</code>过滤条件，发现筛选结果为空白，可以推断出这个网页采用的Ajax请求应该是设置了<code>dataType</code>为<code>script</code>或者<code>jsonp</code>。</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194303975.png" alt="xhr" style="zoom:80%;" /> 

<p>重新打开调试工具，点击网页上的<code>更多书摘</code>，发现<code>NetWork</code>窗口出现了很多记录，网页也多了新的内容，说明浏览器向服务器发送了请求。在网页上，右键<code>检查</code> <code>更多书摘</code>，观察此元素绑定的JavaScript事件：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/2019012119433920.png" alt="Javascript"></p>
<blockquote>
<p>根据JavaScript的知识：<code>javascript:</code>是一个伪协议，表示在触发<code>&lt;a&gt;</code>时，执行一段JavaScript代码，而<code>javascript:;</code>表示什么都不执行，这样点击<code>&lt;a&gt;</code>时就没有任何反应。但一般在这种情况下，会给<code>&lt;a&gt;</code>绑定一个事件回调，来执行业务.</p>
</blockquote>
<p>接下来就需要在网页的JavaSCript代码中找到<code>更多书摘</code>所触发的回调函数。</p>
<p><strong>第二步：</strong></p>
<p>右键<code>检查网页源代码</code>，<code>Ctrl+F</code>搜索<code>subShowContent1_loadMore”</code>(元素<code>更多书摘</code>的id)，发现并没有某个具体的函数与之相关：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194406987.png" alt="函数" style="zoom:80%;" />

<p>这说明<code>更多书摘</code>的回调函数不在网页自身写的JavaScript代码中，那就应该在网页嵌入的JS文件中（通过<code>&lt;script type=”text/javascript” src=“***.js”&gt; &lt;script&gt;</code>这种形式调用的JS文件）。</p>
<p><strong>第三步：</strong></p>
<p>逐个打开嵌入的JS文件，查找与<code>更多书摘</code>绑定的函数，终于在“<a href="http://n.sinaimg.cn/book/js/feedlist.js”这个JS文件中发现函数`$()`如下：" target="_blank" rel="noopener">http://n.sinaimg.cn/book/js/feedlist.js”这个JS文件中发现函数`$()`如下：</a></p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194456854.png" alt="函数" style="zoom:80%;" />

<p>但此函数中并没有直接构造Ajax请求，而是通过调用<code>ListMore()</code>函数执行。继续查找<code>ListMore()</code>函数，发现其内部还是未构造Ajax请求，通过<code>ListMore()</code>内部调用的函数进一步寻找，经过以下过程：<code>$()</code> -&gt; <code>ListMore()</code> -&gt; <code>GetmoreList()</code> -&gt; <code>getMore()</code> 。终于在<code>getMore()</code>函数中发现了Ajax请求的构造过程，发现<code>dataType</code>确实是<code>jsonp</code>：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194526155.png" alt="函数" style="zoom:80%;" />

<p><strong>第四步：</strong></p>
<p>在<code>NetWork</code>窗口<code>Initiator</code>栏点击<code>feedlist.js</code>进入<code>Sources</code>窗口，在<code>$.ajax()</code>处添加断点，<code>F5</code>刷新，Javascript执行到断点处会停止，鼠标分别指在<code>url</code>,<code>data</code>处观察数据：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194551812.png" style="zoom:80%;" />          <img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194605181.png" style="zoom:80%;" />       <img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/2019012119463585.png" style="zoom:80%;" /></p>
<ul>
<li>得到了url以及data的格式，就可以根据<code>jQuery</code>的<code>ajax()</code>用法构造正确的Ajax 请求链接：</li>
</ul>
<blockquote>
<p><a href="http://feed.mix.sina.com.cn/api/roll/get?callback=jsonp1522410869405&amp;pageid=96&amp;lid=560&amp;num=20&amp;page=1" target="_blank" rel="noopener">http://feed.mix.sina.com.cn/api/roll/get?callback=jsonp1522410869405&amp;pageid=96&amp;lid=560&amp;num=20&amp;page=1</a></p>
</blockquote>
<ul>
<li>在浏览器输入构造的链接进行验证，对比网页数据，发现这就是我们需要的Ajax请求链接。</li>
</ul>
<p><strong>第五步：</strong></p>
<p>之前我们说过，在<code>NetWork</code>窗口就有我们需要的Ajax请求链接，对比发现，果然存在：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194719925.png" style="zoom:80%;" />

<p>当我们点击<code>更多书摘</code>、<code>下一页</code>时，发现又多了几条这样的请求：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194737517.png" style="zoom:80%;" />

<p>对比发现：只有<code>jsonp**********</code>与<code>page=*</code>这两部分不同， <code>jsonp</code>后面跟的数字为当前时间的时间戳，是<code>jQuery.ajax()</code>方法自动计算添加的，<code>page</code>后面就是页数，这时候我们只要改变page后面的数字就可以构造翻页的链接了。</p>
<hr>
<h4 id="五、方法小结："><a href="#五、方法小结：" class="headerlink" title="五、方法小结："></a>五、方法小结：</h4><ul>
<li>首先通过设置<code>XHR</code>过滤条件，观察是否可以直接得到Ajax 请求；如果不可以，继续下一步。</li>
<li>查找能够发送Ajax请求的元素绑定的事件或回调函数：首先在网页源代码中查找，没有的话，逐个查找嵌入的JS文件。</li>
<li>找到之后，看函数内部是否直接构造Ajax请求，没有直接构造的话，根据函数调用关系一步一步查找，直到找到构造过程为止。</li>
<li>添加断点，调试，根据Ajax请求的构造方式以及数据形式手动构造链接。 </li>
<li>验证构造的链接的正确性。</li>
</ul>
<p>其实当你有了经验之后，对一些不是很复杂的网页，根本就不用进行这么复杂的逆向工程，凭URL形式可以很快的在<code>NetWork</code>窗口很快的 <strong>选择-验证</strong> 出所需的Ajax请求。</p>
<p>得到Ajax请求链接之后，可以直接得到请求的数据，一般为json格式，处理后即可使用。</p>
<blockquote>
<p>代码见：<a href="https://github.com/linbo-lin/dynamic-web-process" target="_blank" rel="noopener">dynamic-web-process —— GitHub</a></p>
</blockquote>
<hr>
<h4 id="六、最后："><a href="#六、最后：" class="headerlink" title="六、最后："></a>六、最后：</h4><p>本文以 <a href="http://book.sina.com.cn/excerpt/" target="_blank" rel="noopener">新浪读书——书摘 </a>这个示例，介绍了如何得到Ajax请求链接，这是爬取动态网页时可以采取的一种方式，这种方式可能会在寻找Ajax请求的过程中浪费一点时间，并且要求对JavaScript有一定的了解，但找到链接后，爬取的过程可以很迅速。</p>
<p>如果对爬虫执行效率没有过多要求，又不想浪费太多时间在了解JavaScript代码逻辑、找寻Ajax请求链接上，可以参看下一篇文章<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/#more" target="_blank" rel="noopener">爬虫篇-动态网页的处理方式中: 渲染动态网页</a>，这篇文章提供了爬取动态网页的另一种思路。</p>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>Ajax</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ConfigParser模块读取、写入文件时自动转换为小写字符的问题</title>
    <url>/2018/01/03/%E8%A7%A3%E5%86%B3ConfigParser%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E6%97%B6%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B0%8F%E5%86%99%E5%AD%97%E7%AC%A6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="一、问题："><a href="#一、问题：" class="headerlink" title="一、问题："></a>一、问题：</h4><p>最近在使用ConfigParser模块时，发现一个问题：</p>
<ul>
<li><strong>在写入文件时，无论原字符是大写还是小写，ConfigParser option 总是把它转换为小写字符，然后再写入。</strong></li>
</ul>
<p>查阅资料后发现是ConfigParser中optionxform()函数的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optionxform</span><span class="params">(self, optionstr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> optionstr.lower() <span class="comment">#转化为了小写字符</span></span><br></pre></td></tr></table></figure>



<h4 id="二、解决方案："><a href="#二、解决方案：" class="headerlink" title="二、解决方案："></a>二、解决方案：</h4><ul>
<li>第一种解决法案是改源码，直接将<code>def optionxform()</code>函数中<code>.lower()</code>去掉：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optionxform</span><span class="params">(self, optionstr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> optionstr</span><br></pre></td></tr></table></figure>

<p>此种解决方案的不足之处是只能在本机生效，换台机器就会出问题。</p>
<ul>
<li>第二种解决方案是自己写一个<code>MyConfigParser</code>，继承自<code>ConfigParser</code>，重写一下<code>optionxform()</code>方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> ConfigParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfigParser</span><span class="params">(ConfigParser.ConfigParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, defaults=None)</span>:</span></span><br><span class="line">        ConfigParser.ConfigParser.__init__(self, defaults=defaults)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optionxform</span><span class="params">(self, optionstr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> optionstr</span><br></pre></td></tr></table></figure>

<p>使用时使用自己写的<code>MyConfigParser</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conf = MyConfigParser()</span><br><span class="line">conf.read(<span class="string">"************"</span>)</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>本文有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ConfigParser</tag>
      </tags>
  </entry>
</search>
