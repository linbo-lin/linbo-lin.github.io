<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机基础—Linux</title>
    <url>/2020/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94Linux/</url>
    <content><![CDATA[<h4 id="一、Linux-查看打开的连接数"><a href="#一、Linux-查看打开的连接数" class="headerlink" title="一、Linux 查看打开的连接数"></a>一、Linux 查看打开的连接数</h4><h4 id="二、Linux-查看剩余内存"><a href="#二、Linux-查看剩余内存" class="headerlink" title="二、Linux 查看剩余内存"></a>二、Linux 查看剩余内存</h4><h4 id="三、服务器上如何查看一个5G大小的日志文件"><a href="#三、服务器上如何查看一个5G大小的日志文件" class="headerlink" title="三、服务器上如何查看一个5G大小的日志文件"></a>三、服务器上如何查看一个5G大小的日志文件</h4><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—C/C++</title>
    <url>/2020/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94C-C++/</url>
    <content><![CDATA[<h4 id="一、Const-Static-的区别"><a href="#一、Const-Static-的区别" class="headerlink" title="一、Const/Static 的区别"></a>一、Const/Static 的区别</h4><h5 id="static："><a href="#static：" class="headerlink" title="static："></a>static：</h5><ul>
<li>static 局部变量：将一个变量声明为函数的局部变量，但该变量在函数执行完成后不会被释放，而是继续保留在内存中，因此其值在下次调用时仍维持上次的值；</li>
<li>static 全局变量：表示一个变量在当前文件的全局内可访问，不能被模块外其他函数访问；</li>
<li>static 函数：表示一个函数只能在当前文件中被访问；</li>
<li>static 类成员变量：表示这个成员为全类所共有，(所有该类的实例共享)，必须<strong>在类声明的外部进行初始化</strong>；</li>
<li>static 类成员函数：表示这个函数为全类所共有，而且只能访问静态成员变量，这个函数不接受this指针；</li>
</ul>
<p>static成员变量和普通static变量一样，都在内存分区的全局数据区分配内存，到程序结束后释放。这就意味着，static成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p>
<h5 id="const"><a href="#const" class="headerlink" title="const:"></a>const:</h5><ul>
<li>const 常量：定义时就初始化，以后不能更改；</li>
<li>const 形参：该形参在函数里不能改变；</li>
<li>const 修饰类成员函数：该函数对成员变量只能进行读操作；</li>
</ul>
<p>const关键字阻止一个变量被改变；声明常量指针和指针常量。</p>
<p>对于类的成员函数，有时候必须指定其返回值为const类型，以使其返回值不为“左值”。</p>
<p>C++中const修饰的全局常量的作用域LOCAL的，即只在本文件中。可以通过配合使用<code>extern</code>关键字来声明该常量可以作用于其他编译模块中。</p>
<p>C中const修饰的全局常量的作用域是GLOBAL的，作用域整个编译工程。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招进度记录</title>
    <url>/2020/08/20/%E7%A7%8B%E6%8B%9B%E8%BF%9B%E5%BA%A6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h5 id="拼多多-—-服务端研发-—-提前批"><a href="#拼多多-—-服务端研发-—-提前批" class="headerlink" title="拼多多 — 服务端研发 —  提前批"></a><a href="https://careers.pinduoduo.com/campus/personal-center" target="_blank" rel="noopener">拼多多 — 服务端研发 —  提前批</a></h5><ul>
<li>视频一面 2020年8月11日 20:00-21:00  <strong>（未通过）</strong></li>
<li>已结束</li>
</ul>
<h5 id="百度-—-数据库内核开发-—-提前批"><a href="#百度-—-数据库内核开发-—-提前批" class="headerlink" title="百度 — 数据库内核开发 — 提前批"></a><a href="https://talent.baidu.com/external/baidu/campus.html#/individualCenter" target="_blank" rel="noopener">百度 — 数据库内核开发 — 提前批</a></h5><ul>
<li>电话一面 2020年8月20日 20:00-20:30  （已面， 未出结果）</li>
</ul>
<h5 id="字节跳动-—-后端开发工程师-—"><a href="#字节跳动-—-后端开发工程师-—" class="headerlink" title="字节跳动 — 后端开发工程师 — "></a><a href="https://job.bytedance.com/society/position/application" target="_blank" rel="noopener">字节跳动 — 后端开发工程师 — </a></h5><ul>
<li><p>笔试 2020年8月16日 10:00  <strong>（已通过）</strong></p>
</li>
<li><p>视频一面 2020年8月23日 14:00 <strong>（未进行）</strong></p>
</li>
</ul>
<h5 id="华为-—-Cloud-BU-—-正式批"><a href="#华为-—-Cloud-BU-—-正式批" class="headerlink" title="华为 — Cloud BU — 正式批"></a><a href="http://career.huawei.com/reccampportal/portal5/user-index.html" target="_blank" rel="noopener">华为 — Cloud BU — 正式批</a></h5><ul>
<li>笔试 2020年8月26日 <strong>（未进行）</strong></li>
</ul>
<h5 id="阿里-—-研发工程师C-C-数据库-—-正式批"><a href="#阿里-—-研发工程师C-C-数据库-—-正式批" class="headerlink" title="阿里 — 研发工程师C/C++(数据库) — 正式批"></a><a href="https://campus.alibaba.com/myJobApply.htm" target="_blank" rel="noopener">阿里 — 研发工程师C/C++(数据库) — 正式批</a></h5><ul>
<li>笔试 2020年8月21日  <strong>(未进行)</strong></li>
</ul>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>百度数据库内核开发电话一面面经</title>
    <url>/2020/08/20/%E7%99%BE%E5%BA%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E7%94%B5%E8%AF%9D%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>百度数据库内核开发，电话面试，20:00-20:30</p>
<hr>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>没有自我介绍，照着简历问了下学历</p>
</li>
<li><p>问实习项目，在做什么</p>
</li>
<li><p>问实验室项目(数据库开发)，代码量</p>
</li>
<li><p>怎么测试开发完成后不会对原有数据库功能造成影响</p>
</li>
<li><p>问实验室项目，聊到了实验室自研的数据库，问了下性能优劣，为什么(空间换时间)</p>
</li>
<li><p>网络知识：cookie/session</p>
</li>
<li><p>三次握手、四次挥手</p>
</li>
<li><p>HTTP 请求报文 怎么找到报文实体</p>
</li>
<li><p>C/C++ const与static的区别</p>
</li>
<li><p>C/C++  map的实现</p>
</li>
<li><p>红黑树的查找时间复杂度，为什么</p>
</li>
<li><p>树的遍历实现形式</p>
</li>
<li><p>linux查看连接数，查看剩余内存，</p>
</li>
<li><p>服务器上如何查看一个大小为5G的日志</p>
</li>
<li><p>为什么想做数据库</p>
</li>
<li><p>考不考虑Python开发岗</p>
</li>
<li><p>部分问题忘记了，没有手撕算法，没有反问环节</p>
</li>
</ul>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>总体感觉蛮简单。但是C/C++语言方面问题不太会，中间引导面试官可以问下Python，但面试官估计对Python不太熟，就转为问计算机基础了。其它基础问题感觉答的还可以。</p>
<p>期待二面。</p>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>电话面试</tag>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—数据结构与算法</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>数据结构</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—计算机网络</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—操作系统</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="一、死锁"><a href="#一、死锁" class="headerlink" title="一、死锁"></a>一、死锁</h3><h4 id="1-死锁："><a href="#1-死锁：" class="headerlink" title="1. 死锁："></a>1. 死锁：</h4><h4 id="2-死锁产生的条件："><a href="#2-死锁产生的条件：" class="headerlink" title="2. 死锁产生的条件："></a>2. 死锁产生的条件：</h4><h4 id="3-死锁避免："><a href="#3-死锁避免：" class="headerlink" title="3. 死锁避免："></a>3. 死锁避免：</h4>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>操作系统</tag>
        <tag>面试基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础—数据库</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h4 id="一、数据库范式"><a href="#一、数据库范式" class="headerlink" title="一、数据库范式"></a>一、数据库范式</h4><h5 id="第一范式-1NF-："><a href="#第一范式-1NF-：" class="headerlink" title="第一范式(1NF)："></a>第一范式(1NF)：</h5><p>如果一个关系模式R的所有属性都是<strong>不可分</strong>的基本数据项，则这个关系模式属于第一范式；</p>
<h5 id="第二范式-2NF-："><a href="#第二范式-2NF-：" class="headerlink" title="第二范式(2NF)："></a>第二范式(2NF)：</h5><p>如果关系模式R属于第一范式，且每个<strong>非主属性</strong>都<strong>完全函数依赖</strong>于键码，则R属于第二范式；</p>
<p>第二范式消除了<strong>非主属性</strong>对键码的<strong>部分依赖</strong>；</p>
<h5 id="第三范式-3NF-："><a href="#第三范式-3NF-：" class="headerlink" title="第三范式(3NF)："></a>第三范式(3NF)：</h5><p>如果关系模式R属于第一范式，且每个<strong>非主属性</strong>都<strong>不传递依赖</strong>于键码，则R属于第三范式；</p>
<p>第三范式消除了<strong>非主属性</strong>对键码的<strong>传递依赖</strong>；</p>
<h5 id="BC范式-BCNF-："><a href="#BC范式-BCNF-：" class="headerlink" title="BC范式(BCNF)："></a>BC范式(BCNF)：</h5><p>如果关系模式R属于第一范式，且<strong>每个属性</strong>都<strong>不传递依赖</strong>于键码，则R属于BC范式；</p>
<h5 id="函数依赖："><a href="#函数依赖：" class="headerlink" title="函数依赖："></a><strong>函数依赖：</strong></h5><p>如果关系R的两个元组在属性A1, A2, …, An上一致，则它们在另一个属性B上也一致。那么，我们就说再关系R中属性B函数依赖于属性A1, A2, …, An。也可以说是”A1, A2, …, An 函数决定B”。其中，A1, A2, …, An称为决定因素。</p>
<p><strong>示例：</strong></p>
<p>考虑学生关系Student，该关系中所涉及的属性包括学生的学号Sno，姓名Sname，所在系Sdept，系主任姓名Mname，课程名Cname和成绩Grade。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/Student.jpg" alt="student"></p>
<p>由于一个学号只对应一个学生，一个学生只在一个系，因而当“学号”确定之后，姓名及其所在系也就唯一的确定了。</p>
<p>因此说Sno函数决定Sname和Sdept，或者说Sname和Sdept函数依赖于Sno。记作Sno-&gt;Sname，Sno-&gt;Sdept。</p>
<h5 id="关系键码："><a href="#关系键码：" class="headerlink" title="关系键码："></a>关系键码：</h5><p>如果一个或多个属性的集合<code>(A1, A2, ..., An)</code>满足如下条件，则称该集合为关系R的键码(key)：</p>
<ul>
<li>这些属性函数决定该关系的其他属性。也就是说，R中不可能有两个不同的元组，它们在<code>A1, A2, ..., An</code>上的取值完全相同；</li>
<li><code>{A1, A2, ..., An}</code>的任何真子集都不能函数决定R的所有其他属性，也就是说，键码必须是最小的。</li>
</ul>
<p>键码所在的属性称为主属性，键码以外的属性称为非主属性。</p>
<p><strong>示例：</strong></p>
<p>在学生关系Student中，属性集<code>{Sno, Cname}</code>构成Student的键码。</p>
<h5 id="函数依赖规则："><a href="#函数依赖规则：" class="headerlink" title="函数依赖规则："></a>函数依赖规则：</h5><ul>
<li><p>分解/合并规则：</p>
<p>我们可以把一个函数依赖<code>A1A2...An -&gt; B1B2...Bm</code>用一组函数依赖<code>A1A2...An -&gt; Bi(i=1, 2, ..., m)</code>来代替。这种转换称为“分解规则”；</p>
<p>我们也可以把一组函数依赖<code>A1A2...An -&gt; Bi(i=1, 2, ..., m)</code>用一个函数依赖<code>A1A2...An -&gt; B1B2...Bm</code>来代替，这种转换称为”合并规则”； </p>
</li>
<li><p>平凡依赖规则：</p>
<p>对于函数依赖<code>A1A2...An -&gt; B</code>，如果B是A中的某一个，则称之为“平凡的”。</p>
<p>函数依赖<code>A1A2...An -&gt; B1B2...Bm</code>等价于<code>A1A2...An -&gt; C1C2...Ck</code>，其中C是B的子集，但不在A中出现。我们称这个规则为“平凡依赖规则”。</p>
</li>
<li><p>传递规则：</p>
<p>如果<code>A1A2...An -&gt; B1B2...Bm</code>和<code>B1B2...Bm -&gt; C1C2...Ck</code>在关系R中成立，则<code>A1A2...An -&gt; C1C2...Ck</code>在R中也成立。这个规则就称为”传递规则“。</p>
</li>
</ul>
<h5 id="完全依赖与部分依赖："><a href="#完全依赖与部分依赖：" class="headerlink" title="完全依赖与部分依赖："></a>完全依赖与部分依赖：</h5><p>对应函数依赖W -&gt; A，如果存在V(V是W的真子集)而函数依赖V -&gt; A成立，则称A部分依赖于W；否则，若不存在这种V，则称A完全依赖于W。</p>
<p>在一个关系模式中，当存在非主属性属性对键码的部分依赖时，就会产生数据冗余和更新异常。比如上述的Student关系示例，对键码部分依赖的属性Sname，Sdept和Mname由于只函数依赖于Sno，因此当一个学生选修几门课时，这些数据就会多次重复出现，造成大量数据冗余；另一方面，当对一个学生的基本情况(学号、姓名、所在系)进行更新时，又会出现更新异常。</p>
<h5 id="传递依赖："><a href="#传递依赖：" class="headerlink" title="传递依赖："></a>传递依赖：</h5><p>对于函数依赖X -&gt; Y，如果Y -/-&gt; X(X不函数依赖于Y)而函数依赖Y-&gt;Z成立，则称Z对X传递依赖。</p>
<p>在学生关系中，Sno-&gt;Sdept，Sdept-&gt;Mname，Sno-&gt;Mname，Mname传递依赖于Sno。可以看出，当一个学生选修多门课时，系主任的名字也会多次重复出现；当对学生的基本情况进行更新时，同样会出现类似的更新异常。</p>
<h4 id="二、数据库隔离级别"><a href="#二、数据库隔离级别" class="headerlink" title="二、数据库隔离级别"></a>二、数据库隔离级别</h4><h5 id="三种异常现象："><a href="#三种异常现象：" class="headerlink" title="三种异常现象："></a>三种异常现象：</h5><ul>
<li>脏读(Dirty Read)</li>
</ul>
<p>事务T1修改了一个数据，事务T2在T1 commit或者rollback前读取了该数据，如果T1最终执行了rollback，T2将会读到一个不存在的数据。</p>
<ul>
<li>不可重复读(Non-repeatable Read)</li>
</ul>
<p>事务T1读取一个数据，之后事务T2修改了这个数据并且commit了，那么如果T1再次读取这个数据，将读不到该数据或者读到一个修改过的数据。</p>
<ul>
<li>幻读(Phantom)</li>
</ul>
<p>事务T1读取了一些满足某个条件的数据，之后事务T2插入或者删除了满足这个条件的一些数据并且Commit，如果T1再次按照该条件读取数据，将会读到和第一次不一样的数据。</p>
<h5 id="四种隔离级别："><a href="#四种隔离级别：" class="headerlink" title="四种隔离级别："></a>四种隔离级别：</h5><table>
<thead>
<tr>
<th>级别名</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交<br />(Read Uncommited)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读已提交<br />(Read Commited)</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读<br />(Repeatable Read)</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化<br />(Serializable)</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<ul>
<li>读未提交(Read Uncommited)  </li>
</ul>
<p>一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而且还能看到其他事务没有提交的对已有记录的更新。</p>
<ul>
<li>读已提交(Read Commited)</li>
</ul>
<p>一个事务在执行过程中可以看到其他事务已经提交过的新插入的记录，而且还能看到其他事务已经提交的对已有记录的更新。</p>
<ul>
<li>可重复读(Repeatable Read)</li>
</ul>
<p>一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务已经提交的对已有记录的更新。</p>
<ul>
<li>串行化(Serializable)</li>
</ul>
<p>一个事务执行过程中完全看不到其他事务对数据库所做的更新。当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。因此，这两个事务实际上是串行化方式运行。         </p>
<p>MySQL默认的事务隔离级别是<strong>可重复读(Repeatable Read)</strong>；</p>
<p>TiDBi默认的事务隔离级别是<strong>可重复读(Repeatable Read)</strong>；</p>
<h5 id="基于锁的实现："><a href="#基于锁的实现：" class="headerlink" title="基于锁的实现："></a>基于锁的实现：</h5><p>数据库管理系统提供的基本类型有两种：排它锁(exclusive lock, 简记为X锁)以及共享锁(share lock, 简记为S锁)。</p>
<p>若事务T对数据对象A加了X锁，则T就可以对A进行读取以及更新(X锁因此又称为写锁)；在T释放A上的X锁之前，任何其他事务都不能再对A加任何类型的锁，从而也不能读取和更新A。</p>
<p>若事务T对A加了S锁，则T就可以对A进行读取，但不能进行更新(S锁因此又称为读锁)，在T释放A上的S锁之前，其他事务可以再对A加S锁，但不能加X锁，从而可以读取A，但不能更新A。</p>
<h5 id="三级封锁协议："><a href="#三级封锁协议：" class="headerlink" title="三级封锁协议："></a>三级封锁协议：</h5><ul>
<li>1级封锁协议</li>
</ul>
<p>事务T在修改数据A之前必须对先对其加X锁，直到事务结束（提交或者回滚）才释放该锁。</p>
<p>1级封锁协议不要求事务在读数据之前加锁，这样“不可重复读”和“脏读”仍有可能发生。</p>
<ul>
<li>2级封锁协议</li>
</ul>
<p>在1级封锁协议的基础上加上这样的约定：事务T在读取A之前必须对其加S锁，读入该数据后即可立即释放S锁。</p>
<p>2级封锁协议避免了“脏读”，不能避免“不可重复读”。</p>
<ul>
<li>3级封锁协议</li>
</ul>
<p>在1级封锁协议的基础上加上这样的约定：事务T在读取A之前必须对其加S锁，直到事务结束（提交或者回滚）才生释放S锁。</p>
<p>3级封锁协议即避免了“脏读”，又避免了“不可重复读”。</p>
<h5 id="两段锁协议："><a href="#两段锁协议：" class="headerlink" title="两段锁协议："></a>两段锁协议：</h5><p>事务T在对数据A进行读或写之前，必须先获得对A的封锁，并且在释放一个封锁之后，T不能再获得任何其他锁。这就是“两段”锁的含义：事务分成获得封锁和释放封锁即加锁和解锁两个阶段。</p>
<h5 id="基于MVCC的实现："><a href="#基于MVCC的实现：" class="headerlink" title="基于MVCC的实现："></a>基于MVCC的实现：</h5>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>面试基础知识</tag>
        <tag>计算机基础</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>拼多多视频一面面经</title>
    <url>/2020/08/11/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E8%A7%86%E9%A2%91%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>拼多多提前批，视频面试。20:00-21:00。</p>
<hr>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>自我介绍</p>
</li>
<li><p>问项目：描述、职责、难点、待解决问题</p>
</li>
<li><p>毕业论文：方向、内容</p>
</li>
<li><p>熟悉的语言</p>
</li>
<li><p>代码题：读取一个文件，文件中每行是一个 网关+地址(1.1.10/24 BeiJing)，然后给定一个ip，求所属地区。（时间复杂度不能是线性）</p>
</li>
<li><p>死锁描述</p>
</li>
<li><p>死锁避免</p>
</li>
<li><p>快排平均时间复杂度/最坏的时间复杂度，为什么</p>
</li>
<li><p>如何调研毕业论文方向（“计划管理“）的</p>
</li>
<li><p>反问：</p>
<ul>
<li>部门、项目的技术栈</li>
<li>面试建议</li>
</ul>
</li>
<li><p>中间还有什么想不起来了</p>
</li>
</ul>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>面试官好像对我的项目很感兴趣，项目问了将近半个小时，还让我把项目成果展示给他看，问答过程中回答的感觉还可以，毕竟自己刚做的，还很熟悉。</p>
<p>算法题刚开始说了下思路，面试官嫌时间复杂度是O(n)，让优化一下，结果卡死在这里，想先试着说下思路，面试官说先写代码吧，写了半天卡住了，后面就先跳过了。</p>
<p>面试过程中，面试官几乎没有引导，回答不了就过，体验很不舒服。不过，说到底还是自己太菜。</p>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>视频面试</tag>
        <tag>拼多多</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动视频二面面经</title>
    <url>/2020/07/21/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%A7%86%E9%A2%91%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>字节跳动提前批二面，视频面试。2020-7-19 14:10开始，持续40分钟。</p>
<hr>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>自我介绍</li>
<li>最近做过的数据库的项目（背景、方案、难点、收获）</li>
<li>项目讨论了很长时间</li>
<li>Python 闭包</li>
<li>Python 装饰器</li>
<li>手写一个可以打印函数执行时间的装饰器</li>
<li>HTTPS与HTTP的区别</li>
<li>HTTPS的通信过程</li>
<li>SSL/公钥</li>
<li>500系列的HTTP状态码的含义</li>
<li>数据库隔离级别概念、解决的问题、使用什么方式实现</li>
<li>MySQL与PG分别是哪种</li>
<li>二叉树的右视图</li>
</ul>
<ul>
<li>反问</li>
</ul>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>项目表述不清楚；</p>
<p>专业问题了解的不深入，可以聊聊概念，不清楚原理；</p>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
        <tag>视频面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动视频一面面经</title>
    <url>/2020/07/06/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%A7%86%E9%A2%91%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>字节跳动提前批一面，视频面试。2020-07-06 19:30开始，持续40分钟左右。</p>
<hr>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>自我介绍</li>
<li>做过哪些项目</li>
<li>主要使用的语言</li>
<li>代码题：<ul>
<li>求二叉树的深度(递归/迭代)</li>
<li>判断回文链表</li>
<li>SQL题：Person表中有id/email两列，找重复邮箱</li>
</ul>
</li>
<li>浏览器从输入URL按下回车到显示页面的过程</li>
<li>常见的HTTP状态码</li>
<li>如何标识一个TCP连接，端口号的作用，TCP位于哪一层</li>
<li>做过的项目</li>
<li>什么是SSH？java还有哪些web框架</li>
<li>常见排序算法/算法复杂度</li>
<li>对于一个基本排好序的数组，使用哪种排序算法比较好</li>
<li>数据库索引相关：有一个组合索引(id， phone)，查找phone=123的记录，会不会使用到索引</li>
</ul>
<ul>
<li>反问：你们部门业务目前使用的技术栈</li>
</ul>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>面试官人挺不错，刚开始算法题，由于不熟悉标准输入输出，还给换了道题。但是做完题之后也没有要求更多的优化，明明不是最优解，却不想之前那样提示着一步一步进行优化。其他问题也是，回答了之后，也没有问的特别深。</p>
<p>总体感觉不是很难，但自己回答的应该不准确。</p>
<p>期望还有二面，二面一定好好准备。</p>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
        <tag>视频面试</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL内核-添加自定义系统函数</title>
    <url>/2020/05/07/PostgreSQL%E5%86%85%E6%A0%B8-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>最近在做的项目是要在PG数据库上兼容实现Oracle的部分功能，其中一个点就是在PG上去兼容Oracle的四个正则表达式函数，分别是：</p>
<ul>
<li>regexp_count()</li>
<li>regexp_substr()</li>
<li>regexp_instr()</li>
<li>regexp_replace()</li>
</ul>
<p>实现的方式就是在PG中添加同名的内置系统函数，并实现相应功能。</p>
<p>本文的重点在于介绍如何在PG中添加自定义的函数作为内置系统函数，而不是如何实现相关函数。接下来将以兼容实现<code>regexp_count()</code>函数为例进行说明。</p>
<hr>
<h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><h4 id="Oid："><a href="#Oid：" class="headerlink" title="Oid："></a>Oid：</h4><p>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type <code>oid</code> represents an object identifier.</p>
<h4 id="pg-proc系统表："><a href="#pg-proc系统表：" class="headerlink" title="pg_proc系统表："></a>pg_proc系统表：</h4><p>在PG中，所有内置系统函数的基本信息都保存在<code>pg_proc</code>系统表中，每个函数都对应一个<code>Oid</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select oid,proname from pg_proc limit 10; </span></span><br><span class="line"> oid  | proname  </span><br><span class="line">------+----------</span><br><span class="line"> 1242 | boolin</span><br><span class="line"> 1243 | boolout</span><br><span class="line"> 1244 | byteain</span><br><span class="line">   31 | byteaout</span><br><span class="line"> 1245 | charin</span><br><span class="line">   33 | charout</span><br><span class="line">   34 | namein</span><br><span class="line">   35 | nameout</span><br><span class="line">   38 | int2in</span><br><span class="line">   39 | int2out</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<h4 id="函数注册："><a href="#函数注册：" class="headerlink" title="函数注册："></a>函数注册：</h4><p>假设我们已经实现了一个自定义函数，比如<code>regexp_count()</code>，PG如何才能知道该函数的存在呢？答案是通过函数注册实现。</p>
<p>需要将自定义函数的相关信息添加到<code>src/include/catalog/pg_prco.dat</code>中，在PG编译时，perl脚本会根据<code>pg_proc.dat</code>文件生成<code>src/backend/catalog/postgres.bki</code>文件，该文件在执行<code>initdb</code>被解析成一条条的SQL语句，并插入到系统表<code>pg_proc</code>中。</p>
<hr>
<h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h3><h4 id="第一步：函数定义及实现"><a href="#第一步：函数定义及实现" class="headerlink" title="第一步：函数定义及实现"></a>第一步：函数定义及实现</h4><p>经过分析Oracle的<code>regexp_count()</code>函数，根据不同的参数个数，有如下调用形式：</p>
<ul>
<li><p>regexp_count(source_char, pattern)</p>
</li>
<li><p>regexp_count_with_position(source_char, pattern, position)</p>
</li>
<li><p>regexp_count_with_flags(source_char, pattern, position, flags)</p>
</li>
</ul>
<p>函数返回值类型为：<strong>int4</strong>。</p>
<p>实现的代码大致为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Datum</span><br><span class="line">regexp_count(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">text</span>	   *orig_str = PG_GETARG_TEXT_PP(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">text</span>	   *pattern = PG_GETARG_TEXT_PP(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span>        <span class="built_in">position</span> = PG_NARGS() &gt; <span class="number">2</span> ? PG_GETARG_INT32(<span class="number">2</span>) : <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">text</span>	   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(<span class="number">3</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">position</span> &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		ereport(ERROR,</span><br><span class="line">			(errcode(ERRCODE_INVALID_PARAMETER_VALUE),</span><br><span class="line">			errmsg(<span class="string">"argument %d is out of range"</span>, <span class="built_in">position</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	orig_str = text_substring(PG_GETARG_DATUM(<span class="number">0</span>), <span class="built_in">position</span>, <span class="number">-1</span>, <span class="literal">true</span>);			</span><br><span class="line">			</span><br><span class="line">	pg_re_flags re_flags;</span><br><span class="line">	regexp_matches_ctx *matchctx;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Determine options */</span></span><br><span class="line">	<span class="comment">// parse_re_flags(&amp;re_flags, flags);</span></span><br><span class="line">	custom_parse_re_flags(&amp;re_flags, flags);</span><br><span class="line"></span><br><span class="line">	matchctx = setup_regexp_matches(orig_str, pattern, &amp;re_flags,</span><br><span class="line">									PG_GET_COLLATION(), <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	PG_RETURN_INT32((int32)matchctx-&gt;nmatches);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">regexp_count_with_position(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> regexp_count(fcinfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">regexp_count_with_flags(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> regexp_count(fcinfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二步：分配可用OID"><a href="#第二步：分配可用OID" class="headerlink" title="第二步：分配可用OID"></a>第二步：分配可用OID</h4><p>PG提供了<code>unused_oids</code>工具用于快速检索未使用的Oid，该工具位于：<code>src/include/catalog/unused_oids</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">totem@totem-vm:~/SGRDB-AK$ ./src/include/catalog/unused_oids</span><br><span class="line">4 - 9</span><br><span class="line">210</span><br><span class="line">270 - 273</span><br><span class="line">357</span><br><span class="line">380 - 381</span><br><span class="line">421</span><br><span class="line">560 - 583</span><br><span class="line">606</span><br><span class="line">702 - 704</span><br><span class="line">760 - 763</span><br><span class="line">...</span><br><span class="line">6107 - 6109</span><br><span class="line">6116</span><br><span class="line">6122 - 9999</span><br></pre></td></tr></table></figure>

<p>根据列出的未使用的OID范围，为每个函数选择合适的OID，结果如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>OID</th>
</tr>
</thead>
<tbody><tr>
<td>regexp_count</td>
<td>5101</td>
</tr>
<tr>
<td>regexp_count_with_position</td>
<td>5102</td>
</tr>
<tr>
<td>regexp_count_with_flags</td>
<td>5103</td>
</tr>
</tbody></table>
<h4 id="第三步：函数注册"><a href="#第三步：函数注册" class="headerlink" title="第三步：函数注册"></a>第三步：函数注册</h4><p>在文件<code>src/include/catalog/pg_proc.dat</code>中添加如下函数注册信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123; oid =&gt; '5101', descr =&gt; 'find match_count for regexp',</span><br><span class="line">  proname =&gt; 'regexp_count',  prorows =&gt; '1', prorettype =&gt; 'int4',</span><br><span class="line">  proargtypes =&gt; 'text text', prosrc =&gt; 'regexp_count' </span><br><span class="line">&#125;,</span><br><span class="line">&#123; oid =&gt; '5102', descr =&gt; 'find match_count for regexp',</span><br><span class="line">  proname =&gt; 'regexp_count',  prorows =&gt; '1', prorettype =&gt; 'int4',</span><br><span class="line">  proargtypes =&gt; 'text text int4', prosrc =&gt; 'regexp_count_with_position' </span><br><span class="line">&#125;,</span><br><span class="line">&#123; oid =&gt; '5103', descr =&gt; 'find match_count for regexp',</span><br><span class="line">  proname =&gt; 'regexp_count',  prorows =&gt; '1', prorettype =&gt; 'int4',</span><br><span class="line">  proargtypes =&gt; 'text text int4 text', prosrc =&gt; 'regexp_count_with_flags' </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在编译成功后，上面几条记录在<code>postgres.bki</code>中对应的形式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">insert</span> ( <span class="number">5101</span> regexp_count <span class="number">11</span> <span class="number">10</span> <span class="number">12</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> f f f t f i s <span class="number">2</span> <span class="number">0</span> <span class="number">23</span> <span class="string">"25 25"</span> _null_ _null_ _null_ _null_ _null_ regexp_count _null_ _null_ _null_ )</span><br><span class="line"><span class="keyword">insert</span> ( <span class="number">5102</span> regexp_count <span class="number">11</span> <span class="number">10</span> <span class="number">12</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> f f f t f i s <span class="number">3</span> <span class="number">0</span> <span class="number">23</span> <span class="string">"25 25 23"</span> _null_ _null_ _null_ _null_ _null_ regexp_count_with_position _null_ _null_ _null_ )</span><br><span class="line"><span class="keyword">insert</span> ( <span class="number">5103</span> regexp_count <span class="number">11</span> <span class="number">10</span> <span class="number">12</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> f f f t f i s <span class="number">4</span> <span class="number">0</span> <span class="number">23</span> <span class="string">"25 25 23 25"</span> _null_ _null_ _null_ _null_ _null_ regexp_count_with_flags _null_ _null_ _null_ )</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="第四步：添加函数到PG源码"><a href="#第四步：添加函数到PG源码" class="headerlink" title="第四步：添加函数到PG源码"></a>第四步：添加函数到PG源码</h4><p>将自定义函数代码添加到合适的源代码文件中，这里将<code>regexp_count()</code>函数代码添加到了<code>src/backend/utils/adt/regex.c</code>文件中。</p>
<h4 id="第五步：编译安装"><a href="#第五步：编译安装" class="headerlink" title="第五步：编译安装"></a>第五步：编译安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="第六步：初始化、启动数据库"><a href="#第六步：初始化、启动数据库" class="headerlink" title="第六步：初始化、启动数据库"></a>第六步：初始化、启动数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./initdb -D ../data</span><br><span class="line">./pg_ctl -D ../data start</span><br><span class="line">./createdb <span class="built_in">test</span></span><br><span class="line">./psql <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="第七步：验证："><a href="#第七步：验证：" class="headerlink" title="第七步：验证："></a>第七步：验证：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>=<span class="comment"># select regexp_count('abc'||CHR(10)||'ABC', 'abc');</span></span><br><span class="line"> regexp_count </span><br><span class="line">--------------</span><br><span class="line">            1</span><br><span class="line">(1 row)</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select regexp_count('abc'||CHR(10)||'ABC', 'abc', 2);</span></span><br><span class="line"> regexp_count </span><br><span class="line">--------------</span><br><span class="line">            0</span><br><span class="line">(1 row)</span><br><span class="line"><span class="built_in">test</span>=<span class="comment"># select regexp_count('abc'||CHR(10)||'ABC', 'abc', 1, 'i');</span></span><br><span class="line"> regexp_count </span><br><span class="line">--------------</span><br><span class="line">            2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://www.postgresql.org/docs/12/functions-string.html" target="_blank" rel="noopener">PG-9.4. String Functions and Operators</a></li>
<li><a href="https://www.postgresql.org/docs/12/functions-matching.html#FUNCTIONS-POSIX-REGEXP" target="_blank" rel="noopener">PG-9.7. Pattern Matching</a></li>
<li><a href="https://www.postgresql.org/docs/12/catalog-pg-proc.html" target="_blank" rel="noopener">PG-51.39. pg_proc</a></li>
<li><a href="https://docs.oracle.com/database/121/SQLRF/functions161.htm#SQLRF20014" target="_blank" rel="noopener">Oracle-REGEXP_COUNT</a></li>
<li><a href="https://www.postgresql.org/docs/12/catalog-pg-proc.html" target="_blank" rel="noopener">PG-51.39. pg_proc</a></li>
<li><a href="https://docs.oracle.com/database/121/ADFNS/adfns_regexp.htm#ADFNS1003" target="_blank" rel="noopener">Oracle-Using Regular Expressions in Database Applications</a></li>
<li><a href="https://www.postgresql.org/docs/current/datatype-oid.html" target="_blank" rel="noopener">PG-8.19. Object Identifier Types</a></li>
<li><a href="http://blog.itpub.net/6906/viewspace-2642750/" target="_blank" rel="noopener">PostgreSQL 源码解读（180）- 内核研发#4(如何实现自定义系统函数)</a></li>
</ul>
<blockquote>
<p>文中有什么错误或者不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
        <tag>数据库内核开发</tag>
        <tag>兼容Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内存管理机制</title>
    <url>/2020/04/13/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>在之前的面试中有被问到Python的内存管理机制，回答的不好，之后查阅了一些文章，这里简单做下总结。Python的内存管理机制主要包含以下几个方面：</p>
<ul>
<li>引用计数</li>
<li>垃圾回收</li>
<li>内存池机制</li>
</ul>
<hr>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>在Python中，一切皆可视为对象。对每一个对象，都维护了一个指向该对象的引用总数，即引用计数。我们可以使用<code>sys</code>包中的<code>getrefcount()</code>来查看指定对象的引用计数。需要注意的是，<code>getrefcount()</code>函数本身会为参数中对象创建一个引用。因此，<code>getrefcount()</code>的返回值会比期望的多1个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">print(getrefcount(a))  <span class="comment"># 结果为3而不是2</span></span><br></pre></td></tr></table></figure>

<h4 id="引用计数增加："><a href="#引用计数增加：" class="headerlink" title="引用计数增加："></a>引用计数增加：</h4><ul>
<li>对象被创建：<code>a = [1, 2, 3]</code> </li>
<li>对象被赋值给其他变量：<code>b = a</code></li>
<li>被作为参数传递给函数：<code>func(a)</code></li>
<li>作为容器对象中的一个元素：<code>b = [a, a]</code></li>
</ul>
<h4 id="引用计数减少："><a href="#引用计数减少：" class="headerlink" title="引用计数减少："></a>引用计数减少：</h4><ul>
<li>一个本地引用离开了它的作用域。比如上面的<code>func(a)</code>函数结束时，<code>a</code>指向的对象引用减1。</li>
<li>对象的别名被显示的销毁：<code>del a</code>。</li>
<li>对象的一个别名被赋值给其他对象：如上面置<code>b = [2, 3, 4]</code>，那么<code>a</code>指向的对象引用减1。</li>
<li>对象从一个容器对象中移除：<code>b.remove(a)</code></li>
<li>容器对象本身被销毁：<code>del b</code>；或者容器对象本身离开了作用域。</li>
</ul>
<h4 id="引用环："><a href="#引用环：" class="headerlink" title="引用环："></a>引用环：</h4><p>两个对象可能相互引用，或者一个对象自己引用自己，从而造成所谓的<strong>引用环</strong>(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相互引用</span></span><br><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自身引用</span></span><br><span class="line">a = []</span><br><span class="line">a.append(a)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Python为每个对象维护着引用计数，当某个对象的引用计数为0时，说明没有任何引用指向该对象，即用户不能通过任何方式接触或者运用这个对象。那么这个对象就成为了要被回收的垃圾。</p>
<p>在进行垃圾回收时，Python不能进行其它人任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要立刻启动垃圾回收。所以，Python只会在特定的条件下启动垃圾回收。</p>
<p>在Python运行时，会记录其中<strong>分配对象</strong>(object allocation)和<strong>取消分配对象</strong>(object deallocation)的次数，当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>此阈值可以通过<code>gc</code>模块的<code>get_threshold()</code>函数查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())  <span class="comment"># (700, 10, 10)</span></span><br></pre></td></tr></table></figure>

<p>返回（700， 10， 10）。其中700即是垃圾回收启动的阈值，后面的两个10是与<strong>分代回收</strong>相关的阈值。可以通过<code>gc</code>模块中的<code>set_threshold()</code>函数重新设置。</p>
<p>我们也可以使用<code>gc.collect()</code>函数手动启动垃圾回收。</p>
<h4 id="分代回收："><a href="#分代回收：" class="headerlink" title="分代回收："></a>分代回收：</h4><p>Python同时采用了<strong>分代回收</strong>(generation)的策略。这一策略的假设是：存活时间越久的对象，越不可能在后面的程序中变成垃圾。</p>
<p>我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这些<em>长寿</em>的对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过<strong>一定次数</strong>的垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了<strong>一定次数</strong>的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即为上面<code>get_threshold()</code>函数结果中的两个值。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以使用<code>set_threshold()</code>来调整。</p>
<h4 id="引用环：-1"><a href="#引用环：-1" class="headerlink" title="引用环："></a>引用环：</h4><p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">b = [a]</span><br><span class="line">a.append(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>

<p>上面我们先创建了两个列表对象，并相互引用对方，构成了一个引用环。删除了a, b引用之后，这两个对象都不能再从程序中调用，就没什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200413214658.png" alt=""></p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为<code>gc_ref</code>。假设，每个对象i，该计数为<code>gc_ref_i</code>。Python会遍历所有的对象i。对于每个对象i引用对象j，将相应的<code>gc_ref_j</code>减1。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200413214933.png" alt=""></p>
<p>在结束遍历后，<code>gc_ref</code>不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<hr>
<h3 id="内存池机制"><a href="#内存池机制" class="headerlink" title="内存池机制"></a>内存池机制</h3><p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200413215259.png" alt=""></p>
<p>Python的内存机制呈金字塔型：</p>
<ul>
<li>-1，-2层主要由操作系统进行操作。</li>
<li>第0层是C中的<code>malloc()</code>、<code>free()</code>等内存分配和释放函数进行操作。</li>
<li>第1层和第2层是内存池，由Python的接口函数<code>PyMem_API</code>函数实现，当对象小于256K时由该层直接分配内存。</li>
<li>第3层是最上层，也就是我们对Python对象的直接操作。</li>
</ul>
<p>在C中如果频繁的调用<code>malloc()</code>与<code>free()</code>，是会产生性能问题的。再加上频繁的分配与释放小块内存会产生内存碎片。</p>
<ul>
<li><p>经由内存池登记的内存到最后还是会回收到内存池，并不会调用<code>free()</code>释放掉，以便下次使用。</p>
</li>
<li><p>对于一些特定的Python对象，例如<code>int</code>，<code>string</code>、<code>list</code>、<code>dict</code>等，会分别有专门的内存来存储，即这些内存只能存储指定类型的对象。</p>
</li>
</ul>
<hr>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="https://www.cnblogs.com/CBDoctor/p/3781078.html" target="_blank" rel="noopener">python的内存管理机制</a></li>
<li><a href="https://www.cnblogs.com/vamei/p/3232088.html" target="_blank" rel="noopener">Python深入06 Python的内存管理</a></li>
<li><a href="https://docs.python.org/zh-cn/3.6/c-api/memory.html" target="_blank" rel="noopener">内存管理</a></li>
</ul>
<blockquote>
<p>文中有什么错误或者不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基本数据类型defaultdict</title>
    <url>/2020/04/05/Python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bdefaultdict/</url>
    <content><![CDATA[<h3 id="字典中的KeyError异常"><a href="#字典中的KeyError异常" class="headerlink" title="字典中的KeyError异常"></a>字典中的KeyError异常</h3><p>Python中字典（Dict）这种数据类型是通过键值（key）来存取的，当使用一个不存在的键值取值时，会引发<code>keyerror</code>异常。为避免这种情况，有以下几种方法：</p>
<ul>
<li>判断是否存在此键值</li>
<li>使用<code>dict.setdefault()</code>设置默认值</li>
<li>使用<code>collections</code>模块中的<code>defaultdict</code>数据类型来代替默认的<code>dict</code></li>
</ul>
<hr>
<h4 id="判断是否存在"><a href="#判断是否存在" class="headerlink" title="判断是否存在"></a>判断是否存在</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">        d[key].append(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[key] = []</span><br><span class="line">        d[key].append(value)</span><br><span class="line">print(d)  <span class="comment"># &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="dict-setdefault"><a href="#dict-setdefault" class="headerlink" title="dict.setdefault()"></a>dict.setdefault()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    d.setdefault(key, []).append(value)</span><br><span class="line">print(d)  <span class="comment"># &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>dict.setdefault()</code>方法接收两个参数，一个是键的名称，另一个是默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setdefault</span><span class="params">(self, *args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Insert key with a value of default if key is not in the dictionary. </span></span><br><span class="line"><span class="string">    Return the value for key if key is in the dictionary, else default.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict()"></a>collections.defaultdict()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    d[key].append(value)</span><br><span class="line">print(d)  <span class="comment"># defaultdict(&lt;class 'list'&gt;, &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="collections-defaultdict模块介绍："><a href="#collections-defaultdict模块介绍：" class="headerlink" title="collections.defaultdict模块介绍："></a>collections.defaultdict模块介绍：</h3><p><code>defaultdict</code>是<code>dict</code>的一个子类，可以实现为不存在的键值返回一个默认值。</p>
<ul>
<li><strong>default_factory</strong></li>
</ul>
<p><code>defaultdict</code>在初始化时可以提供一个<code>default_factory</code>的参数。<code>default_factory</code>接收一个工厂函数作为参数，可以是<code>int()/str()/list()</code>等内置函数，也可以是自定义函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, default_factory=None, **kwargs)</span>:</span> <span class="comment"># known case of _collections.defaultdict.__init__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    defaultdict(default_factory[, ...]) --&gt; dict with default factory</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    The default factory is called without arguments to produce</span></span><br><span class="line"><span class="string">    a new value when a key is not present, in __getitem__ only.</span></span><br><span class="line"><span class="string">    A defaultdict compares equal to a dict with the same items.</span></span><br><span class="line"><span class="string">    All remaining arguments are treated the same as if they were</span></span><br><span class="line"><span class="string">    passed to the dict constructor, including keyword arguments.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    # (copied from class doc)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">default_factory = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"><span class="string">"""Factory for default value called by __missing__()."""</span></span><br></pre></td></tr></table></figure>

<p><code>defaultdict</code>可以通过类属性<code>default_factory</code>来查看此工厂函数的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = collections.defaultdict(list)</span><br><span class="line">print(d.default_factory)  <span class="comment"># &lt;class 'list'&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>__missing__(key)</strong></li>
</ul>
<p><code>defaultdict</code>在<code>dict</code>的基础上添加了一个<code>__missing__(key)</code>方法，在调用一个不存的key的时候， <code>defaultdict</code>会调用<code>__missing__()</code>，根据<code>default_factory</code>参数创建一个实例，作为此<code>key</code>的默认值返回。如果初始化时<code>default_factory</code>参数为空，仍然会引发<code>KeyError</code>异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    __missing__(key) # Called by __getitem__ for missing key; pseudo-code:</span></span><br><span class="line"><span class="string">      if self.default_factory is None: raise KeyError((key,))</span></span><br><span class="line"><span class="string">      self[key] = value = self.default_factory()</span></span><br><span class="line"><span class="string">      return value</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="使用自定义函数作为工厂函数"><a href="#使用自定义函数作为工厂函数" class="headerlink" title="使用自定义函数作为工厂函数"></a>使用自定义函数作为工厂函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># ("color", id):  指定小球的颜色以及Id</span></span><br><span class="line">s = [(<span class="string">"black"</span>, <span class="number">1</span>), (<span class="string">"red"</span>, <span class="number">2</span>), (<span class="string">"yellow"</span>, <span class="number">3</span>), (<span class="string">"black"</span>, <span class="number">4</span>), (<span class="string">"yellow"</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计各种颜色小球的出现</span></span><br><span class="line">d = collections.defaultdict(custom_function)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> s:</span><br><span class="line">    d[key].append(value)</span><br><span class="line">print(d)  <span class="comment"># defaultdict(&lt;function custom_function at 0x0000017038C7C1E0&gt;, &#123;'black': [1, 4], 'red': [2], 'yellow': [3, 5]&#125;)</span></span><br><span class="line">print(d.default_factory)  <span class="comment"># &lt;function custom_function at 0x00000247FD18C1E0&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用lambda函数"><a href="#使用lambda函数" class="headerlink" title="使用lambda函数"></a>使用lambda函数</h4><p>使用匿名函数（lambda function）可以更快、更灵活的创建常值函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constant_factory</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: value</span><br><span class="line"></span><br><span class="line">d = collections.defaultdict(constant_factory(<span class="string">'&lt;missing&gt;'</span>))</span><br><span class="line">d.update(name=<span class="string">'John'</span>, action=<span class="string">'ran'</span>)</span><br><span class="line">print(<span class="string">'%(name)s %(action)s to %(object)s'</span> % d)  <span class="comment"># John ran to &lt;missing&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>dict</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里测开电话二面面经</title>
    <url>/2020/04/01/%E9%98%BF%E9%87%8C%E6%B5%8B%E5%BC%80%E7%94%B5%E8%AF%9D%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>2020/03/27参加了阿里的笔试，30号电话约了面试，31号晚19:30-20:20完成了第一轮的电话面试，4月1号晚20:50-21:30完成了第二轮电话面试。</p>
<hr>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>自我介绍</li>
<li>问了问学校开学情况</li>
<li>学校专硕的要求，时间</li>
<li>项目（背景、功能、任务）</li>
<li>本科毕设提了下</li>
<li>数据结构堆栈、队列</li>
<li>算法题：两个堆栈实现一个队列</li>
<li>算法题：将数字n拆分，打印所有的可能</li>
<li>使用的语言（Python），Java用过吗？</li>
<li>服务器如何记录用户的状态（cookie 与 session）</li>
<li>负载均衡</li>
<li>负载均衡的算法</li>
<li>反问环节</li>
</ul>
<p>还有些记不得了，问题顺序大致就是上面的顺序。</p>
<hr>
<h3 id="感受："><a href="#感受：" class="headerlink" title="感受："></a>感受：</h3><p>这次项目问的多一点，算法题第二题回答的不好，花费了很长时间。</p>
<p>反问的时候，问了下面试官有什么评价，有什么提升的建议。这次面试官的回答有点让人猜不到大致结果，一会儿说我的基础应该不错，一会说要补充一下哪些哪些基础。建议多参加竞赛。提了下简历的问题，要把专利和软件著作权写上去。</p>
<p>自我感觉：还是要多做算法题，加快解题的时间。要加强描述能力，第一题很简单，可能是没有描述清楚，面试官追问了几次。</p>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>阿里</tag>
        <tag>电话面试</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里测开电话一面面经</title>
    <url>/2020/03/31/%E9%98%BF%E9%87%8C%E6%B5%8B%E5%BC%80%E7%94%B5%E8%AF%9D%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>2020/03/27参加了阿里的笔试，30号电话约了面试，31号晚19:30-20:20完成了第一轮的电话面试。</p>
<hr>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>自我介绍</p>
</li>
<li><p>Python内存管理</p>
</li>
<li><p>Python函数定义</p>
</li>
<li><p>在函数内设置/引用全局变量</p>
</li>
<li><p>Python except 关键字及异常处理，举例</p>
</li>
<li><p>python filter 函数</p>
</li>
<li><p>常用排序算法介绍</p>
</li>
<li><p>乐观锁、悲观锁</p>
</li>
<li><p>介绍一下项目（遇到的难点，如何解决的，负责的模块，软件界面使用的模块）</p>
</li>
<li><p>http与https</p>
</li>
<li><p>数据库索引</p>
</li>
<li><p>数据库为什么使用B+树做索引</p>
</li>
<li><p>sql语句，在表中查询不包含某个字段的记录</p>
</li>
<li><p>为什么做数据库，给你带来了什么，兴趣在哪里</p>
</li>
<li><p>为什么选择测试岗位。</p>
</li>
<li><p>TCP三次连接的过程</p>
</li>
<li><p>为百度搜索设计测试用例</p>
</li>
<li><p>算法题：两个长度为n的序列A和B，交换A和B中的元素，使得序列A元素总和与序列B元素总和差值最小。</p>
</li>
<li><p>同学怎么评价你</p>
</li>
<li><p>有什么成果（比赛、论文）</p>
</li>
<li><p>比较遗憾的事情</p>
</li>
<li><p>最大的优点</p>
</li>
<li><p>喜欢写代码吗</p>
</li>
<li><p>喜欢逛什么技术论坛、看的书</p>
</li>
</ul>
<p>还有些记不得了，问题顺序不是上面的顺序。</p>
<hr>
<h3 id="体验："><a href="#体验：" class="headerlink" title="体验："></a>体验：</h3><p>总体感觉问题问的不是很难，但自己准备的不好，面试过程发挥的也不好，有几个准备了的问题都没答好。</p>
<p>需要补充一下Python的基础知识，底层知识，数据库理论、操作系统等相关内容。</p>
<p>还有，为什么一面问了这么多开放性的非技术问题呀？难道是因为我技术太弱，不想问了吗？</p>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>阿里</tag>
        <tag>电话面试</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题打卡提醒程序实现与部署</title>
    <url>/2020/03/30/leetcode%E5%88%B7%E9%A2%98%E6%89%93%E5%8D%A1%E6%8F%90%E9%86%92%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="前因后果"><a href="#前因后果" class="headerlink" title="前因后果"></a>前因后果</h3><p>今天是3月30号，还差一天 <a href="https://leetcode-cn.com/circle/article/9EZfRE/" target="_blank" rel="noopener">leetcode-cn每日一题</a> 活动就满一个月了，下面这张图是博主这一个月的打卡记录：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/%E6%89%93%E5%8D%A1.png" alt=""></p>
<p>不要问我为什么有一个红叉叉，因为我也记不得当天为什么没有完成打卡了。但是就因为这一个红叉叉，我与下面的打卡奖励就无缘了。</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200330215802.png" alt=""></p>
<p>为了更好的完成打卡任务，以及养成刷题的习惯，今天就写了一个leetcode-cn打卡提醒的程序，并且部署在了服务器上，这里记录一下实现的步骤。</p>
<hr>
<h3 id="打卡程序"><a href="#打卡程序" class="headerlink" title="打卡程序"></a>打卡程序</h3><p>打卡提醒程序的本质是一个定时的爬虫任务，工作原理是：从每天的上午九点开始，去查询一下我的个人提交记录，如果发现了在当天有提交通过的记录，就认为打卡成功了；否则就认为还未打卡，就会给我的邮箱发送一封提醒的邮件，并且会每隔一个小时再去查询一次，直到发现打卡成功或者时间到了23点。</p>
<p>程序主要分为三个部分：</p>
<ul>
<li>爬虫，查询个人提交记录（登录状态）</li>
<li>邮件提醒功能</li>
<li>定时任务功能</li>
</ul>
<h4 id="爬虫，查询提交记录："><a href="#爬虫，查询提交记录：" class="headerlink" title="爬虫，查询提交记录："></a>爬虫，查询提交记录：</h4><ol>
<li><p>通过分析leetcode-cn的 <a href="https://leetcode-cn.com/submissions/#/1" target="_blank" rel="noopener">个人提交记录</a> 界面，可以发现<strong>提交记录数据</strong>是通过Ajax技术加载的，真正的链接如下：</p>
<blockquote>
<p> <a href="https://leetcode-cn.com/api/submissions/?offset=0&amp;limit=20&amp;lastkey=" target="_blank" rel="noopener">https://leetcode-cn.com/api/submissions/?offset=0&amp;limit=20&amp;lastkey=</a></p>
</blockquote>
<p>其中：limit表示每页展示的记录条数，offset来指定页数，为0即为第一页，lastkey在翻页的时候会更新，第一页时此值为空。</p>
<p>由于我们判断是否打卡成功一般只需要第一页的数据，所以使用上面一条链接就足够了，不需要再去构造翻页的链接。</p>
</li>
<li><p>此链接是在<strong>登录状态</strong>下查询<strong>自己的提交记录</strong>的接口，所以需要我们处于登录的状态，使用<strong>Cookie模拟登录</strong>即可。从浏览器复制cookie信息，构造<code>headers</code>，只需如下几个字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;    </span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">'your_cookie_info'</span>,  <span class="comment"># 在这里替换个人的cookie信息    </span></span><br><span class="line">    <span class="string">'referer'</span>: <span class="string">'https://leetcode-cn.com/submissions/'</span>,    </span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'</span>,    </span><br><span class="line">    <span class="string">'x-requested-with'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此链接查询的结果为json形式，直接解析即可，需要的字段有<strong>时间</strong>和<strong>状态</strong>两个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submission_check</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 检查是否打卡</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        submissions = response.json()</span><br><span class="line">        records = submissions[<span class="string">"submissions_dump"</span>]</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># 是否已打卡</span></span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> records:</span><br><span class="line">            sub_time, status = record[<span class="string">"time"</span>], record[<span class="string">"status_display"</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"分钟"</span> <span class="keyword">in</span> sub_time:</span><br><span class="line">                hour = sub_time.split()[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> int(hour) &lt;= <span class="number">9</span> <span class="keyword">and</span> status == <span class="string">"Accepted"</span>:  <span class="comment"># 首次检查在上午九点，筛除前一天的打卡记录</span></span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    print(<span class="string">"已打卡！"</span>)</span><br><span class="line">                    print(sub_time, status)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"未打卡！"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        mail_notice(<span class="string">"cookie已失效，请重新登录！"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h4 id="邮件提醒功能："><a href="#邮件提醒功能：" class="headerlink" title="邮件提醒功能："></a>邮件提醒功能：</h4><p>使用的是python的<code>email</code>模块，根据自定义的邮件提示内容向指定邮箱发送邮件，功能实现较为简单，直接看代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail_notice</span><span class="params">(mes)</span>:</span></span><br><span class="line">    <span class="comment"># 邮件提醒功能</span></span><br><span class="line">    from_addr = <span class="string">"********@qq.com"</span>  <span class="comment"># 替换发件人</span></span><br><span class="line">    to_addr = <span class="string">"********@qq.com"</span>  <span class="comment"># 替换收件人</span></span><br><span class="line">    password = <span class="string">"akyijm********jbi"</span>  <span class="comment"># 替换授权码</span></span><br><span class="line">    smtp_server = <span class="string">"smtp.qq.com"</span>  <span class="comment"># 发件人非QQ邮箱需要替换为对应的邮箱服务地址</span></span><br><span class="line"></span><br><span class="line">    subject = <span class="string">'LeetCode每日打卡提醒!'</span></span><br><span class="line">    msg = MIMEText(<span class="string">'&lt;HTML&gt;&lt;H1&gt;&#123;&#125;&lt;/hi&gt;&lt;/html&gt;'</span>.format(mes), <span class="string">'html'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'From'</span>] = Header(<span class="string">"未来"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'To'</span>] = Header(<span class="string">"现在"</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line">    smtp = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>)</span><br><span class="line">    smtp.login(from_addr, password)</span><br><span class="line">    smtp.sendmail(from_addr, to_addr, msg.as_string())</span><br><span class="line">    smtp.quit()</span><br></pre></td></tr></table></figure>

<h4 id="定时任务功能："><a href="#定时任务功能：" class="headerlink" title="定时任务功能："></a>定时任务功能：</h4><p>使用的是python的<code>schedule</code>模块，指定在每天的上午九点开始执行。另外每隔一个小时执行一次的实现直接采用的<code>time.sleep(60*60)</code>。代码也比较简单，直接看代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        flag = submission_check()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            mail_notice(<span class="string">"今天不要忘了打卡哦！"</span>)  <span class="comment"># 未打卡则发送邮件提醒</span></span><br><span class="line">            cur_hour = time.localtime().tm_hour</span><br><span class="line">            <span class="keyword">if</span> cur_hour == <span class="number">23</span>:   <span class="comment"># 时间超过23:00 今日不再提醒</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">60</span>*<span class="number">60</span>)  <span class="comment"># 一小时后再检查</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    schedule.every().day.at(<span class="string">"09:00"</span>).do(job)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        schedule.run_pending()</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="程序部署"><a href="#程序部署" class="headerlink" title="程序部署"></a>程序部署</h3><p>本来想将程序直接挂在自己电脑上一直运行的，但一直以来都想折腾一下服务器，然后就看了下阿里云，发现服务器正在做活动，价格还可以接受，就买了一个准备折腾一下。没有服务器的话，还是运行在自己电脑上吧。对于一台全新的服务器，部署过程如下：</p>
<ol>
<li><p>使用root用户登录（阿里云买了之后只有root用户，需要在控制台管理界面设置下root用户的密码才能登录）后，创建一个新用户，并赋予相应的权限。（也可以使用root用户配置，但不推荐）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd -m newuser  <span class="comment"># 创建用户,-m表示自动创建用户的登入目录</span></span><br><span class="line">sudo passwd newuser  <span class="comment"># 为新建的用户创建密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的用户加入sudo组sudo </span></span><br><span class="line">chmod +w /etc/sudoers  <span class="comment"># /etc/sudoers文件只有读权限，先赋予写权限</span></span><br><span class="line">sudo vim /etc/sudoers  </span><br><span class="line"><span class="comment"># 编辑此文件，在 root　ALL=(ALL:ALL) ALL行下面添加 newuser ALL=(ALL:ALL) ALL</span></span><br><span class="line">sudo chmod -w /etc/sudoers  <span class="comment"># 将/etc/sudoers文件的权限改为只读权限</span></span><br><span class="line"></span><br><span class="line">su newuser  <span class="comment"># 切换到新用户</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装环境依赖，主要包括<code>requests</code>以及<code>schedule</code>模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install requests schedule</span><br></pre></td></tr></table></figure>
</li>
<li><p>将程序文件拷贝到服务器合适位置，博主直接使用的<code>xftp</code>传输的，放在了用户目录下。</p>
</li>
<li><p>开通阿里云服务器的<code>465</code>端口</p>
<p>之所以在邮件提醒功能中使用的邮件服务端口是<code>465</code>端口，是因为阿里云服务器屏蔽了<code>25</code>端口，申请开通的步骤比较麻烦，需要域名等其他的要求，所以直接采用了<code>465</code>端口。基本配置需要两个步骤：</p>
<ul>
<li>配置安全组规则，将<code>465</code>端口加入入站规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200402182452.png" alt=""></p>
<ul>
<li>在服务器防火墙中打开<code>465</code>端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install iptables</span><br><span class="line">sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT  <span class="comment"># 将80替换</span></span><br><span class="line">sudo iptables-save  <span class="comment"># 临时保存配置，重启后失效</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install iptables-persistent  <span class="comment"># 安装 iptables-persistent工具，持久化开放端口配置</span></span><br><span class="line">sudo netfilter-persistent save</span><br><span class="line">sudo netfilter-persistent reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>在后台运行python程序</p>
<p>让python后台运行的方法有很多，这里采用了比较简单的一种。在终端运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 leetcode_check.py &gt;lc.log &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&gt;lc.log</code>：表示将标准输出存储在log文件中。</p>
</li>
<li><p><code>&amp;</code> ：表示后台运行。</p>
</li>
</ul>
</li>
<li><p>部署完毕，退出。</p>
</li>
</ol>
<hr>
<h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>此打卡提醒程序只是为了满足日常的一个小需求，程序代码以及部署方式都很简单，很多方面都没有考虑，以后有需要和时间再来慢慢完善吧。大家有什么建议也可以在下方留言。</p>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>爬虫</tag>
        <tag>脚本工具</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04服务器常用配置</title>
    <url>/2020/03/30/Ubuntu18-04%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd -m newuser  <span class="comment"># 创建用户,-m表示自动创建用户的登入目录</span></span><br><span class="line">sudo passwd newuser  <span class="comment"># 为新建的用户创建密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新建的用户加入sudo组</span></span><br><span class="line">sudo chmod +w /etc/sudoers  <span class="comment"># /etc/sudoers文件只有读权限，先赋予写权限</span></span><br><span class="line">sudo vim /etc/sudoers  </span><br><span class="line"><span class="comment"># 编辑此文件，在 root　ALL=(ALL:ALL) ALL行下面添加 newuser ALL=(ALL:ALL) ALL</span></span><br><span class="line">sudo chmod -w /etc/sudoers  <span class="comment"># 将/etc/sudoers文件的权限改为只读权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户</span></span><br><span class="line">sudo userdel newuser</span><br><span class="line">sudo rm -rf /home/newuser  <span class="comment"># 删除用户目录</span></span><br><span class="line"><span class="comment"># 接下来删除此用户相关的配置文件</span></span><br><span class="line">sudo vim /etc/sudoers  </span><br><span class="line">sudo vim /etc/passwd</span><br><span class="line">sudo vim /etc/group</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="后台运行单个Python程序"><a href="#后台运行单个Python程序" class="headerlink" title="后台运行单个Python程序"></a>后台运行单个Python程序</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python test.py &gt;test.log &amp;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成公钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul>
<li>开放某个端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install iptables</span><br><span class="line">sudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT  <span class="comment"># 将80替换</span></span><br><span class="line">sudo iptables-save  <span class="comment"># 临时保存配置，重启后失效</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install iptables-persistent  <span class="comment"># 安装 iptables-persistent工具，持久化开放端口配置</span></span><br><span class="line">sudo netfilter-persistent save</span><br><span class="line">sudo netfilter-persistent reload</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础命令</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内置序列类型总结</title>
    <url>/2020/03/28/Python%E5%86%85%E7%BD%AE%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>Python 标准库用C实现了丰富的序列类型，这些类型大都支持迭代、排序、切片、拼接等操作。</p>
<h5 id="按照存储的内容可以分为："><a href="#按照存储的内容可以分为：" class="headerlink" title="按照存储的内容可以分为："></a>按照存储的内容可以分为：</h5><ul>
<li><p>容器序列：可以存放不同类型的数据</p>
<blockquote>
<p>list、tuple、collections.deque</p>
</blockquote>
</li>
<li><p>扁平序列：只能容纳一种类型</p>
<blockquote>
<p>str、bytes、bytearray、memoryview、array.array</p>
</blockquote>
</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。换句话说，扁平序列其实是一段连续的内存空间。</p>
<h5 id="按照能否被修改可以分为："><a href="#按照能否被修改可以分为：" class="headerlink" title="按照能否被修改可以分为："></a>按照能否被修改可以分为：</h5><ul>
<li><p>可变序列：序列内容可以被修改</p>
<blockquote>
<p>list、bytearray、array.array、collections.deque、memoryview</p>
</blockquote>
</li>
<li><p>不可变序列</p>
<blockquote>
<p>tuple、str、bytes</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a><a href="https://runestone.academy/runestone/books/published/pythonds/AlgorithmAnalysis/Lists.html" target="_blank" rel="noopener">列表list</a></h4><h5 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h5><ul>
<li>属于容器序列：可以存放不同类型的数据</li>
<li>属于可变序列：序列内容可以被修改</li>
</ul>
<h5 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h5><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>index[]</td>
<td>取值</td>
<td>O(1)</td>
</tr>
<tr>
<td>index assignment</td>
<td>赋值</td>
<td>O(1)</td>
</tr>
<tr>
<td>list.append(value)</td>
<td>Append object to the end of the list.</td>
<td>O(1)</td>
</tr>
<tr>
<td>list.clear()</td>
<td>Remove all items from list.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.copy()</td>
<td>Return a shallow copy of the list.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.count(value)</td>
<td>Return number of occurrences of value.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.extend()</td>
<td>Extend list by appending elements from the iterable.</td>
<td>O(k)</td>
</tr>
<tr>
<td>list.index(value,[start,[stop])</td>
<td>Return first index of value.<br />Raises ValueError if the value is not present.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.insert(index, value)</td>
<td>Insert object before index.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.pop()</td>
<td>Remove and return item at  last.</td>
<td>O(1)</td>
</tr>
<tr>
<td>list.pop(index)</td>
<td>Remove and return item at index (default last).</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.remove()</td>
<td>Remove first occurrence of value.<br />Raises ValueError if the value is not present.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.reverse()</td>
<td>Reverse <em>IN PLACE</em>.</td>
<td>O(n)</td>
</tr>
<tr>
<td>list.sort()</td>
<td>Stable sort <em>IN PLACE</em>.</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>len(list)</td>
<td>求列表长度</td>
<td>O(1)</td>
</tr>
<tr>
<td>get slice [x:y]</td>
<td>切片</td>
<td>O(k)</td>
</tr>
<tr>
<td>in 关键字</td>
<td>判断元素是否在列表中</td>
<td>O(n)</td>
</tr>
<tr>
<td>multiply</td>
<td>列表乘法</td>
<td>O(nk)</td>
</tr>
</tbody></table>
<ul>
<li>‘n’是容器中当前的元素数， ‘k’是需要操作的元素个数。</li>
</ul>
<h5 id="列表推导-list-comprehension，简称-listcomps"><a href="#列表推导-list-comprehension，简称-listcomps" class="headerlink" title="列表推导(list comprehension，简称: listcomps):"></a>列表推导(list comprehension，简称: listcomps):</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_a = <span class="string">"1234567890"</span></span><br><span class="line">list_a = []</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> str_a:</span><br><span class="line">    list_a.append(int(c))</span><br><span class="line">print(list_a)</span><br><span class="line"></span><br><span class="line">list_b = [int(c) <span class="keyword">for</span> c <span class="keyword">in</span> str_a]</span><br><span class="line">print(list_b)</span><br></pre></td></tr></table></figure>

<p>以上代码就是一个用<strong>列表推导</strong>代替<strong>for循环</strong>来新建列表的示例。</p>
<p>通常只使用<strong>列表推导</strong>来创建新的列表，并且使代码尽量简短。如果列表推导的代码超过了两行，就要考虑是不是要使用<strong>for循环</strong>进行重写。</p>
<ul>
<li>Python2中列表推导存在变量泄露问题，Python3中不存在。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line">c = <span class="string">"ABC"</span></span><br><span class="line">list_a = [c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"DEF"</span>]</span><br><span class="line">print(c)  <span class="comment"># F</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">c = <span class="string">"ABC"</span></span><br><span class="line">list_a = [c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"DEF"</span>]</span><br><span class="line">print(c)  <span class="comment"># ABC</span></span><br></pre></td></tr></table></figure>

<h5 id="列表推导的性能："><a href="#列表推导的性能：" class="headerlink" title="列表推导的性能："></a>列表推导的性能：</h5><p>列表推导可以实现的操作也有一些替代选择，这里比较一下他们的性能，具体见如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">TIMES = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">SETUP = <span class="string">"""</span></span><br><span class="line"><span class="string">symbols = '$¢£¥€¤'</span></span><br><span class="line"><span class="string">def non_ascii(c):</span></span><br><span class="line"><span class="string">    return c &gt; 127</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(label, cmd)</span>:</span></span><br><span class="line">    res = timeit.repeat(cmd, setup=SETUP, number=TIMES)</span><br><span class="line">    print(label, *(<span class="string">'&#123;:.3f&#125;'</span>.format(x) <span class="keyword">for</span> x <span class="keyword">in</span> res))</span><br><span class="line"></span><br><span class="line">clock(<span class="string">'listcomp        :'</span>, <span class="string">'[ord(s) for s in symbols if ord(s) &gt; 127]'</span>)</span><br><span class="line">clock(<span class="string">'listcomp + func :'</span>, <span class="string">'[ord(s) for s in symbols if non_ascii(ord(s))]'</span>)</span><br><span class="line">clock(<span class="string">'filter + lambda :'</span>, <span class="string">'list(filter(lambda c: c &gt; 127, map(ord, symbols)))'</span>)</span><br><span class="line">clock(<span class="string">'filter + func   :'</span>, <span class="string">'list(filter(non_ascii, map(ord, symbols)))'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># listcomp        : 0.016 0.015 0.015 0.014 0.015</span></span><br><span class="line"><span class="comment"># listcomp + func : 0.025 0.019 0.020 0.077 0.030</span></span><br><span class="line"><span class="comment"># filter + lambda : 0.022 0.022 0.019 0.020 0.023</span></span><br><span class="line"><span class="comment"># filter + func   : 0.017 0.018 0.024 0.020 0.020</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码出处为：<a href="https://github.com/fluentpython/example-code/blob/master/02-array-seq/listcomp_speed.py" target="_blank" rel="noopener">流畅的Python-listcomp_speed.py </a></p>
</blockquote>
<hr>
<h4 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a><a href="https://docs.python.org/3.5/library/stdtypes.html#tuple" target="_blank" rel="noopener">元组tuple</a></h4><h5 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h5><ul>
<li>属于容器序列：可以存放不同类型的数据</li>
<li>属于不可变序列：序列内容不可以被修改</li>
</ul>
<h5 id="内置函数：-1"><a href="#内置函数：-1" class="headerlink" title="内置函数："></a>内置函数：</h5><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>count()</td>
<td>Return number of occurrences of value.</td>
<td>O(n)</td>
</tr>
<tr>
<td>index(value,[start,[stop])</td>
<td>Return first index of value.<br />Raises ValueError if the value is not present.</td>
<td>O(n)</td>
</tr>
<tr>
<td>in 关键字</td>
<td>判断是否在元组中</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h5 id="元组与记录："><a href="#元组与记录：" class="headerlink" title="元组与记录："></a>元组与记录：</h5><p>元组其实是<strong>对数据的记录</strong>：<strong>元组中的每个元素都对应记录中一个字段的数据，外加这个字段的位置，</strong>正是这个位置信息给数据赋予了意义。</p>
<p>如果只是把元组理解为不可变的列表，那其他信息——它所含有的元素的总数和元素的位置——似乎就变得可有可无。但是如果把元组当做是一些字段的集合，那么数量和位置信息就变得非常重要的。</p>
<ul>
<li><strong>示例：</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">city, year, pop, chg, area = (<span class="string">'Tokyo'</span>, <span class="number">2003</span>, <span class="number">32450</span>, <span class="number">0.66</span>, <span class="number">8014</span>)</span><br></pre></td></tr></table></figure>

<p>以上是东京市的一条数据记录，包含了市名、年份、人口、人口变化和面积五个字段的信息。 如何我们对元组内的数据排序，那这些元素所携带的信息就会丢失。</p>
<p><strong>拆包</strong>让元组可以完美地被当作记录来使用。</p>
<h5 id="元组拆包："><a href="#元组拆包：" class="headerlink" title="元组拆包："></a>元组拆包：</h5><p>元组拆包可以应用到任何可迭代对象上。有如下几种应用方式：</p>
<ul>
<li>平行赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lax_coordinates = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line">latitude, longitude = lax_coordinates <span class="comment"># 元组拆包</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不使用中间变量交换两个变量的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>*</code>运算符把一个可迭代对象拆开作为函数的参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">divmod(<span class="number">20</span>, <span class="number">8</span>)  <span class="comment"># (2, 4)</span></span><br><span class="line">t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">divmod(*t)  <span class="comment"># (2, 4)</span></span><br><span class="line">quotient, remainder = divmod(*t)  <span class="comment"># 2, 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>*</code>处理剩下的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, *rest = range(<span class="number">5</span>)  <span class="comment"># 0, 1, [2, 3, 4]</span></span><br><span class="line">a, b, *rest = range(<span class="number">3</span>)  <span class="comment"># 0, 1, [2]</span></span><br><span class="line">a, b, *rest = range(<span class="number">2</span>)  <span class="comment"># 0, 1, []</span></span><br><span class="line"><span class="comment"># *前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置</span></span><br><span class="line">a, *body, c, d = range(<span class="number">5</span>)  <span class="comment"># 0, [1, 2], 3, 4</span></span><br><span class="line">*head, b, c, d = range(<span class="number">5</span>)  <span class="comment"># [0, 1], 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<h5 id="嵌套元组拆包："><a href="#嵌套元组拆包：" class="headerlink" title="嵌套元组拆包："></a>嵌套元组拆包：</h5><p>接受表达式的元组可以是嵌套式的，例如(a, b, (c, d))。需要接受元组的嵌套结构符合表达式本身的嵌套结构。</p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">'Mexico City'</span>, <span class="string">'MX'</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">    (<span class="string">'New York-Newark'</span>, <span class="string">'US'</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">'Sao Paulo'</span>, <span class="string">'BR'</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line">print(<span class="string">'&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;'</span>.format(<span class="string">''</span>, <span class="string">'lat.'</span>, <span class="string">'long.'</span>))</span><br><span class="line">fmt = <span class="string">'&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;'</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:</span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:</span><br><span class="line">        print(fmt.format(name, latitude, longitude))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment">#                 |   lat.    |   long.  </span></span><br><span class="line"><span class="comment"># Mexico City     |   19.4333 |  -99.1333</span></span><br><span class="line"><span class="comment"># New York-Newark |   40.8086 |  -74.0204</span></span><br><span class="line"><span class="comment"># Sao Paulo       |  -23.5478 |  -46.6358</span></span><br></pre></td></tr></table></figure>

<h5 id="具名元组："><a href="#具名元组：" class="headerlink" title="具名元组："></a>具名元组：</h5><p><code>collections.namedtuple</code>模块可以用来构建一个带字段名的元组和一个有名字的类。</p>
<p>使用<code>namedtuple</code>构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些，因为Python不会用<code>__dict__</code>来存放这些实例的属性。</p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="comment"># 创建具名元组</span></span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, <span class="string">'name country population coordinates'</span>) </span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">tokyo = City(<span class="string">'Tokyo'</span>, <span class="string">'JP'</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br><span class="line">print(tokyo)</span><br><span class="line">print(tokyo.population)</span><br><span class="line">print(tokyo.coordinates)</span><br><span class="line">print(tokyo[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># City(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))</span></span><br><span class="line"><span class="comment"># 36.933</span></span><br><span class="line"><span class="comment"># (35.689722, 139.691667)</span></span><br><span class="line"><span class="comment"># JP</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建一个具名元组需要两个参数：类名和类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格所分隔开的字段名组成的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上述示例中的创建具名元组等价于下面这种方式</span></span><br><span class="line">City = namedtuple(<span class="string">'City'</span>, [<span class="string">"name"</span>, <span class="string">"country"</span>, <span class="string">"population"</span>, <span class="string">"coordinates"</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>存放在对应字段里的数据要以一串参数的形式传入到构造函数参数中。需要注意的是，构造函数可接受的参数形式单一，只接受可迭代对象。</p>
</li>
<li><p>可以通过字段名或位置来获取一个字段的位置。</p>
</li>
</ul>
<p>具名元组继承自普通元组，除普通元组的属性外，还有自己专有的属性，比如<strong>_fields类属性</strong>、<strong>类方法_make(iterable)</strong>和<strong>实例方法_asdict()</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(City._fields)</span><br><span class="line">LatLong = namedtuple(<span class="string">'LatLong'</span>, <span class="string">'lat long'</span>)</span><br><span class="line">delhi_data = (<span class="string">'Delhi NCR'</span>, <span class="string">'IN'</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line">delhi = City._make(delhi_data)</span><br><span class="line">print(delhi._asdict())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> delhi._asdict().items():</span><br><span class="line">    print(key + <span class="string">':'</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('name', 'country', 'population', 'coordinates')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name: Delhi NCR</span></span><br><span class="line"><span class="comment"># country: IN</span></span><br><span class="line"><span class="comment"># population: 21.935</span></span><br><span class="line"><span class="comment"># coordinates: LatLong(lat=28.613889, long=77.208889)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>_fields</strong>属性是一个包含这个类所有字段名称的元组</p>
</li>
<li><p>用<strong>_make()</strong>接收一个可迭代对象来生成这个类的一个实例，等价于如下写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">City(*delhi_data)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>_asdict()</strong> 把具名元组以<code>collections.OrderedDict</code>的形式返回。</p>
</li>
</ul>
<hr>
<h4 id="数组array-array"><a href="#数组array-array" class="headerlink" title="数组array.array"></a><a href="https://docs.python.org/3.5/library/array.html#module-array" target="_blank" rel="noopener">数组array.array</a></h4><h5 id="特性：-2"><a href="#特性：-2" class="headerlink" title="特性："></a>特性：</h5><ul>
<li>扁平序列：只能容纳一种类型的数据</li>
<li>可变序列：序列内容可以被修改</li>
</ul>
<p>如果我们需要一个只包含数字的列表，那么array.array比list会更高效。数组支持所有跟可变序列有关的操作。另外，还提供了从文件读取和存入文件的更快的方法。</p>
<h5 id="内置函数：-2"><a href="#内置函数：-2" class="headerlink" title="内置函数："></a>内置函数：</h5><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>append a new item to the end of the array</td>
<td></td>
</tr>
<tr>
<td>buffer_info()</td>
<td>Return a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array’s contents.<br />The length should be multiplied by the itemsize attribute to calculatethe buffer length in bytes.</td>
<td></td>
</tr>
<tr>
<td>byteswap()</td>
<td>Byteswap all items of the array.<br />If the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError israised.</td>
<td></td>
</tr>
<tr>
<td>count()</td>
<td>Return number of occurrences of v in the array.</td>
<td></td>
</tr>
<tr>
<td>extend()</td>
<td>Append items to the end of the array.</td>
<td></td>
</tr>
<tr>
<td>fromfile()</td>
<td>Read n objects from the file object f and append them to the end of the array.</td>
<td></td>
</tr>
<tr>
<td>fromlist()</td>
<td>Append items to array from list.</td>
<td></td>
</tr>
<tr>
<td>frombytes()</td>
<td>Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method).</td>
<td></td>
</tr>
<tr>
<td>fromunicode()</td>
<td>Extends this array with data from the unicode string ustr.<br />The array must be a unicode type array; otherwise a ValueError is raised.<br />Use array.frombytes(ustr.encode(…)) to append Unicode data to an array ofsome other type.</td>
<td></td>
</tr>
<tr>
<td>index()</td>
<td>Return index of first occurrence of v in the array.</td>
<td></td>
</tr>
<tr>
<td>insert()</td>
<td>Insert a new item v into the array before position i.</td>
<td></td>
</tr>
<tr>
<td>pop()</td>
<td>Return the i-th element and delete it from the array.<br />i defaults to -1.</td>
<td></td>
</tr>
<tr>
<td>remove()</td>
<td>Remove the first occurrence of v in the array.</td>
<td></td>
</tr>
<tr>
<td>reverse()</td>
<td>Reverse the order of the items in the array.</td>
<td></td>
</tr>
<tr>
<td>tofile()</td>
<td>Write all items (as machine values) to the file object f.</td>
<td></td>
</tr>
<tr>
<td>tolist()</td>
<td>Convert array to an ordinary list with the same items.</td>
<td></td>
</tr>
<tr>
<td>tobytes()</td>
<td>Convert the array to an array of machine values and return the bytes representation.</td>
<td></td>
</tr>
<tr>
<td>tounicode()</td>
<td>Extends this array with data from the unicode string ustr.<br />Convert the array to a unicode string.  The array must be a unicode type array;otherwise a ValueError is raised.  <br />Use array.tobytes().decode() to obtain aunicode string from an array of some other type.</td>
<td></td>
</tr>
</tbody></table>
<h5 id="类属性：typecode-amp-itemsize"><a href="#类属性：typecode-amp-itemsize" class="headerlink" title="类属性：typecode&amp;itemsize"></a>类属性：typecode&amp;itemsize</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">a = array(<span class="string">'i'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(a.itemsize)</span><br><span class="line">print(a.typecode)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># i</span></span><br><span class="line"><span class="comment"># array('i', [1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>

<p>创建数组需要指定<strong>类型码</strong>以及一个<strong>可迭代对象</strong>，两者可以分别通过内置的类属性<code>typecode</code>以及<code>itemsize</code>来查看。</p>
<ul>
<li>类型码用来表示在底层的C语言应该存放怎样的数据类型，有以下种类：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Type code</th>
<th align="left">C Type</th>
<th align="left">Python Type</th>
<th align="left">Minimum size in bytes</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&#39;b&#39;</code></td>
<td align="left">signed char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;B&#39;</code></td>
<td align="left">unsigned char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;u&#39;</code></td>
<td align="left">Py_UNICODE</td>
<td align="left">Unicode character</td>
<td align="left">2</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>&#39;h&#39;</code></td>
<td align="left">signed short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;H&#39;</code></td>
<td align="left">unsigned short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;i&#39;</code></td>
<td align="left">signed int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;I&#39;</code></td>
<td align="left">unsigned int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;l&#39;</code></td>
<td align="left">signed long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;L&#39;</code></td>
<td align="left">unsigned long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;q&#39;</code></td>
<td align="left">signed long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>&#39;Q&#39;</code></td>
<td align="left">unsigned long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>&#39;f&#39;</code></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&#39;d&#39;</code></td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Notes:</p>
<ol>
<li><p>The <code>&#39;u&#39;</code> type code corresponds to Python’s obsolete unicode character (<a href="https://docs.python.org/3.5/c-api/unicode.html#c.Py_UNICODE" target="_blank" rel="noopener"><code>Py_UNICODE</code></a> which is <code>wchar_t</code>). Depending on the platform, it can be 16 bits or 32 bits.</p>
<p><code>&#39;u&#39;</code> will be removed together with the rest of the <a href="https://docs.python.org/3.5/c-api/unicode.html#c.Py_UNICODE" target="_blank" rel="noopener"><code>Py_UNICODE</code></a> API.</p>
<p><em>Deprecated since version 3.3, will be removed in version 4.0.</em> </p>
</li>
<li><p>The <code>&#39;q&#39;</code> and <code>&#39;Q&#39;</code> type codes are available only if the platform C compiler used to build Python supports C <code>long long</code>, or, on Windows, <code>__int64</code>.</p>
</li>
</ol>
<hr>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><h5 id="序列的增量赋值："><a href="#序列的增量赋值：" class="headerlink" title="序列的增量赋值："></a>序列的增量赋值：</h5><p>增量赋值运算符 <code>+=</code>和<code>*=</code>的表现取决于它们的第一个操作对象。</p>
<p>考虑表达式<code>a += b</code>，<code>+=</code>背后的特殊方法是<code>__iadd__</code>(用于“就地加法”)，对于可变序列来说，a就会就地改动，就像调用了<code>a.extend(b)</code>这样。如果一个类没有实现这个方法的话，Python会退一步调用<code>__add__</code>，这样<code>a += b</code>的效果就变得跟<code>a = a + b</code>一样了：首先计算<code>a + b</code>，得到一个新的对象，然后赋值给a。</p>
<p>总体来讲，可变序列一般都实现了<code>__iadd__</code>方法，因而<code>+=</code>是就地加法。而不可变序列根本就不支持这个操作，对这个方法的实现也就无从谈起了。</p>
<p>上面所说的这些关于<code>+=</code>的概念也适用于<code>*=</code>，不同的是，后者对应的是<code>__imul__</code>。</p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(id(a))  <span class="comment"># 2862020911752</span></span><br><span class="line">a += [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(id(a))  <span class="comment"># 2862020911752</span></span><br><span class="line">a *= <span class="number">2</span></span><br><span class="line">print(id(a))  <span class="comment"># 2862020911752</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 2862021748992</span></span><br><span class="line">print(id(b))</span><br><span class="line">b += (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(id(b))  <span class="comment"># 2862020978208</span></span><br><span class="line">b *= <span class="number">2</span></span><br><span class="line">print(id(b))  <span class="comment"># 2862020594632</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array</span></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">c = array(<span class="string">'i'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">d = array(<span class="string">'i'</span>, [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">print(id(c))  <span class="comment"># 2862021863536</span></span><br><span class="line">c += d</span><br><span class="line">print(id(c))  <span class="comment"># 2862021863536</span></span><br><span class="line">c *= <span class="number">2</span></span><br><span class="line">print(id(c))  <span class="comment"># 2862021863536</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str</span></span><br><span class="line">a = <span class="string">"123"</span></span><br><span class="line">print(id(a))  <span class="comment"># 2316514911712</span></span><br><span class="line">a += <span class="string">"456"</span></span><br><span class="line">print(id(a))  <span class="comment"># 2316515702128</span></span><br><span class="line">a *= <span class="number">2</span></span><br><span class="line">print(id(a))  <span class="comment"># 2316516515952</span></span><br></pre></td></tr></table></figure>

<p>对于不可变序列进行重复拼接操作的话，效率会很低，因为每次都要建立一个新对象，而解释器需要把原来对象的元素先复制到新的对象里，然后再追加新的元素。</p>
<h5 id="改变不可变元组中的列表："><a href="#改变不可变元组中的列表：" class="headerlink" title="改变不可变元组中的列表："></a>改变不可变元组中的列表：</h5><ul>
<li>看下面一段代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>] += [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>a的类型为不可变类型tuple，其中第二个元素为可变类型list，可以看到我们在修改a[2]这个元素时，运行报错，但a还是被修改成功。</p>
<ul>
<li>让我们先来看一下代码运行前后a的状态</li>
</ul>
<ol>
<li><code>a = (1, 2, [3, 4])</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200329174757.png" alt=""></p>
<ol start="2">
<li><code>a[2] += [4, 5]</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200329174949.png" alt=""></p>
<p>可以发现a[2]存储的并不是列表[3, 4]的值，而是列表的引用。</p>
<blockquote>
<p><a href="http://www.pythontutor.com" target="_blank" rel="noopener">Python Tutor</a> 是一个对 Python 运行原理进行可视化分析的工具。  </p>
</blockquote>
<ul>
<li><p>接下来看一下Python 表达式<code>s[a] += b</code>生成的字节码：</p>
<p>为简化分析，我们将前面的示例代码改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a[<span class="number">2</span>] += b</span><br></pre></td></tr></table></figure>

<p>利用python的<a href="https://docs.python.org/3/library/dis.html" target="_blank" rel="noopener">dis模块</a>查看<code>a[2]+=b</code>的执行字节码：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(<span class="string">'a[2]+=b'</span>)</span><br><span class="line">    <span class="number">1</span>           <span class="number">0</span> LOAD_NAME                <span class="number">0</span> (a)  </span><br><span class="line">                <span class="number">2</span> LOAD_CONST               <span class="number">0</span> (<span class="number">2</span>)</span><br><span class="line">                <span class="number">4</span> DUP_TOP_TWO</span><br><span class="line">                <span class="number">6</span> BINARY_SUBSCR                    <span class="comment"># node 1</span></span><br><span class="line">                <span class="number">8</span> LOAD_NAME                <span class="number">1</span> (b)</span><br><span class="line">               <span class="number">10</span> INPLACE_ADD                      <span class="comment"># node 2</span></span><br><span class="line">               <span class="number">12</span> ROT_THREE</span><br><span class="line">               <span class="number">14</span> STORE_SUBSCR                     <span class="comment"># node 3</span></span><br><span class="line">               <span class="number">16</span> LOAD_CONST               <span class="number">1</span> (<span class="literal">None</span>)</span><br><span class="line">               <span class="number">18</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>node 1：</strong>将a[2]的值存入TOS(Top Of Stack，栈的顶端)</li>
<li><strong>node 2：</strong>计算TOS + b。这一步能够完成，是因为TOS指向的是一个可变对象。</li>
<li><strong>node3：</strong>a[2] = TOS赋值。这一步会失败。因为a是不可变的元组tuple。</li>
</ul>
</li>
</ul>
<p>由以上分析，我们可以发现：<strong>增量赋值</strong>操作不是原子操作。前面示例可以看到，代码抛出了异常，但还是完成了操作。</p>
<hr>
<blockquote>
<p>本篇博客内容大部分总结自《流畅的Python》一书，文中有什么写的不清楚的，读者可以阅读《流畅的Python》自己分析一下。</p>
<p>另外，文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>内置序列类型</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里3月27日笔试算法题记录</title>
    <url>/2020/03/27/%E9%98%BF%E9%87%8C3%E6%9C%8827%E6%97%A5%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>上午参加了阿里巴巴2020-3-27场次的笔试，笔试内容为两道算法题，笔试形式为牛客网在线编程(考试形式)，允许使用本地IDE进行调式。</p>
<p>博主本身算法题基础不是很好，加上是第一次参加这种形式的笔试（需要自己处理输入输出，之前刷LeetCode只需要实现函数就行了），题答的不好，结束后决定把这两道题搞清楚并记录一下。</p>
<hr>
<h4 id="算法题一的大致内容如下："><a href="#算法题一的大致内容如下：" class="headerlink" title="算法题一的大致内容如下："></a>算法题一的大致内容如下：</h4><ul>
<li>两行输入，分别为S和T，每行是一个字符串，字符串S和T长度相等</li>
<li>允许的操作是：将S中任意一个字符移至字符串的末尾</li>
<li>计算需要操作几次可以将S转换为T，输出操作次数；若S无法转换为T，则输出-1</li>
</ul>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ul>
<li><p>输入：</p>
<blockquote>
<p>ackd<br>cdak</p>
</blockquote>
</li>
<li><p>输出</p>
<blockquote>
<p>2</p>
</blockquote>
</li>
</ul>
<h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><ul>
<li><p>首先判断字符串S能否转换为T，即判断S和T中字符出现的次数是都完全一致</p>
</li>
<li><p>接下来寻找S中不需要移动的字符数，即寻找T的最长的一个首部，满足：S中可以找到一个子序列，包含此首部中出现的所有字符，并且这些字符出现的顺序相同。不需要移动的字符数即为此首部的长度。</p>
<p>如上例中T满足要求的最长首部为<code>cd</code>，对应S中的子序列为<code>ckd</code>。</p>
</li>
<li><p>输出需要操作的次数，即为T的长度减去不需要移动的字符数</p>
</li>
</ul>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(S, T)</span>:</span></span><br><span class="line">    <span class="comment"># 首先统计字符串S和T每个字符出现的次数是否相等</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> hashmap:</span><br><span class="line">            hashmap[c] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hashmap[c] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> T:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> hashmap:</span><br><span class="line">            hashmap[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> hashmap.values():</span><br><span class="line">        <span class="keyword">if</span> value != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 然后寻找不需要移动的字符数</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> j &lt; len(T):</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> T[j] != S[i]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(T)-j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    S = sys.stdin.readline().strip()</span><br><span class="line">    T = sys.stdin.readline().strip()</span><br><span class="line">    print(func(S, T))</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="算法题2的大致内容如下："><a href="#算法题2的大致内容如下：" class="headerlink" title="算法题2的大致内容如下："></a>算法题2的大致内容如下：</h4><ul>
<li><p>求n个随机数中最小值的期望值</p>
</li>
<li><p>三行输入，分别为：</p>
<ul>
<li>n:  随机数的个数</li>
<li>l1, l2, … ln  :  l<em>i</em> 为第i个随机数的最小值</li>
<li>r1, r2, … rn  ：r<em>i</em> 为第i个随机数的最大值</li>
</ul>
<p>即第i个随机数的取值区间是 [l<em>i</em>, r<em>i</em>]，取到区间里数字的概率相等</p>
</li>
<li><p>输出为随机数最小值的期望</p>
</li>
<li><p>还有一些关于浮点数的要求（记不清楚了）</p>
</li>
</ul>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><ul>
<li><p>输入：</p>
<blockquote>
<p>2</p>
<p>1 2</p>
<p>3 3</p>
</blockquote>
</li>
<li><p>输出</p>
<blockquote>
<p>1.83333</p>
</blockquote>
</li>
<li><p>解释：</p>
<blockquote>
<p>最小值为1：（1，2）（1，3）：概率为2/6</p>
<p>最小值为2：（2，2）（2，3）（3，2）：概率为3/6</p>
<p>最小值为3：（3，3）：概率为1/6</p>
<p>结果为：1*(2/6) + 2*(3/6) + 3*(1/6) = 1.83333</p>
</blockquote>
</li>
</ul>
<h5 id="解题思路：暴力破解"><a href="#解题思路：暴力破解" class="headerlink" title="解题思路：暴力破解"></a>解题思路：暴力破解</h5><ul>
<li>首先找到n个随机数的所有情况</li>
<li>然后找到最小值的范围</li>
<li>然后寻找每个可能值可能出现的次数并计算概率, 更新期望:<ul>
<li>依次让第i个随机数为num，统计可能的出现的次数</li>
<li>在统计其他位置可能的情况的时候，要略过已经统计过的情况（见代码）</li>
</ul>
</li>
</ul>
<h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(N, LS, RS)</span>:</span></span><br><span class="line">    <span class="comment"># 首先找到n个随机数的所有情况</span></span><br><span class="line">    total = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        total *= (RS[i] - LS[i]) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 然后找到最小值的范围</span></span><br><span class="line">    min_num = min(LS)</span><br><span class="line">    max_num = min(RS)</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 然后寻找每个可能值的概率, 并计算期望: 依次让第i个随机数为num，统计可能的出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(min_num, max_num+<span class="number">1</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            tmp = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> LS[i] &lt;= num &lt;= RS[i]:  <span class="comment"># 第i个随机数可以取到num才计算：</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                    <span class="keyword">if</span> j != i:  <span class="comment"># 统计其他位置可能的情况</span></span><br><span class="line">                        <span class="keyword">if</span> j &lt; i <span class="keyword">and</span> LS[j] &lt;= num:  <span class="comment"># 略过已经统计过的情况</span></span><br><span class="line">                            pro = min(RS[j] - LS[j], RS[j]-num)  <span class="comment">#例如：示例中统计最小值为2的情况时，取第一位为2，有(2, 2),(2,3);取第二位为2时，应略过(2, 2), 此时只有(3,2)</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            pro = min(RS[j] - LS[j], RS[j] - num) + <span class="number">1</span></span><br><span class="line">                        tmp *= pro</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = <span class="number">0</span></span><br><span class="line">            count += tmp</span><br><span class="line">        p = count / total  <span class="comment"># 计算概率</span></span><br><span class="line">        ans += num*p  <span class="comment"># 更新期望</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = int(sys.stdin.readline())</span><br><span class="line">    line = sys.stdin.readline().strip()</span><br><span class="line">    ls = list(map(int, line.split()))</span><br><span class="line">    line = sys.stdin.readline().strip()</span><br><span class="line">    rs = list(map(int, line.split()))</span><br><span class="line">    print(func(n, ls, rs))</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>笔试时间为一个小时，调试第一题不知不觉就花了半个多小时，第二题慌慌张张只写了一个大概，跑通是不可能跑通的。</p>
<p>看来以后刷题的时候要刻意的控制下解题时间，不可以像现在这样慢慢的做。</p>
<p>有了思路之后要多考虑几个测试用例，不然写到一半或者写完测试时发现思路是错的，再改也没有时间了。</p>
<blockquote>
<p>文中有什么错误或者不足之处，欢迎指出~</p>
<p>题二有什么更好的解法也欢迎指教~</p>
</blockquote>
]]></content>
      <categories>
        <category>面试/笔试</category>
      </categories>
      <tags>
        <tag>阿里</tag>
        <tag>笔试</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内置模块bisect</title>
    <url>/2020/03/25/Python%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97bisect/</url>
    <content><![CDATA[<h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p><code>bisect</code>模块是Python内置的一个功能模块，这个模块的功能是在对列表<code>list</code>进行插入操作时，维护列表保持有序的状态。使用<code>bisect</code>模块中的方法时需要满足一个条件，即<strong>执行插入操作的列表<code>list</code>本身需要是有序的。</strong></p>
<hr>
<h4 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h4><p><code>bisect</code> 模块包含如下四个主要函数，这四个函数都利用二分查找算法来在有序列表中查找或者插入元素。</p>
<h5 id="1-bisect-a-x-lo-0-hi-None"><a href="#1-bisect-a-x-lo-0-hi-None" class="headerlink" title="1. bisect(a, x, lo=0, hi=None):"></a>1. bisect(a, x, lo=0, hi=None):</h5><ul>
<li><p>此函数其实是<code>bisect_right()</code>的别名，函数的作用是返回元素x在列表a中的插入位置，a需要是有序的。</p>
</li>
<li><p>如果存在与x相等的元素，返回的结果是最后x出现位置的下一位。</p>
</li>
<li><p>参数lo和hi指定了查找范围。</p>
</li>
<li><p>源码：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<h5 id="2-insort-a-x-lo-0-hi-None-："><a href="#2-insort-a-x-lo-0-hi-None-：" class="headerlink" title="2. insort(a, x, lo=0, hi=None)："></a>2. insort(a, x, lo=0, hi=None)：</h5><ul>
<li>此函数其实是<code>insort_right()</code>的别名，函数的作用是在列表a中插入元素x，并保持列表a有序。</li>
<li>如果存在与x相等的元素，则插入在最后一个x的右侧。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br></pre></td></tr></table></figure>

<h5 id="3-bisect-left-a-x-lo-0-hi-None"><a href="#3-bisect-left-a-x-lo-0-hi-None" class="headerlink" title="3. bisect_left(a, x, lo=0, hi=None):"></a>3. bisect_left(a, x, lo=0, hi=None):</h5><ul>
<li>函数作用同样是返回元素x在列表a中的插入位置。</li>
<li>但如果存在与x相等的元素，返回的结果是第一个x出现位置。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<h5 id="4-insort-left-a-x-lo-0-hi-None"><a href="#4-insort-left-a-x-lo-0-hi-None" class="headerlink" title="4. insort_left(a, x, lo=0, hi=None):"></a>4. insort_left(a, x, lo=0, hi=None):</h5><ul>
<li>函数的作用同样是在列表a中插入元素x，并保持列表a有序。</li>
<li>但如果存在与x相等的元素，则插入在第一个x的左侧。</li>
<li>参数lo和hi指定了查找范围。</li>
<li>源码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="与list内置index-性能的比较："><a href="#与list内置index-性能的比较：" class="headerlink" title="与list内置index()性能的比较："></a>与<code>list</code>内置<code>index()</code>性能的比较：</h4><p>由<code>bisect</code>的源码可以看出，<code>bisect</code>模块内的函数使用<strong>二分查找</strong>的方式来加快<strong>寻找元素插入位置</strong>。对于<strong>插入元素，并保持列表有序</strong> 这样的操作要求我们可以结合<code>list</code>内置的<code>index()</code>函数与<code>insert()</code>函数来实现相同的效果。但由于<code>index()</code>函数是采用顺序查找的方式，故<code>bisect</code>模块的效率应高于<code>list</code>内置的<code>index()</code>函数。</p>
<h5 id="1-list-内置index-函数源码："><a href="#1-list-内置index-函数源码：" class="headerlink" title="1.  list 内置index()函数源码："></a>1.  <code>list</code> 内置<code>index()</code>函数源码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*[clinic input]</span></span><br><span class="line"><span class="comment">list.index</span></span><br><span class="line"><span class="comment">    value: object</span></span><br><span class="line"><span class="comment">    start: slice_index(accept=&#123;int&#125;) = 0</span></span><br><span class="line"><span class="comment">    stop: slice_index(accept=&#123;int&#125;, c_default="PY_SSIZE_T_MAX") = sys.maxsize</span></span><br><span class="line"><span class="comment">    /</span></span><br><span class="line"><span class="comment">Return first index of value.</span></span><br><span class="line"><span class="comment">Raises ValueError if the value is not present.</span></span><br><span class="line"><span class="comment">[clinic start generated code]*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">list_index_impl(PyListObject *self, PyObject *value, Py_ssize_t start,</span><br><span class="line">                Py_ssize_t <span class="built_in">stop</span>)</span><br><span class="line"><span class="comment">/*[clinic end generated code: output=ec51b88787e4e481 input=40ec5826303a0eb1]*/</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stop</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stop</span> += Py_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stop</span> &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; <span class="built_in">stop</span> &amp;&amp; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        PyObject *obj = self-&gt;ob_item[i];</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        <span class="keyword">int</span> cmp = PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> PyLong_FromSsize_t(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_Format(PyExc_ValueError, <span class="string">"%R is not in list"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出<code>index()</code>函数是从<code>start</code>到<code>stop</code>顺序遍历的。</li>
</ul>
<h5 id="2-效率比较"><a href="#2-效率比较" class="headerlink" title="2. 效率比较"></a>2. 效率比较</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">list_ = list(range(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    list_.index(i)  <span class="comment"># 查找list中的每一个元素</span></span><br><span class="line">print(time.time() - start)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    bisect.bisect(list_, i)  <span class="comment"># 查找list中的每一个元素</span></span><br><span class="line">print(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 1.013824462890625</span></span><br><span class="line"><span class="comment"># 0.007440805435180664</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>bisect</code>模块的功能和实现都较为简单，通过调用此模块可以来让我们的代码更简洁。当然了，我们也可以自己实现二分查找的过程。</p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python内置模块</tag>
        <tag>Python</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 多表插入操作 insert all/first子句</title>
    <url>/2020/03/20/Oracle-insert-all-first%E5%AD%90%E5%8F%A5/</url>
    <content><![CDATA[<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>在Oracle 中如果需要将一个子查询得到的数据进行多表插入操作的话，可以使用insert all/first 子句进行操作，相比使用多次单表插入效率会更高，因为主表只访问了一次。</p>
<hr>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/INSERT.html#GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank" rel="noopener">多表插入操作</a> 可以分为<strong>有条件</strong>插入和<strong>无条件</strong>插入两种：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200320210500.png"  />

<ul>
<li><p>执行<strong>有条件插入</strong>时，可以选择<strong>insert all/first</strong>子句来执行不同的插入策略。</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200320211224.png" style="zoom:80%;" />

<ul>
<li>一条多表插入操作的SQL语句最多支持<strong>127</strong>个<strong>when</strong>子句。</li>
</ul>
<p>两者的区别在于：</p>
<ul>
<li>insert all: 会对每个when条件进行匹配，如果满足则插入</li>
<li>insert first: 数据库会将数据依次对when条件进行匹配，遇到满足条件的when条件就进行插入，并且跳过之后的when条件的判断。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/insert all-first.png" style="zoom:80%;" />

<hr>
<h4 id="简单示例："><a href="#简单示例：" class="headerlink" title="简单示例："></a>简单示例：</h4><h5 id="1-数据准备："><a href="#1-数据准备：" class="headerlink" title="1. 数据准备："></a>1. 数据准备：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_a(a <span class="built_in">number</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_b <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_c <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_a <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-insert-all"><a href="#2-insert-all" class="headerlink" title="2.  insert all"></a>2.  insert all</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert all</span><br><span class="line">	when a &lt;&#x3D; 2 then into table_b</span><br><span class="line">	when a &lt;&#x3D; 5 then into table_c</span><br><span class="line">select * from table_a;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：</p>
<table>
<thead>
<tr>
<th>表</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>table_a</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
<tr>
<td>table_b</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>table_c</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
</tbody></table>
<blockquote>
<p>数据1和2同时满足两个when条件，两个表都进行了插入。</p>
</blockquote>
</li>
</ul>
<h5 id="3-insert-first"><a href="#3-insert-first" class="headerlink" title="3. insert first"></a>3. insert first</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">first</span></span><br><span class="line">	<span class="keyword">when</span> a &lt;= <span class="number">2</span> <span class="keyword">then</span> <span class="keyword">into</span> table_b</span><br><span class="line">	<span class="keyword">when</span> a &lt;= <span class="number">5</span> <span class="keyword">then</span> <span class="keyword">into</span> table_c</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_a;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果：</p>
<table>
<thead>
<tr>
<th>表</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>table_a</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
<tr>
<td>table_b</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>table_c</td>
<td>[3, 4, 5]</td>
</tr>
</tbody></table>
<blockquote>
<p>数据1和2同时满足两个when条件，但插入了第一个表后就跳过了第二个when条件的检查。</p>
</blockquote>
</li>
</ul>
<p>推荐使用Oracle 的<a href="https://livesql.oracle.com/apex/f?p=590:1:1114621173697::NO:RP::" target="_blank" rel="noopener">Live SQL</a>动手测试一下。</p>
<p>更多的示例可以参考Oracle官方文档 <a href="https://docs.oracle.com/en/database/oracle/oracle-database/20/sqlrf/INSERT.html#GUID-903F8043-0254-4EE9-ACC1-CB8AC0AF3423" target="_blank" rel="noopener"><strong>Multitable Inserts: Examples</strong></a></p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中sort()/sorted()自定义排序规则</title>
    <url>/2020/03/17/Python%E4%B8%ADsort-sorted%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h4 id="问题：面试题45-把数组排成最小的数——《剑指Offer》"><a href="#问题：面试题45-把数组排成最小的数——《剑指Offer》" class="headerlink" title="问题：面试题45. 把数组排成最小的数——《剑指Offer》"></a>问题：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">面试题45. 把数组排成最小的数——《剑指Offer》</a></h4><p>先来看这样一道算法题：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20200317161920.png" alt=""></p>
<p>解题思路：</p>
<ul>
<li>找到一个排序规则，数组根据这个规则排序后能排成一个最小的数字。要确定排序规则，就要比较两个数字，也就是给出两个数字<code>m</code>和<code>n</code>,我们需要确定一个规则来判断<code>m</code>和<code>n</code>哪个应该排在前面，而不是仅仅比较这两个数字的值的大小。</li>
</ul>
<p>排序规则设计：</p>
<ul>
<li>根据题目的要求，两个数字<code>m</code>和<code>n</code>能拼接成数字<code>mn</code>和<code>nm</code>。如果<code>mn</code>&lt;<code>nm</code>，那么我们应该打印<code>mn</code>，也就是<code>m</code>应该排在<code>n</code>的前面，此时我们定义<code>m</code>小于<code>n</code>；反之，如果<code>mn</code>&gt;<code>nm</code>，我们定义<code>m</code>大于<code>n</code>。</li>
</ul>
<hr>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><ul>
<li><p>基于以上排序规则，我们可以实现如下的排序函数：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="comment"># 将数组元素转换为str,是为了处理大数问题</span></span><br><span class="line">    str1 = m + n</span><br><span class="line">    str2 = n + m</span><br><span class="line">    <span class="keyword">if</span> str1 &lt; str2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> str1 &gt; str2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自定义的排序规则函数进行排序</p>
<p><code>nums</code>的排序可以使用<code>sort()</code>或者<code>sorted()</code>，但要注意的是：在Python3版本中，<code>sort()</code>以及<code>sorted()</code>都舍弃了<code>cmp</code>参数，引进了新的<code>key</code>参数，</p>
<ul>
<li><p><strong>cmp:</strong> 接受两个参数<code>a</code>和<code>b</code>，然后根据它们的大小关系返回不同的值：<code>a &lt; b</code>时返回负值，<code>a &gt; b</code>时返回正值，<code>a = b</code>时返回0。</p>
</li>
<li><p><strong>key:</strong> 接收一个参数，返回一个可比较对象。新的<code>key</code>函数这种模式并不直接比较任意两个原始元素，而是通过<code>key</code>函数把那些元素转换成一个个新的可比较对象，也就是元素的key，然后用元素的key代替元素去参与比较。</p>
</li>
</ul>
</li>
<li><p>如果我们习惯了Python2中<code>cmp</code>参数格式的写法，可以使用<a href="https://docs.python.org/3/library/functools.html#functools.cmp_to_key" target="_blank" rel="noopener">functools.cmp_to_key()</a>函数进行转换，它相当于旧接口和新接口的转换器。完整代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            str1 = a + b</span><br><span class="line">            str2 = b + a</span><br><span class="line">            <span class="keyword">if</span> str1 &lt; str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> str1 &gt; str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=functools.cmp_to_key(compare)))</span><br></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>其实很巧妙，Python对象的比较过程可以用<code>__lt__</code>等函数重写，<code>cmp_to_key</code>的返回值也是一个重写了比较过程的对象，在调用自定义比较过程时会调用输入的比较函数，从而实现了设计目标。以下是<code>cmp_to_key()</code>的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_to_key</span><span class="params">(mycmp)</span>:</span></span><br><span class="line">    <span class="string">"""Convert a cmp= function into a key= function"""</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">K</span><span class="params">(object)</span>:</span></span><br><span class="line">        __slots__ = [<span class="string">'obj'</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">            self.obj = obj</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) == <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &lt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) &gt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(self.obj, other.obj) != <span class="number">0</span></span><br><span class="line">        __hash__ = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>cmp_to_key()</code>函数返回的是一个类对象，在这里重载了进行元素比较的各个函数。</p>
<hr>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h4><ul>
<li><p>如果我们不想使用<code>cmp_to_key()</code>函数进行转换，我们也可以自己实现一个这样的类对象，只需重载其中的<code>__lt__</code>函数即可，完整代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Compare</span><span class="params">(str)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">                <span class="keyword">return</span> self + s &lt; s + self</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=Compare))</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>cmp_to_key()</code>这种形式时，还可以利用<code>lambda</code>表达式来代替自定义排序规则函数，达到简化代码的效果，等效代码如下：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums: List[int])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">import</span> functools</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums], key=functools.cmp_to_key(<span class="keyword">lambda</span> x, y: int(x+y)-int(y+x))))</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较：</p>
<blockquote>
<p>This(key) is easier to use and faster to run. When using the cmp parameter, the sorting compares pairs of values, so the compare-function is called multiple times for every item. The larger the set of data, the more times the compare-function is called per item. With the key function the sorting instead keeps the key value for each item and compares those, so the key function is only called once for every item. This results in much faster sorts for large sets of data.</p>
<p>查看 <a href="http://python3porting.com/preparing.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p><strong>1. sort()与sorted()基础知识</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>sort()</th>
<th>sorted()</th>
</tr>
</thead>
<tbody><tr>
<td align="center">调用方式</td>
<td><code>list1.sort()</code></td>
<td><code>sort(list1)</code></td>
</tr>
<tr>
<td align="center">返回值</td>
<td>自身被排序，没有返回值</td>
<td>返回一个新的排序好的list</td>
</tr>
<tr>
<td align="center">适用性</td>
<td>只适用于list</td>
<td>适用于所有可迭代序列</td>
</tr>
</tbody></table>
<ul>
<li>都有一个<code>reverse</code> 参数，指定升序或降序，默认为<code>False</code>(升序)</li>
<li>都有一个<code>key</code> 参数，此参数为一个只有一个参数的函数，这个函数会应用在序列里的每个元素, 所产生的结果将是排序算法依赖的对比关键字。默认值为恒等函数，即默认用元素自己的值来排序。</li>
<li>两个函数都是稳定的，即具有相同顺序的元素排序后还是原来的顺序。</li>
</ul>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中queue模块及常用方法</title>
    <url>/2020/03/07/Python%E4%B8%ADqueue%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Python中的<code>queue</code>模块对应数据结构中<code>队列</code>的概念，实现了一些基本的队列操作。</p>
</blockquote>
<h4 id="一、queue-Queue-maxsize-0"><a href="#一、queue-Queue-maxsize-0" class="headerlink" title="一、queue.Queue(maxsize=0)"></a>一、queue.Queue(maxsize=0)</h4><ul>
<li><p>普通<code>FIFO</code>队列</p>
<p>  初始化时指定 <code>maxsize</code>参数可设定队列的最大容量， 若<code>maxsize &lt;= 0</code>，则队列容量无限。</p>
<p>  常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td>如果队列为空，返回True</td>
<td></td>
</tr>
<tr>
<td>full()</td>
<td>如果队满，返回True</td>
<td></td>
</tr>
<tr>
<td>put()</td>
<td>向队列添加元素</td>
<td></td>
</tr>
<tr>
<td>get()</td>
<td>从队列取元素，并从队列删除该元素</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="二、queue-deque"><a href="#二、queue-deque" class="headerlink" title="二、queue.deque()"></a>二、queue.deque()</h4><ul>
<li><p>双端队列</p>
<p>  其实是<code>collections.deque</code>模块。<code>deque()</code> 的设计是为了在两端实现高效的插入和删除操作。</p>
<p>  常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>在队列右侧添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>appendleft()</td>
<td>在队列左侧添加元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>clear()</td>
<td>删除所有元素</td>
<td>O(n)</td>
</tr>
<tr>
<td>copy()</td>
<td>浅拷贝</td>
<td>O(n)</td>
</tr>
<tr>
<td>count(value)</td>
<td>统计Value出现的次数</td>
<td>O(n)</td>
</tr>
<tr>
<td>extend(value)</td>
<td>Extend the right side of the deque with elements from the iterable</td>
<td>O(k)</td>
</tr>
<tr>
<td>extendleft</td>
<td>Extend the left side of the deque with elements from the iterable</td>
<td>O(k)</td>
</tr>
<tr>
<td>index(value)</td>
<td>返回value的第一个位置的索引</td>
<td>O(n)</td>
</tr>
<tr>
<td>insert(index, value)</td>
<td>在指定位置插入元素</td>
<td>O(n)</td>
</tr>
<tr>
<td>pop()</td>
<td>Remove and return the rightmost element</td>
<td>O(1)</td>
</tr>
<tr>
<td>popleft()</td>
<td>Remove and return the leftmost element</td>
<td>O(1)</td>
</tr>
<tr>
<td>remove(value)</td>
<td>remove first occurrence of value</td>
<td>O(n)</td>
</tr>
<tr>
<td>reverse()</td>
<td>reverse IN PLACE</td>
<td>O(n)</td>
</tr>
<tr>
<td>rotate()</td>
<td>Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left</td>
<td>O(k)</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="三、与list的对比"><a href="#三、与list的对比" class="headerlink" title="三、与list的对比"></a>三、与list的对比</h4><p>我们有时为了方便会使用<code>list</code>这一数据类型来模拟队列的实现，但在某些功能实现的效率上会有所不同。比如：</p>
<ol>
<li><p>从队列中弹出队首元素</p>
<ul>
<li><p><code>list</code>:<br> 实现方式：<code>pop(0)</code> </p>
<ul>
<li><p><code>deque</code>：<br>实现方式：<code>popleft()</code></p>
</li>
<li><p><code>Queue</code>：<br>实现方式：<code>get()</code></p>
</li>
<li><p>以下是三种方法的时间复杂度比较：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>pop(0)</td>
<td>O(n)</td>
</tr>
<tr>
<td>popleft()</td>
<td>O(1)</td>
</tr>
<tr>
<td>get()</td>
<td>O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p><code>list</code> 中pop()函数不加参数时间复杂度为O(1)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python内置模块</tag>
        <tag>Python</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3使用‘*’初始化list的陷阱</title>
    <url>/2020/03/06/Python%E4%BD%BF%E7%94%A8%E2%80%98%E2%80%BB%E2%80%99%E5%88%9D%E5%A7%8B%E5%8C%96list%E7%9A%84%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<ul>
<li><p>问题发现：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [[<span class="number">0</span>]*<span class="number">2</span>]*<span class="number">3</span></span><br><span class="line">list2 = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">list1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">list2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(list1)  <span class="comment"># [[1, 0], [1, 0], [1, 0]]</span></span><br><span class="line">print(list2)  <span class="comment"># [[1, 0], [0, 0], [0, 0]]</span></span><br></pre></td></tr></table></figure>
<p>  在上述示例代码中，list1, list2这两种初始化的方式都会得到 [[0, 0], [0, 0]] 这样的list。<br>  但在我们想要修改list1以及list2的[0][0]位置的值时，我们发现list2中修改结果如我们所愿，而list1中所有元素均被修改。</p>
</li>
<li><p>解释：<br>在Python3中，list1 以及list2 两种初始化方式分别对应如下两种方式：</p>
<ul>
<li>list1<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, list1 &#x3D; [0]*2, []</span><br><span class="line">for i in range(3):    </span><br><span class="line">    list1.append(x)</span><br></pre></td></tr></table></figure></li>
<li>list2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list2 &#x3D; []</span><br><span class="line">for i in range(3):</span><br><span class="line">    x &#x3D; [0]*2</span><br><span class="line">    list2.append(x)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  <strong>list1:</strong> 将同一个对象x添加到list1当中三次，即list1中三个元素为同一个对象<br>  <strong>list2:</strong> 每次迭代创建一个新的对象，并将其添加到list2中</p>
</li>
<li><p>验证：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(list1[<span class="number">0</span>] <span class="keyword">is</span> list1[<span class="number">1</span>])  <span class="comment"># True</span></span><br><span class="line">print(list2[<span class="number">0</span>] <span class="keyword">is</span> list2[<span class="number">1</span>])  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次网络配置故障排查记录</title>
    <url>/2020/03/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="一、问题出现"><a href="#一、问题出现" class="headerlink" title="一、问题出现"></a>一、问题出现</h4><p>问题源自之前做的一个项目，客户换了新电脑之后，无论如何都打不开软件。</p>
<p>在多台电脑上测试后，都可以正常运行，唯独客户打不开，简单检查排除了软件自身的原因。</p>
<p>之后经过长时间检查，发现是客户新电脑网络配置的问题，以此文来记录下排查故障的过程和问题解决的方式。</p>
<hr>
<h4 id="二、基本环境"><a href="#二、基本环境" class="headerlink" title="二、基本环境"></a>二、基本环境</h4><ul>
<li>项目基础：<ol>
<li><code>Python3</code> + <code>PyQt5</code> 制作的桌面应用程序，在win10系统下使用，主要使用的模块还有<code>requests</code>；</li>
<li>使用<code>pyinstaller</code> 打包成单个exe程序，无需客户配置程序运行环境；</li>
</ol>
</li>
<li>客观因素：客户网络不是很好，网速比较慢</li>
</ul>
<h4 id="三、排查故障及解决过程"><a href="#三、排查故障及解决过程" class="headerlink" title="三、排查故障及解决过程"></a>三、排查故障及解决过程</h4><ol>
<li><p>错误提示<br> 客户每次运行软件，都会弹出<code>Failed to execute script ***</code>的错误提示窗口，此外没有其他信息。</p>
</li>
<li><p>重新打包<br> 之前的打包方式为 <code>pyinstall -F -w ***.py</code>，生成的为不带命令行窗口的单个EXE文件。为了查看更多、更详细的错误提示信息，需要重新打包软件，使用以下命令可以打包成使用命令行窗口执行的EXE文件。<br> <code>pyinstall -F -c ***.py</code><br> 在命令行窗口中再次运行程序，观察命令行窗口错误信息，主要有如下信息：<br> <img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/error.png" alt=""><br> 发现是在通过 <code>requests</code>库连接目标网址的时候，连接失败了。</p>
<blockquote>
<p> 考虑到客户说他网络不好，首先怀疑是网速的原因，但通过在浏览器网页打开目标网站的速度来看，应该不是由网速引起的，决定进一步排查。</p>
</blockquote>
</li>
<li><p>检查网络配置<br> 借助win10 自带工具<code>ping</code> 和 <code>telnet</code> 在命令行窗口排查故障</p>
<ul>
<li><p>在命令行中 <code>ping www.目标网址.com</code> ：<strong>提示找不到主机，请检查名称，然后重试。</strong>（博主自己的电脑可以）</p>
</li>
<li><p>在命令行中 <code>ping www.baidu.com</code>：ping 不通，同样的提示信息。</p>
</li>
<li><p>在命令行中 <code>telnet www.目标网址.com 443</code>：<strong>提示无法打开到主机的连接，在端口443，连接失败。</strong>（博主自己的电脑可以）</p>
</li>
<li><p>在命令行中 <code>ping 221.**.**.190(目标网址IP)</code>：可以ping通</p>
</li>
<li><p>在命令行中 <code>ping 111.206.223.172(百度网址的IP)</code>：可以ping通</p>
<p>可以发现客户电脑在 <code>ping</code> 域名时无法ping通，在直接 <code>ping</code>IP地址时可以ping通。推测是客户电脑在解析域名为IP地址时发生问题。</p>
</li>
<li><p>在命令行中 <code>nslookup www.目标网址.com</code>：失败（意料之中）</p>
</li>
<li><p>在命令行中 <code>nslookup www.baidu.com</code>：失败</p>
<p>由此可以判断是客户电脑DNS配置有问题，在解析域名时失败。</p>
</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>配置DNS服务器<strong>手动模式</strong>，输入<code>8.8.8.8</code></li>
<li>在命令行中刷新DNS缓存，执行 <code>ipconfig /flushdns</code></li>
<li>在命令行中（管理员身份）重置网络配置，执行 <code>netsh winsock reset</code></li>
<li>重新启动</li>
</ul>
</li>
</ol>
<hr>
<h4 id="四、事后"><a href="#四、事后" class="headerlink" title="四、事后"></a>四、事后</h4><p>通过一步一步的排查故障，到最后解决之后，感觉浑身通畅、无比舒服，也许这就是计算机的魅力之处吧</p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub搭建部署个人网站</title>
    <url>/2020/02/29/Hexo-GitHub%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><ul>
<li>安装 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
<li>安装 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li>
</ul>
<hr>
<h4 id="二、安装配置Hexo"><a href="#二、安装配置Hexo" class="headerlink" title="二、安装配置Hexo"></a>二、安装配置Hexo</h4><ol>
<li><p>安装</p>
<p>打开Git-bash，输入以下命令安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化<br>选择合适的文件夹，如 <code>E:\hexo</code>，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd E:\hexo</span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>执行成功后，在 <code>hexo</code>文件夹下的目录结构类似为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _config.yml </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source|   </span><br><span class="line">├       ├── _drafts|   </span><br><span class="line">├       └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<ul>
<li>_config.yml: 网站的配置 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 文件，可以在此配置大部分的参数。</li>
<li>文件详细介绍可见 <a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">Hexo 官方网站</a></li>
</ul>
</li>
<li><p>测试，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>按照信息提示，使用浏览器访问 <code>http://localhost:4000/</code>。可以看到Hexo默认主题则说明本地建站成功。</p>
</li>
<li><p>修改主题</p>
<p>本网站使用的是 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next 主题</a></p>
<ul>
<li><p>下载主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用主题<br>修改 <code>_config.yml</code> 文件，找到 <code>theme</code>字段，并将其值改为 <code>next</code></p>
</li>
<li><p>验证主题<br>执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p> 此时使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行 <code>Next</code>主题。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="三、配置GitHub"><a href="#三、配置GitHub" class="headerlink" title="三、配置GitHub"></a>三、配置GitHub</h4><ul>
<li><p>创建仓库</p>
<p>新建一个名为<code>GitHub账户名.github.io</code>的仓库，之后网站的访问网址就是<code>http://GitHub账户名.github.io</code></p>
</li>
</ul>
<hr>
<h4 id="四、将Hexo部署到GitHub-Pages"><a href="#四、将Hexo部署到GitHub-Pages" class="headerlink" title="四、将Hexo部署到GitHub Pages"></a>四、将Hexo部署到GitHub Pages</h4><ol>
<li><p>安装 <code>hexo-deploy-git</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>_config.yml</code> 文件，找到<code>deploy</code> 配置项，修改为如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo:  https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt; </span><br><span class="line">    #示例：https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io </span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>注：要确保可以向 <code>GitHub</code>正常 <code>Push</code>，若出错，请检查是否配置好了<code>ssh key</code></p>
</li>
<li><p>验证部署<br>使用浏览器打开 <code>http://GitHub账户名.github.io</code>，验证是否部署成功。</p>
</li>
</ol>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~</p>
</blockquote>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫篇-动态网页的处理方式下:模拟浏览器行为</title>
    <url>/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8B-%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>在上篇文章<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/#more" target="_blank" rel="noopener">爬虫篇-动态网页的处理方式中:渲染动态网页</a>中，我们使用<code>WebKit</code>库，可以自定义浏览器渲染引擎，这样就可以完全控制想要执行的行为。如果不需要那么高的灵活性，那么还有一个不错的替代品 <a href="https://docs.seleniumhq.org/" target="_blank" rel="noopener">Selenium</a> 可以选择，它提供了使浏览器自动化的API 接口。</p>
<hr>
<h4 id="Selenium-简介："><a href="#Selenium-简介：" class="headerlink" title="Selenium 简介："></a>Selenium 简介：</h4><p>Selenium 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持市面上几乎所有的主流浏览器。</p>
<p>本来打算使用的是selenium + PhantomJS的组合，但发现Chrome以及FireFox也相继推出无头 ( <em>headless</em> ) 浏览器模式，个人比较倾向Chrome。本文采用的是Selenium+Chrome的组合。</p>
<hr>
<h4 id="爬虫示例："><a href="#爬虫示例：" class="headerlink" title="爬虫示例："></a>爬虫示例：</h4><p>运用到爬虫中的思路是：</p>
<ul>
<li>使用Selenium 渲染网页，解析渲染后的网页源码，或者直接通过Selenium 接口获取页面中的元素。</li>
</ul>
<p>还是以 <a href="http://book.sina.com.cn/excerpt/" target="_blank" rel="noopener">新浪读书——书摘</a> 这个网站为例，目标是获取列表中每篇文章详情页的地址，直接看示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinaBookSpider</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建可见的Chrome浏览器， 方便调试</span></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建Chrome的无头浏览器</span></span><br><span class="line">    <span class="comment"># opt = webdriver.ChromeOptions()</span></span><br><span class="line">    <span class="comment"># opt.set_headless()</span></span><br><span class="line">    <span class="comment"># driver = webdriver.Chrome(options=opt)</span></span><br><span class="line"></span><br><span class="line">    driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    total = <span class="number">1526</span>  <span class="comment"># 预先计算的总数据量</span></span><br><span class="line">    count = <span class="number">0</span>  <span class="comment"># 已爬取的数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录解析以及翻页位置</span></span><br><span class="line">    location = <span class="number">0</span></span><br><span class="line">    click_times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        开始爬虫</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># get方式打开网页</span></span><br><span class="line">        self.driver.get(<span class="string">"http://book.sina.com.cn/excerpt/rwws/"</span>)</span><br><span class="line"></span><br><span class="line">        self.parselist()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.count &lt; self.total:</span><br><span class="line">            <span class="keyword">if</span> self.click_times <span class="keyword">is</span> <span class="number">2</span>:</span><br><span class="line">                self.driver.find_element_by_css_selector(<span class="string">'#subShowContent1_page &gt; span:nth-child(6) &gt; a'</span>).click()</span><br><span class="line">                <span class="comment"># 等待页面加载完成</span></span><br><span class="line">                time.sleep(<span class="number">5</span>)</span><br><span class="line">                self.click_times = <span class="number">0</span></span><br><span class="line">                self.location = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.driver.find_element_by_css_selector(<span class="string">'#subShowContent1_loadMore'</span>).click()</span><br><span class="line">                <span class="comment"># 等待页面加载完成</span></span><br><span class="line">                time.sleep(<span class="number">3</span>)</span><br><span class="line">                self.click_times += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 分析加载的新内容，从location开始</span></span><br><span class="line">            self.parselist()</span><br><span class="line">        self.driver.quit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parselist</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        解析列表</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        divs = self.driver.find_elements_by_class_name(<span class="string">"item"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.location, len(divs)):</span><br><span class="line">            link = divs[i].find_element_by_tag_name(<span class="string">'a'</span>).get_attribute(<span class="string">"href"</span>)</span><br><span class="line">            <span class="keyword">print</span> link</span><br><span class="line">            self.location += <span class="number">1</span></span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> self.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    spider = SinaBookSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 代码地址：<a href="https://github.com/linbo-lin/dynamic-web-process" target="_blank" rel="noopener">dynamic-web-process —— GitHub</a><br> 如果你想实际运行上述代码，请在运行之前确定：安装了与浏览器版本对应的驱动，并正确的添加到了环境变量中。</p>
</blockquote>
<p>使用<code>selenium</code>时同样要特别注意的是如何确定<strong>网页是否加载完成</strong>，有三种方式：</p>
<ul>
<li>强制等待</li>
<li>隐形等待</li>
<li>显性等待</li>
</ul>
<blockquote>
<p>有关这三种方式的讲解可以看这里：<a href="https://huilansame.github.io/huilansame.github.io/archivers/sleep-implicitlywait-wait" target="_blank" rel="noopener">Python selenium —— 一定要会用selenium的等待，三种等待方式解读 —— 灰蓝的博客</a></p>
</blockquote>
<hr>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>到此，我们介绍了动态页面处理的三种思路：</p>
<ul>
<li><a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8A-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" target="_blank" rel="noopener">逆向工程</a></li>
<li>渲染动态页面：<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/" target="_blank" rel="noopener">使用<code>PySide</code>或<code>ghost.py</code></a></li>
<li><a href="">selenium 模拟浏览器</a></li>
</ul>
<p>做一下简单的比较：</p>
<ul>
<li>前者在运行上更快，开销更小。在实际情况中，大多数网页都可以被逆向，但是有些网页足够复杂逆向要花费极大的功夫。</li>
<li>后两者在思路上更直观，更容易被接受和理解。浏览器渲染引擎能够为我们节省了解网站后端工作原理的时间，但是渲染网页增大了开销，使其比单纯下载HTML更慢。另外，使用后两者通常需要轮训网页来检查是否已经得到所需的HTML元素，这种方式非常脆弱，在网络较慢时经常会失败。</li>
</ul>
<p>采用哪种方法，取决于爬虫活动中的具体情况：</p>
<ul>
<li>易于逆向、对速度和资源要求高的，应使用前者；</li>
<li>难以逆向、没有工程上的优化的要求的，可以使用后者。</li>
</ul>
<p>个人认为模拟浏览器的方法应尽量避免，因为浏览器环境对内存和CPU的消耗非常多，可以作为短期决绝方案，此时长期的性能和可靠性并不算重要；而作为长期解决方案，我会尽最大努力对网站进行逆向工程。</p>
<blockquote>
<p>本文有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫篇-动态网页的处理方式中:渲染动态网页</title>
    <url>/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>上一篇文章中我们介绍了爬取动态网页的一种方式：<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8A-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/#more" target="_blank" rel="noopener">逆向工程</a></p>
<p>这种方式有一点美中不足：这种方式要求我们对JavaScript以及Ajax有一定的了解，而且当网页的JS代码混乱，难以分析的时候，上述过程会花费我们大量的时间和精力。</p>
<p>这时候，如果对爬虫的执行效率没有过多要求，又不想浪费太多时间在了解JavaScript代码逻辑、找寻Ajax请求链接上，我们可以尝试另一种方式——<strong>渲染动态网页</strong> 。</p>
<hr>
<h4 id="浏览器渲染引擎："><a href="#浏览器渲染引擎：" class="headerlink" title="浏览器渲染引擎："></a>浏览器渲染引擎：</h4><p>在介绍这种方式之前，我们需要首先了解一些浏览器渲染引擎的基本知识。渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。浏览器向服务器发送请求，得到服务器返回的资源文件后，经过需要渲染引擎的处理，将资源文件显示在浏览器窗口中。目前使用较为广泛的渲染引擎有两种：</p>
<ul>
<li>webkit——使用者有Chrome, Safari</li>
<li>Geoko——使用者有Firefox</li>
</ul>
<p><strong>渲染主流程：</strong></p>
<ul>
<li><p>渲染引擎首先通过网络获得所请求文档的内容；</p>
</li>
<li><p>下面是渲染引擎在取得内容之后的基本流程：</p>
<p><code>解析html以构建dom树</code> -&gt; <code>构建render树</code> -&gt; <code>布局render树</code> -&gt; <code>绘制render树</code></p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/aHR0cHM6Ly9waWMwMDIuY25ibG9ncy5jb20vaW1hZ2VzLzIwMTEvMjY1MTczLzIwMTExMTAzMTYyNjM3MTUucG5n.jfif" style="zoom:67%;" />
</li>
<li><p>渲染引擎开始解析html，并将标签转化为内容树中的dom节点。如果遇到JS，那么此时会启用单独连接进行下载，并且在下载后进行解析。</p>
</li>
<li><p>接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树—render树。</p>
<p>Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。</p>
</li>
<li><p>Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。</p>
</li>
<li><p>再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</p>
</li>
</ul>
<p>想要了解更多有关浏览器渲染引擎的知识，可以阅读这些：</p>
<ul>
<li><p><a href="http://www.cnblogs.com/lhb25/p/how-browsers-work.html#Resources" target="_blank" rel="noopener">前端文摘：深入解析浏览器的幕后工作原理</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xiaozhuxmen/article/details/52014901" target="_blank" rel="noopener">浏览器加载、解析、渲染的过程</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xifeijian/article/details/10813339" target="_blank" rel="noopener">浏览器加载和渲染html的顺序-css渲染效率的探究</a></p>
</li>
</ul>
<p><strong>思考：</strong></p>
<p>了解了浏览器渲染引擎的基本原理，我们可以发现：</p>
<ul>
<li>当浏览器渲染引擎完成了dom树以及render树的构建之后，树中就已经包含了我们在浏览器窗口中可以看到的所有数据。</li>
</ul>
<p>那么我们就有了一种爬取动态网页的新思路：</p>
<ul>
<li>在浏览器渲染引擎执行<code>layout</code>以及<code>printing</code>之前，得到<code>dom</code>树或者<code>render</code>树，从树中获取动态加载的数据。</li>
</ul>
<hr>
<h4 id="渲染动态网页："><a href="#渲染动态网页：" class="headerlink" title="渲染动态网页："></a>渲染动态网页：</h4><p>有两种选择：</p>
<ul>
<li><p>自己从头实现一个浏览器渲染引擎，在合适的时机返回构建的<code>dom</code>树或<code>render</code>树。这需要进行大量的工作，需要考虑html、js、css等不同格式文件的解析方式以及解析顺序等。</p>
<p>本人参考以下资料进行了尝试，但最终没有成功，有兴趣的可以尝试下。</p>
<ul>
<li><p><a href="http://ju.outofmemory.cn/entry/36085" target="_blank" rel="noopener">使用PyV8解析HTML 文档</a> （文中提到的demo可以从下面的链接得到）</p>
</li>
<li><p><a href="https://storage.googleapis.com/google-code-archive-source/v2/code.google.com/pyv8/source-archive.zip" target="_blank" rel="noopener">PyV8源码以及demo</a></p>
</li>
</ul>
</li>
<li><p>利用已有的渲染引擎。</p>
</li>
</ul>
<p>接下来将使用WebKit 渲染引擎，通过 <a href="http://pyside.github.io/docs/pyside/" target="_blank" rel="noopener">PySide</a> 这个python库可以获得该引擎的一个便捷接口。</p>
<hr>
<h4 id="爬虫示例："><a href="#爬虫示例：" class="headerlink" title="爬虫示例："></a>爬虫示例：</h4><p>还是以 <a href="http://book.sina.com.cn/excerpt/rwws/" target="_blank" rel="noopener">新浪读书——书摘</a> 为例，可以发现：页面中文章列表的部分是动态加载的。</p>
<p><strong>爬虫代码：</strong></p>
<p>使用<code>PySide</code>库进行处理的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PySide.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide.QtWebKit <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    url = <span class="string">"http://book.sina.com.cn/excerpt/rwws/"</span></span><br><span class="line"></span><br><span class="line">    app = QApplication([])  <span class="comment"># 完成其他Qt对象之前，必须先创建该对象</span></span><br><span class="line">    webview = QWebView()  <span class="comment"># 该对象是Web 对象的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用show方法显示窗口</span></span><br><span class="line">    <span class="comment"># webview.show()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置循环事件， 并等待网页加载完成</span></span><br><span class="line">    loop = QEventLoop()</span><br><span class="line">    webview.loadFinished.connect(loop.quit)</span><br><span class="line">    webview.load(QUrl(url))</span><br><span class="line">    loop.exec_()</span><br><span class="line"></span><br><span class="line">    frame = webview.page().mainFrame()  <span class="comment"># QWebFrame类有很多与网页交互的有用方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到页面渲染后的html代码</span></span><br><span class="line">    html = frame.toHtml()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> html</span><br></pre></td></tr></table></figure>

<p>通过<code>print</code>语句，我们可以发现：页面的源码<code>html</code>中已经包含了动态加载的内容。</p>
<p><strong>与网站交互：</strong></p>
<p>得到动态加载的内容后，需要解决的另一个问题是翻页问题。还好<code>PySide</code>库的<code>QWebKit</code>模块还有一个名为<code>QWebFrame</code>的类，支持很多与网页的交互操作。如“点击”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据CSS Selector 找到所需“进行翻页”的元素</span></span><br><span class="line">elem = frame.findFirstElement(<span class="string">'#subShowContent1_loadMore'</span>)</span><br><span class="line"><span class="comment"># 点击：通过evaluateJavaScript()函数可以执行Js代码</span></span><br><span class="line">elem.evaluateJavaScript(<span class="string">'this.click()'</span>)</span><br></pre></td></tr></table></figure>

<p>除了点击事件，还可以进行填充表单，滚动窗口等操作。</p>
<p><strong>数据加载时间：</strong></p>
<p>需要注意的是，在进行了翻页、或者获取更多内容时，一个最大的难点在于如何确定页面是否完成了加载，因为我们难以估计Ajax事件或者Js准备数据的时间。对于这个问题有两种解决思路：</p>
<ul>
<li><p>等待固定的一段时间，比如<code>time.sleep(3)</code>：这种方法容易实现，但效率较低；</p>
</li>
<li><p>轮询网页，等待特定内容出现；这种方法虽然会在检查是否加载完成时浪费CPU周期，但更加可靠。以下是一个简单的实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elem = <span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> elem:</span><br><span class="line">    app.processEvents()</span><br><span class="line">    elem = frame.findAllElemnets(<span class="string">'#pattern'</span>)</span><br></pre></td></tr></table></figure>

<p>代码循环，直到出现特定元素。每次循环，调用<code>app.processEvents()</code>方法，用于给Qt事件循环执行任务的时间，比如响应点击事件。</p>
<blockquote>
<p>更多有关PySide的内容请看这里：<a href="http://pyside.github.io/docs/pyside/" target="_blank" rel="noopener">PySide官方文档</a></p>
</blockquote>
<hr>
<h4 id="ghost-py"><a href="#ghost-py" class="headerlink" title="ghost.py"></a>ghost.py</h4><p>但是<code>PySide</code>毕竟是一个为了Python的GUI 编程而开发的， 其功能对于爬虫来说实在是太过于庞大，所以我们可以把爬虫经常使用的功能进行封装，来提升编写爬虫的效率。<a href="http://ghost-py.readthedocs.io/en/latest/#" target="_blank" rel="noopener">ghost.py</a>  是目前一个针对爬虫且功能比较完善的<code>PySide</code>的封装模块，使用它可以很方便的进行数据采集。</p>
<p>还是以获取列表页中每篇文章详情页地址为目标，直接看示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ghost <span class="keyword">import</span> Ghost, Session</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinaBookSpider</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化相关参数</span></span><br><span class="line">    gh = Ghost()</span><br><span class="line">    ss = Session(gh, display=<span class="literal">True</span>)  <span class="comment"># 设置display为true, 方便调试</span></span><br><span class="line"></span><br><span class="line">    total = <span class="number">1526</span>  <span class="comment"># 预先计算的总数据量</span></span><br><span class="line">    count = <span class="number">0</span>  <span class="comment"># 已爬取的数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录解析以及翻页位置</span></span><br><span class="line">    location = <span class="number">0</span></span><br><span class="line">    click_times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        开始爬虫</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 打开网页</span></span><br><span class="line">        self.ss.open(<span class="string">"http://book.sina.com.cn/excerpt/rwws/"</span>)</span><br><span class="line">        <span class="comment"># 等待数据加载完成</span></span><br><span class="line">        self.ss.wait_for_selector(<span class="string">'#subShowContent1_static &gt; div:nth-child(20)'</span>)</span><br><span class="line"></span><br><span class="line">        self.parselist()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.count &lt; self.total:</span><br><span class="line">            <span class="keyword">if</span> self.click_times <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 点击加载更多</span></span><br><span class="line">                self.ss.click(<span class="string">'#subShowContent1_loadMore'</span>)</span><br><span class="line">                <span class="comment"># 每次翻页，或加载更多，要等待至加载完成</span></span><br><span class="line">                self.ss.wait_for_selector(<span class="string">'#subShowContent1_static &gt; div:nth-child(21)'</span>)</span><br><span class="line"></span><br><span class="line">                self.click_times += <span class="number">1</span></span><br><span class="line">                self.parselist()</span><br><span class="line">            <span class="keyword">elif</span> self.click_times <span class="keyword">is</span> <span class="number">1</span>:</span><br><span class="line">                self.ss.click(<span class="string">'#subShowContent1_loadMore'</span>)</span><br><span class="line">                self.ss.wait_for_selector(<span class="string">'#subShowContent1_static &gt; div:nth-child(41)'</span>)</span><br><span class="line"></span><br><span class="line">                self.click_times += <span class="number">1</span></span><br><span class="line">                self.parselist()</span><br><span class="line">            <span class="keyword">elif</span> self.click_times <span class="keyword">is</span> <span class="number">2</span>:</span><br><span class="line">                self.ss.click(<span class="string">'#subShowContent1_page .pagebox_next a'</span>)</span><br><span class="line">                self.ss.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                self.click_times = <span class="number">0</span></span><br><span class="line">                self.location = <span class="number">0</span></span><br><span class="line">                self.parselist()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parselist</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        解析列表页</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        html = self.ss.content.encode(<span class="string">'utf8'</span>)</span><br><span class="line">        <span class="comment"># print html</span></span><br><span class="line"></span><br><span class="line">        pattern = re.compile(<span class="string">r'&lt;div class="item"&gt;&lt;h4&gt;&lt;a href="(.*?)" target="_blank"&gt;'</span>, re.M)</span><br><span class="line">        links = pattern.findall(html)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.location, len(links)):</span><br><span class="line">            <span class="keyword">print</span> links[i]</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            self.location += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> self.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    spider = SinaBookSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 代码地址：<a href="https://github.com/linbo-lin/dynamic-web-process" target="_blank" rel="noopener">dynamic-web-process —— GitHub</a></p>
</blockquote>
<p><strong>补充：</strong></p>
<ul>
<li><p><code>ghost.py</code>对直接获取元素支持的不是很好，但可以借助<code>BeautifulSoup</code>或<code>正则表达式</code>来解决。</p>
</li>
<li><p><code>ghost.py</code>支持与网页的简单交互，如点击，填充表单等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set_field_value(*args, **kwargs)</span><br><span class="line">fill(*args, **kwargs)</span><br><span class="line">click(*args, **kwargs)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ghost.py</code>很好的解决了<strong>确定元素加载完成</strong>的问题，通过以下方法可以让爬虫等待，直到满足设置的条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wait_for(condition, timeout_message, timeout=<span class="literal">None</span>)</span><br><span class="line">wait_for_page_loaded(timeout=<span class="literal">None</span>)</span><br><span class="line">wait_for_selector(selector, timeout=<span class="literal">None</span>)</span><br><span class="line">wait_for_text(text, timeout=<span class="literal">None</span>)</span><br><span class="line">wait_while_selector(selector, timeout=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有关更多<code>ghost.py</code>的方法请看这里：<a href="http://ghost-py.readthedocs.io/en/latest/#" target="_blank" rel="noopener">Ghost.py</a></p>
<hr>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>动态网页</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫篇-动态网页的处理方式上:逆向工程</title>
    <url>/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8A-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="动态网页简介："><a href="#动态网页简介：" class="headerlink" title="动态网页简介："></a>动态网页简介：</h4><p>在我们编写爬虫时，可能会碰到以下两种问题：</p>
<ul>
<li>我们所需要爬取的数据在网页源代码中并不存在；</li>
<li>点击下一页跳转页面时，网页的URL 并没与发生变化；</li>
</ul>
<p>造成这种问题原因是，你所正在爬取的页面采取了动态加载的方式，是一个动态网页。所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码生成，页面的内容和显示效果就不会发生变化了。而动态网页则不然，其显示的页面则是经过Javascript处理数据后生成的结果，可以发生改变。这些数据的来源有多种，可能是经过Javascript计算生成的，也可能是通过Ajax加载的。动态网页经常使用的一种技术是Ajax请求技术。</p>
<p><code>Ajax(Asynchronous JavaScript and XML)</code>，其最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页的内容。想要了解更多有关Ajax技术的可以看这里：</p>
<ol>
<li><a href="http://www.runoob.com/ajax/ajax-tutorial.html" target="_blank" rel="noopener">AJAX教程——菜鸟教程</a></li>
<li><a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">jQuery ajax -ajax()方法——W3school</a></li>
</ol>
<p>目前，越来越多的网站采取的是这种动态加载网页的方式，一来是可以实现web开发的前后端分离，减少服务器直接渲染页面的压力；二来是可以作为反爬虫的一种手段。</p>
<hr>
<h4 id="爬虫处理动态页面的三种方式："><a href="#爬虫处理动态页面的三种方式：" class="headerlink" title="爬虫处理动态页面的三种方式："></a>爬虫处理动态页面的三种方式：</h4><ul>
<li>逆向工程</li>
<li>渲染动态网页：使用<code>pyside</code>或<code>ghost.py</code><ul>
<li>selenium模拟浏览器</li>
</ul>
</li>
</ul>
<hr>
<h4 id="逆向工程："><a href="#逆向工程：" class="headerlink" title="逆向工程："></a>逆向工程：</h4><p>对于动态加载的网页，我们想要获取其网页数据，需要了解网页是如何加载数据的，该过程就被成为<strong>逆向工程</strong>。对于使用了Ajax 请求技术的网页，我们可以找到Ajax请求的具体链接，直接得到Ajax请求得到的数据。需要注意的是，构造Ajax请求有两种方式：</p>
<ul>
<li>原生的Ajax请求，会直接创建一个<code>XMLHTTPReques</code>t对象。</li>
<li>调用jQuery的ajax()方法。一般情况下，<code>$.ajax()</code>会返回其创建的<code>XMLHTTPRequest</code>对象；但是，如果<code>$.ajax()</code>的<code>dataType</code>参数指定了为<code>script</code>或<code>jsonp</code>类型，<code>$.ajax()</code>不再返回其创建的<code>XMLHTTPRequest</code>对象。</li>
</ul>
<p>对于这两种方式，只要创建返回了<code>XMLHTTPRequest</code>对象，就可以通过Chrome浏览器的调试工具在<code>NetWork</code>窗口通过设置<code>XHR</code>过滤条件，直接筛选出Ajax请求的链接；如果是<code>$.ajax()</code>并且<code>dataType</code>指定了为<code>script</code>或<code>jsonp</code>，则无法通过这种方式筛选出来。</p>
<hr>
<h4 id="爬虫示例："><a href="#爬虫示例：" class="headerlink" title="爬虫示例："></a>爬虫示例：</h4><p>接下来以 <a href="http://book.sina.com.cn/excerpt/" target="_blank" rel="noopener">新浪读书——书摘</a> 这个网站的爬取为例，介绍如何得到无法筛选出来的Ajax请求链接：</p>
<p>在Chrome中打开网页，右键<code>检查</code>，会发现首页中书摘列表包含在一个id为<code>subShowContent1_static</code>的div中，而<code>查看网页源代码</code>会发现id为<code>subShowContent1_static</code>的div为空。点击<code>更多书摘</code>或<code>下一页</code>时，网页URL并没有发生变化。与我们最前面所说的两种情况相同。</p>
<p><code>F12</code>打开调试工具，打开<code>NetWork</code>窗口<em>（功能是记录浏览器的活动记录<code>network activities</code>）</em>，<code>F5</code>刷新，可以看到浏览器发送以及接收到的数据记录，其实我们所找的Ajax请求链接就是其中一条。</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194144329.png" alt="活动记录" style="zoom:80%;" />

<p><strong>第一步：</strong></p>
<p>首先设置<code>XHR</code>过滤条件，发现筛选结果为空白，可以推断出这个网页采用的Ajax请求应该是设置了<code>dataType</code>为<code>script</code>或者<code>jsonp</code>。</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194303975.png" alt="xhr" style="zoom:80%;" /> 

<p>重新打开调试工具，点击网页上的<code>更多书摘</code>，发现<code>NetWork</code>窗口出现了很多记录，网页也多了新的内容，说明浏览器向服务器发送了请求。在网页上，右键<code>检查</code> <code>更多书摘</code>，观察此元素绑定的JavaScript事件：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/2019012119433920.png" alt="Javascript"></p>
<blockquote>
<p>根据JavaScript的知识：<code>javascript:</code>是一个伪协议，表示在触发<code>&lt;a&gt;</code>时，执行一段JavaScript代码，而<code>javascript:;</code>表示什么都不执行，这样点击<code>&lt;a&gt;</code>时就没有任何反应。但一般在这种情况下，会给<code>&lt;a&gt;</code>绑定一个事件回调，来执行业务.</p>
</blockquote>
<p>接下来就需要在网页的JavaSCript代码中找到<code>更多书摘</code>所触发的回调函数。</p>
<p><strong>第二步：</strong></p>
<p>右键<code>检查网页源代码</code>，<code>Ctrl+F</code>搜索<code>subShowContent1_loadMore”</code>(元素<code>更多书摘</code>的id)，发现并没有某个具体的函数与之相关：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194406987.png" alt="函数" style="zoom:80%;" />

<p>这说明<code>更多书摘</code>的回调函数不在网页自身写的JavaScript代码中，那就应该在网页嵌入的JS文件中（通过<code>&lt;script type=”text/javascript” src=“***.js”&gt; &lt;script&gt;</code>这种形式调用的JS文件）。</p>
<p><strong>第三步：</strong></p>
<p>逐个打开嵌入的JS文件，查找与<code>更多书摘</code>绑定的函数，终于在“<a href="http://n.sinaimg.cn/book/js/feedlist.js”这个JS文件中发现函数`$()`如下：" target="_blank" rel="noopener">http://n.sinaimg.cn/book/js/feedlist.js”这个JS文件中发现函数`$()`如下：</a></p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194456854.png" alt="函数" style="zoom:80%;" />

<p>但此函数中并没有直接构造Ajax请求，而是通过调用<code>ListMore()</code>函数执行。继续查找<code>ListMore()</code>函数，发现其内部还是未构造Ajax请求，通过<code>ListMore()</code>内部调用的函数进一步寻找，经过以下过程：<code>$()</code> -&gt; <code>ListMore()</code> -&gt; <code>GetmoreList()</code> -&gt; <code>getMore()</code> 。终于在<code>getMore()</code>函数中发现了Ajax请求的构造过程，发现<code>dataType</code>确实是<code>jsonp</code>：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194526155.png" alt="函数" style="zoom:80%;" />

<p><strong>第四步：</strong></p>
<p>在<code>NetWork</code>窗口<code>Initiator</code>栏点击<code>feedlist.js</code>进入<code>Sources</code>窗口，在<code>$.ajax()</code>处添加断点，<code>F5</code>刷新，Javascript执行到断点处会停止，鼠标分别指在<code>url</code>,<code>data</code>处观察数据：</p>
<p><img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194551812.png" style="zoom:80%;" />          <img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194605181.png" style="zoom:80%;" />       <img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/2019012119463585.png" style="zoom:80%;" /></p>
<ul>
<li>得到了url以及data的格式，就可以根据<code>jQuery</code>的<code>ajax()</code>用法构造正确的Ajax 请求链接：</li>
</ul>
<blockquote>
<p><a href="http://feed.mix.sina.com.cn/api/roll/get?callback=jsonp1522410869405&amp;pageid=96&amp;lid=560&amp;num=20&amp;page=1" target="_blank" rel="noopener">http://feed.mix.sina.com.cn/api/roll/get?callback=jsonp1522410869405&amp;pageid=96&amp;lid=560&amp;num=20&amp;page=1</a></p>
</blockquote>
<ul>
<li>在浏览器输入构造的链接进行验证，对比网页数据，发现这就是我们需要的Ajax请求链接。</li>
</ul>
<p><strong>第五步：</strong></p>
<p>之前我们说过，在<code>NetWork</code>窗口就有我们需要的Ajax请求链接，对比发现，果然存在：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194719925.png" style="zoom:80%;" />

<p>当我们点击<code>更多书摘</code>、<code>下一页</code>时，发现又多了几条这样的请求：</p>
<img src="https://raw.githubusercontent.com/linbo-lin/cloudimg/master/img/20190121194737517.png" style="zoom:80%;" />

<p>对比发现：只有<code>jsonp**********</code>与<code>page=*</code>这两部分不同， <code>jsonp</code>后面跟的数字为当前时间的时间戳，是<code>jQuery.ajax()</code>方法自动计算添加的，<code>page</code>后面就是页数，这时候我们只要改变page后面的数字就可以构造翻页的链接了。</p>
<hr>
<h4 id="方法小结："><a href="#方法小结：" class="headerlink" title="方法小结："></a>方法小结：</h4><ul>
<li>首先通过设置<code>XHR</code>过滤条件，观察是否可以直接得到Ajax 请求；如果不可以，继续下一步。</li>
<li>查找能够发送Ajax请求的元素绑定的事件或回调函数：首先在网页源代码中查找，没有的话，逐个查找嵌入的JS文件。</li>
<li>找到之后，看函数内部是否直接构造Ajax请求，没有直接构造的话，根据函数调用关系一步一步查找，直到找到构造过程为止。</li>
<li>添加断点，调试，根据Ajax请求的构造方式以及数据形式手动构造链接。 </li>
<li>验证构造的链接的正确性。</li>
</ul>
<p>其实当你有了经验之后，对一些不是很复杂的网页，根本就不用进行这么复杂的逆向工程，凭URL形式可以很快的在<code>NetWork</code>窗口很快的 <strong>选择-验证</strong> 出所需的Ajax请求。</p>
<p>得到Ajax请求链接之后，可以直接得到请求的数据，一般为json格式，处理后即可使用。</p>
<blockquote>
<p>代码见：<a href="https://github.com/linbo-lin/dynamic-web-process" target="_blank" rel="noopener">dynamic-web-process —— GitHub</a></p>
</blockquote>
<hr>
<h4 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h4><p>本文以 <a href="http://book.sina.com.cn/excerpt/" target="_blank" rel="noopener">新浪读书——书摘 </a>这个示例，介绍了如何得到Ajax请求链接，这是爬取动态网页时可以采取的一种方式，这种方式可能会在寻找Ajax请求的过程中浪费一点时间，并且要求对JavaScript有一定的了解，但找到链接后，爬取的过程可以很迅速。</p>
<p>如果对爬虫执行效率没有过多要求，又不想浪费太多时间在了解JavaScript代码逻辑、找寻Ajax请求链接上，可以参看下一篇文章<a href="https://linbo-lin.github.io/2018/05/15/%E7%88%AC%E8%99%AB%E7%AF%87-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD-%E6%B8%B2%E6%9F%93%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/#more" target="_blank" rel="noopener">爬虫篇-动态网页的处理方式中: 渲染动态网页</a>，这篇文章提供了爬取动态网页的另一种思路。</p>
<blockquote>
<p>文中有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
        <tag>Ajax</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ConfigParser模块读取、写入文件时自动转换为小写字符的问题</title>
    <url>/2018/01/03/%E8%A7%A3%E5%86%B3ConfigParser%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E6%97%B6%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B0%8F%E5%86%99%E5%AD%97%E7%AC%A6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>最近在使用ConfigParser模块时，发现一个问题：</p>
<ul>
<li><strong>在写入文件时，无论原字符是大写还是小写，ConfigParser option 总是把它转换为小写字符，然后再写入。</strong></li>
</ul>
<p>查阅资料后发现是ConfigParser中optionxform()函数的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optionxform</span><span class="params">(self, optionstr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> optionstr.lower() <span class="comment">#转化为了小写字符</span></span><br></pre></td></tr></table></figure>



<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul>
<li>第一种解决法案是改源码，直接将<code>def optionxform()</code>函数中<code>.lower()</code>去掉：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optionxform</span><span class="params">(self, optionstr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> optionstr</span><br></pre></td></tr></table></figure>

<p>此种解决方案的不足之处是只能在本机生效，换台机器就会出问题。</p>
<ul>
<li>第二种解决方案是自己写一个<code>MyConfigParser</code>，继承自<code>ConfigParser</code>，重写一下<code>optionxform()</code>方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> ConfigParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfigParser</span><span class="params">(ConfigParser.ConfigParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, defaults=None)</span>:</span></span><br><span class="line">        ConfigParser.ConfigParser.__init__(self, defaults=defaults)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optionxform</span><span class="params">(self, optionstr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> optionstr</span><br></pre></td></tr></table></figure>

<p>使用时使用自己写的<code>MyConfigParser</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conf = MyConfigParser()</span><br><span class="line">conf.read(<span class="string">"************"</span>)</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>本文有什么错误或不足之处，欢迎指出~~</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ConfigParser</tag>
      </tags>
  </entry>
</search>
